---
layout: post
permalink: An_Introduction_to_generating_sequences_with_SQL
ratings: 3
avgrate: 4.0000
user: Junglee
real_name: "Ashok Hariharan"
user_since: 28 Jan 2002
avatar: "/images/pictures/picture-20519.jpg"
article_count: 5
excerpt: "Did mama say that &quot;while&quot; and &quot;for&quot; loops were the only ways to generate patterned sequences? Well, mama was wrong! The plain old SQL SELECT statement will do just fine."
---
<p>Writing code to create a sequence is one of the first things taught in programming school.</p></p><p>Remember this code from your early Basic programming bootcamp?</p></p><p><code> For i = 1 to 10<br> Print i<br> Next i<br> </code></p></p><p>While loops (no pun intended) seem to be quite good at creating sequences,  we will soon see that they are actually quite inelegant and awkward.</p></p><p>Structured Query Language, a language oriented towards set-based operations, is  ideally suited to build sequences quickly and efficently.</p></p><p>Are sequences really useful in SQL? Yes they are! Here are some areas  where I have found sequences to be indispensable:</p></p><ul></p><li>to build calendar-type applications and leave-day/business-day calculations (tables    with ranges of dates)</li> </p><li>sales fact tables (tables with ranges of numbers or dates)</li> </p><li>creating volume data for volume testing of applications (tables    with ranges of numbers, dates or alpha-numeric values)</li></p></ul></p><h2>Enough, show me some SQL</h2></p><p>For all the examples in this article I have stuck to common  SQL syntax.  In a couple of instances where I have used database specific syntax it  should not be too hard to convert the syntax to any other database.   I tested all the syntax  on a SQL Server 2000 installation, but at the end of the article I have provided  the sample examples in both MS-Access and Oracle.</p></p><p>We'll start by creating a very simple table, a table that stores the integers  from 0 to 9. Let's call it 'tblInteger'. The table creation script could look  like this:</p></p><pre>Create Table tblInteger( anInteger int)</pre></p><p>Now fill up the table with the numbers from 0 to 9.</p></p><pre>insert into tblInteger values (0)</p>insert into tblInteger values (1) </p>insert into tblInteger values (2) </p>...</p>insert into tblInteger values (9) </pre></p><p>We'll be using this table extensively in the course of this article.</p></p><p>You've probably guessed by now the easiest way to generate a simple sequence  of 10 numbers:</p></p><p><code>Select anInteger from tblInteger</code></p></p><p>The query will output:</p></p><table border="1"></p><thead></p><tr><th>anInteger</th></tr></p></thead></p><tbody></p><tr><td>0</td></tr></p><tr><td>1</td></tr></p><tr><td>2</td></tr></p><tr><td>3</td></tr></p><tr><td>4</td></tr></p><tr><td>5</td></tr></p><tr><td>6</td></tr></p><tr><td>7</td></tr></p><tr><td>8</td></tr></p><tr><td>9</td></tr></p></tbody> </p></table></p><p><a name="sqlMultiplesof10"></a>And to generate a sequence of multiples of 10  from 0 to 90:</p></p><p><code>Select anInteger*10 as tens from tblInteger</code></p></p><table border="1"></p><thead> </p><tr><th>tens</th></tr></p></thead></p><tbody> </p><tr><td>0</td></tr></p><tr><td>10</td></tr></p><tr><td>20</td></tr></p><tr><td>30</td></tr></p><tr><td>40</td></tr></p><tr><td>50</td></tr></p><tr><td>60</td></tr></p><tr><td>70</td></tr></p><tr><td>80</td></tr></p><tr><td>90</td></tr></p></tbody> </p></table></p><h2>Duh? What's the big deal? A generated sequence of 10 numbers?</h2></p><p>Agreed. Generating a sequence of 10 numbers was simple enough as all the numbers  were hard coded in a table! But, when two sets (sequences) are combined using  a cartesian product, an entirely new set is created.</p></p><h3>Using a Cartesian Product</h3></p><p>Now we will generate a much larger sequence of 100 numbers, by combining the  two queries that we just saw.</p></p><pre>Select tblZeroToNine.anInteger</p>     + (tblTensFromZeroToNinety.anInteger*10)</p>           as NumberSequence</p>  from tblInteger as tblZeroToNine ,</p>       tblInteger as tblTensFromZeroToNinety</p>order by tblZeroToNine.anInteger </p>       + (tblTensFromZeroToNinety.anInteger*10)</pre></p><p>This will output a sequence of 100 numbers.</p></p><table  border="1"></p><thead> </p><tr><th>NumberSequence</th></tr></p></thead></p><tbody> </p><tr><td>0</td></tr></p><tr><td>1</td></tr></p><tr><td>2</td></tr></p><tr><td>3</td></tr></p><tr><td>...</td></tr></p><tr><td>98</td></tr></p><tr><td>99</td></tr></tbody> </p></table></p><p>What exactly happened here?</p></p><p>We used a &quot;cartesian product&quot; to combine two sets of numbers -- </p>one with a sequence of numbers from 0 to 9 and another with a staggered sequence </p>of numbers from 0 to 90, to generate a  completely new set of numbers.</p></p><p>How does a cartesian product work? Revisiting some good old set theory,   consider two very simple sets:</p></p><blockquote><p></p>set of Men = { Peter, Michael }<br></p>set of Women = { Amanda, Jennifer }</p></p></blockquote></p><p>The cartesian product of the set of Men and Women will first combine Peter with </p>Amanda and Jennifer, and then combine Michael with Amanda and Jennifer.</p>So the new set will have:</p></p><blockquote><p></p>cartesian product = { (Peter Amanda), (Peter Jennifer), (Michael Amanda), (Michael Jennifer) }</p></p></blockquote></p><p>Also note that in a cartesian product the sequence of elements is </p><strong>important</strong>,  which means &quot;Women cartesian product Men&quot; is not the same as &quot;Men cartesian  product Women&quot;, so (Peter Amanda) is not the same person as (Amanda Peter)  -- not unless they had multiple personality disorder!</p> </p><p>In this SQL example we had two sets, one with 10 numbers from {0 to 9} (call  that as set UNITS) and another set with 10 numbers in increments of 10 from {0 to  90} (set TENS). Every element in set UNITS is combined with every element in set TENS.  So the 0 from set UNITS is combined with 0, 10, 20, ... 90 from set TENS, then the  element 1 from set UNITS is again combined with all the elements in set TENS and so  on. We combine the elements using the arithmetic &quot;+&quot;.</p></p><h2>Building more sophisticated sequences</h2></p><p>With a bit of creativity we can extend this concept and build more sophisticated  sequences.</p></p><p>To build a sequence of 10 odd numbers we can use this query:</p></p><p><code>Select (2*anInteger)+1 From tblInteger</code></p></p><p>The above query will output numbers: 1,3,5,7, ... 19. (<em>Math note</em>:  to convert an integer value 'n' to an odd number, the formula is: <strong>2*n  + 1</strong>)</p></p><p>When combined with the <a href="/An_Introduction_to_generating_sequences_with_SQL#sqlMultiplesof10">query to build the sequence  of the first 10 multiples of 10</a> we can create a sequence of the first 50  odd numbers:</p></p><pre>Select distinct </p>       ( (2*tblFirst10oddNumbers.anInteger)+1 </p>       + (tblZeroToNinety.anInteger*10) ) </p>            as OddNumberSequence</p>  from tblInteger as tblFirst10oddNumbers , </p>       tblInteger as tblZeroToNinety</p> where (2*tblFirst10oddNumbers.anInteger)+1 +  </p>       (tblZeroToNinety.anInteger*10) < 100 </pre></p><p>We can also create sequences with dates. The following SQL query will return a </p>set containing the next hundred dates  from the present date.</p></p><pre>Select Getdate() + units.anInteger </p>                 + (tens.anInteger*10)</p>             as DateSequence</p>  from tblInteger as units ,</p>       tblInteger as tens</pre></p><p>In the above query, <code>Getdate()</code> is a SQL Server function to return  the current date; you can replace it with the &quot;date()&quot; function of  the database of your choice.</p></p><p>While the world of HTML has been a fairly recent adopter of standards, the  world of SQL has a long history of standards. SQL was adopted as an ISO standard  back in 1987. Eventually the standard was revised in 1992, and that version was  called SQL92 (now called SQL2). The SQL2 standard sets guidelines for conceptual  SQL features.</p></p><p>Similar to the w3.org compliance levels, SQL2 also supports various levels  of conformance -- entry level, intermediate and advanced.  Most modern databases   are typically measured against the SQL2 standard. The most recent SQL99 (or  SQL3) standard focuses on object oriented databases.</p> <p>If your database server supports some sophisticated syntax, you can easily build  complex patterned sequences. The following query makes use of SQL Server's <code>CASE() </code>syntax to generate a 1000 element long alpha-numeric sequence.</p></p><p class="side"><strong>Note</strong>: <br> <br> For those not familiar with SQL Server's <code>Case()</code> statement, it is  quite similar to the <code>IIF()</code> function in Access or the <code>decode()</code>  function in oracle. <br><br> And before you get all worked up about the use of proprietary SQL constructs, SQL Server's  <code>Case()</code> syntax is <a title="SQL92 standard" target="_blank" href="http://cui.unige.ch/db-research/Enseignement/analyseinfo/SQL92/simple_case.html">  SQL2 compliant</a>. <br><br> <em>Personal note: Now I am beginning to sound like one of those HTML compliance  article writers.</em></p></p><pre></p>Select Distinct  anAlphabet + </p>       ( Case </p>          When tblZeroToNine.anInteger</p>            + (tblTensFromZeroToNinety.anInteger*10) < 10 </p>          Then '00'+ Cast(tblZeroToNine.anInteger</p>                   + (tblTensFromZeroToNinety.anInteger*10) </p>                        as char(1))</p>          When (tblZeroToNine.anInteger</p>             + (tblTensFromZeroToNinety.anInteger*10) > 9 </p>           and tblZeroToNine.anInteger </p>             + (tblTensFromZeroToNinety.anInteger*10)<= 99) </p>          Then '0'+ Cast(tblZeroToNine.anInteger  </p>                  + (tblTensFromZeroToNinety.anInteger*10) </p>                        as char(2))</p>          Else '0000'</p>         End ) as alphaSeq</p>  from tblInteger as tblZeroToNine ,</p>       tblInteger as tblTensFromZeroToNinety , </p>       tblAlphabets</p>order by alphaSeq</pre></p><p>Here, &quot;tblAlphabets&quot; is a table with the first ten letters of the  english alphabet (from A to J), the table structure looks like this:</p></p><p><code> Create Table tblAlphabets ( anAlphabet char(1))</code></p></p><h2>Endnotes</h2></p><p>This was just an introduction.  The type of usage, and the level of complexity of this technique is limited only by imagination.  </p>I would recommend going through a good SQL manual, your <a href="http://msdn.microsoft.com/library/en-us/startsql/getstart_4fht.asp" title="SQL Server books Online" target="_blank">favourite RDBMS's SQL manual</a> should be a good </p>starting point.</p></p><h2>Sample Code for other databases</h2></p><ul> </p><li><a title="download zip file containing sample access database" href="files/20519/47652/access_SQL.zip" target="_blank">Example code in Microsoft Access syntax</a></li> </p><li><a title="download zip file containing sample oracle plsql code" href="files/20519/47652/oracle_SQL.zip" target="_blank">Example code in Oracle 8i syntax</a></li></p></ul>