---
layout: post
permalink: node/24700
ratings: 9
avgrate: 4.5556
categories: [Code]
user: activeneter
real_name: "Paul Wilton"
user_biog: "After an initial stint as a Visual Basic applications programmer at the Ministry of Defence in the UK, Paul Wilton found himself pulled into the Net. He is currently working freelance and is busy trying to piece together the Microsoft .Net jigsaw. Paul\'s main skills are in developing web front ends using DHTML, JavaScript, VBScript, and Visual Basic, and back-end solutions with ASP, Visual Basic, and SQL Server."
user_since: 15 Apr 2002
avatar: 
article_count: 1
excerpt: "Sample chapter chunk from the glasshaus book Practical JavaScript for the Usable Web showing how to use JavaScript to perform a mod10 check on credit card numbers."
---
<p></p>Please note, this article is an excerpt from the book <cite><a href="http://www.amazon.com/exec/obidos/ASIN/1904151051/" target="_new" title="The book at Amazon.com; opens in new window">Practical JavaScript for the Usable Web</a></cite> (ISBN: 1904151051) by Paul Wilton, Stephen Williams, and Sing Li.</p></p></p><p><p></p>JavaScript is a core skill for web professionals, and as every web professional knows, client-side JavaScript can produce all sorts of glitches and bugs. <cite>Practical JavaScript for the Usable Web</cite> takes a two pronged approach to learning the JavaScript that you need to get your work done: teaching the core client-side JavaScript that you need to incorporate usable interactivity into your web applications, including many short functional scripts, and building up a complete application with shopping cart functionality.</p></p></p><p><p></p>The JavaScript function excerpted below doesn't require you to own the book in order to get it to work.  We, of course, hope it will give you a taste of what the book has to offer, but if not, enjoy it anyway.</p></p></p><p><hr></p><p><img src="http://glasshaus.com/images/photos/1904151051s.gif" width="100" height="128" align="right" alt="Practical JavaScript for the Usable Web"></p><p></p><p></p>Our final validation method checks whether a credit card number could be a valid card number. Note that I say "could be" rather than "is" &#8212; just because the number is valid, doesn't mean that the card has been allocated or that it has not been canceled, if it was allocated. Only server-side processing can possibly validate a card number. However, what we can do here is check that the user hasn't made an accidental mistake so that we can get them to rectify any mistakes before we attempt server-side checks.</p></p></p><p><p></p>As we'll see shortly, validating a credit card is much more complex than any of the validation methods we have created so far. There are three checks we can perform client-side:</p></p></p><p><ul></p> <li>Check that only numbers or spaces are given in the credit card number &#8212; not letters or other characters.</li></p> <li>Check that, for the given card type, the number of digits given is valid and the prefix to the number is valid.</li></p> <li>Use the Luhn formula to check the validity of the entered credit card number. This is a special algorithm that can be applied to most credit card numbers to check that the number would be valid.</li></p></ul></p><p><p></p>We'll be using all three of these checks in our method.</p></p></p><p><pre></p>Validate.prototype.isValidCreditCardNumber = function(cardNumber, cardType)</p>{</p>  var isValid = false;</p>  var ccCheckRegExp = /[^\d ]/;</p>  isValid = !ccCheckRegExp.test(cardNumber);</p><p>  if (isValid)</p>  {</p>    var cardNumbersOnly = cardNumber.replace(/ /g,"");</p>    var cardNumberLength = cardNumbersOnly.length;</p>    var lengthIsValid = false;</p>    var prefixIsValid = false;</p>    var prefixRegExp;</p><p>    switch(cardType)</p>    {</p>      case "mastercard":</p>        lengthIsValid = (cardNumberLength == 16);</p>        prefixRegExp = /^5[1-5]/;</p>        break;</p><p>      case "visa":</p>        lengthIsValid = (cardNumberLength == 16    cardNumberLength == 13);</p>        prefixRegExp = /^4/;</p>        break;</p><p>      case "amex":</p>        lengthIsValid = (cardNumberLength == 15);</p>        prefixRegExp = /^3(4 7)/;</p>        break;</p><p>      default:</p>        prefixRegExp = /^$/;</p>        alert("Card type not found");</p>    }</p><p>    prefixIsValid = prefixRegExp.test(cardNumbersOnly);</p>    isValid = prefixIsValid &amp;&amp; lengthIsValid;</p>  }</p><p>  if (isValid)</p>  {</p>    var numberProduct;</p>    var numberProductDigitIndex;</p>    var checkSumTotal = 0;</p><p>    for (digitCounter = cardNumberLength - 1; </p>      digitCounter >= 0; </p>      digitCounter--)</p>    {</p>      checkSumTotal += parseInt (cardNumbersOnly.charAt(digitCounter));</p>      digitCounter--;</p>      numberProduct = String((cardNumbersOnly.charAt(digitCounter) * 2));</p>      for (var productDigitCounter = 0;</p>        productDigitCounter < numberProduct.length; </p>        productDigitCounter++)</p>      {</p>        checkSumTotal += </p>          parseInt(numberProduct.charAt(productDigitCounter));</p>      }</p>    }</p><p>    isValid = (checkSumTotal % 10 == 0);</p>  }</p><p>  return isValid;</p>}</p></pre></p><p><p></p>We'll take this method step by step. Note first of all, that the method takes two parameters &#8212; the card number and the card type (<code>mastercard</code>, <code>amex</code>, and <code>visa</code> are valid card types that we will cater for here, though the method could be extended for other card types).</p></p></p><p><p></p>The first part of the method checks that only numbers or spaces have been entered:</p></p></p><p><pre></p>  var isValid = false;</p>  var ccCheckRegExp = /[^\d ]/;</p>  isValid = !ccCheckRegExp.test(cardNumber);</p></pre></p><p><p></p>The regular expression <code>/[^\d ]/</code> will match invalid characters (any character that is not a digit or a space). When we test the card number against the regular expression on the third line, as in previous methods, we use the ! character to reverse the logic, so that <code>isValid</code> is set to false if invalid characters are found in the card number.</p></p></p><p><p></p>The next part of the method checks that the card has a valid prefix, that is it starts with the correct numbers for that card type, and contains the correct number of digits, again specific to a card type. The prefixes and lengths for some commonly available cards are shown below:</p></p></p><p><table cellspacing="0" class="data"></p><thead></p> <tr></p>  <th align="left">Card Type</th></p>  <th>Prefix</th></p>  <th>Number of Digits</th></p> </tr></p></thead></p> <tr></p>  <td>Visa</td></p>  <td align="center">4</td></p>  <td align="center">13,16</td></p> </tr></p> <tr></p>  <td>Mastercard</td></p>  <td align="center">51-55</td></p>  <td align="center">16</td></p> </tr></p> <tr></p>  <td>American Express</td></p>  <td align="center">34,37</td></p>  <td align="center">15</td></p> </tr></p></table></p><p><p></p>You can find more information on card details at <a href="http://www.beachnet.com/~hstiles/cardtype.html" target="_new">http://www.beachnet.com/~hstiles/cardtype.html</a>.</p></p></p><p><p></p>First we strip out any spaces the user may have put in their credit card number when they entered it:</p></p></p><p><pre></p>  if (isValid)</p>  {</p>    var cardNumbersOnly = cardNumber.replace(/ /g,"");</p>    var cardNumberLength = cardNumbersOnly.length;</p>    var lengthIsValid = false;</p>    var prefixIsValid = false;</p>    var prefixRegExp;</p></pre></p><p></p><p></p>The <code>if</code> statement checks whether the previous validation (that the card number only contained numbers or spaces) found the number to be valid, and only proceeds with the next check if it did. Then, using a regular expression (a space between the <code>/</code> regular expression delimiters, together with the global flag <code>g</code>) and the String object's <code>replace()</code> method, we strip out the spaces.</p></p></p><p><p></p>Variable <code>cardNumberLength</code> is set to the length of the string (the number of digits in the string). The variables <code>lengthIsValid</code> and <code>prefixIsValid</code> will store Boolean values indicating the validity of the length and prefix checks that we do next.</p></p></p><p><p></p>We now need to check the <code>cardType</code> parameter of the method and, from that, decide what the prefix to the card number should be and how long the number should be.</p></p></p><p><p></p>The <code>switch</code> statement checks the card type to see which, if any, of the known card types is found:</p></p></p><p><pre></p>    switch(cardType)</p>    {</p>      case "mastercard":</p>        lengthIsValid = (cardNumberLength == 16);</p>        prefixRegExp = /^5[1-5]/;</p>        break;</p><p>      case "visa":</p>        lengthIsValid = (cardNumberLength == 16    cardNumberLength == 13);</p>        prefixRegExp = /^4/;</p>        break;</p><p>      case "amex":</p>        lengthIsValid = (cardNumberLength == 15);</p>        prefixRegExp = /^3(4 7)/;</p>        break;</p><p>      default:</p>        prefixRegExp = /^$/;</p>        alert("Card type not found");</p>    }</p></pre></p><p><p></p>In each <code>case</code> statement, we set <code>lengthIsValid</code> to the Boolean returned by the logical expression that checks for the correct card length. Then we create a regular expression that will check for the correct prefix for that card. In the <code>default</code> case, we create a regular expression that matches nothing, and warn the customer that their card type hasn't been found. If we want to allow different cards, for example diners club, then our <code>switch</code> statement simply needs an extra case adding to match the new type of card's parameters, that is size and start digits.</p></p></p><p><p></p>We next check the prefix using the regular expression set in the relevant <code>case</code> statement, and then set <code>isValid</code> to the results of the logical addition <code>prefixIsValid</code> <strong>and</strong> <code>lengthIsValid</code>, which will be true only if both these values are true:</p></p></p><p><pre></p>    prefixIsValid = prefixRegExp.test(cardNumbersOnly);</p>    isValid = prefixIsValid &amp;&amp; lengthIsValid;</p></pre></p><p><p></p>OK, that's the two easy checks done. Now we have the part of the method that checks the card number using the <strong>Luhn formula</strong>, which works with almost all card types. This special formula, also known as <strong>Modula 10</strong> or <strong>Mod 10</strong>, tells us whether the number it is applied to could be a valid number. Obviously, it doesn't guarantee that the number is actually in use, only that it could be used.</p></p></p><p><p></p>We'll walk through the basic formula, using the credit card number 4221 3456 1243 1237 as an example:</p></p></p><p><ol></p> <li>Start with the second digit from last in the card number. Moving backwards towards the first digit in the number, double each alternate digit.<br></p>	In our example, we would double the bold numbers in <strong>4</strong>2<strong>2</strong>1 <strong>3</strong>4<strong>5</strong>6 <strong>1</strong>2<strong>4</strong>3 <strong>1</strong>2<strong>3</strong>7 to give us:<br></p>	<code>(4x2), (2x2), (3x2), (5x2), (1x2), (4x2), (1x2), (3x2)</code><br></p>	which is:<br></p>	<code>8, 4, 6, 10, 2, 8, 2, 6</code><br><br></li></p> <li>Take the results of the doubling, add each of the individual digits in each doubled number together, and then add to the running total.<br></p>	In our example we have:<br></p>	<code>8 + 4 + 6 + (1 + 0) + 2 + 8 + 2 + 6 = 37</code><br><br></li></p> <li>Add all the non-doubled digits from the credit card number together.<br></p>	In our example we have:<br></p>	<code>2 + 1 + 4 + 6 + 2 + 3 + 2 + 7 = 27</code><br><br></li></p> <li>Add the values calculated in step 2 and step 3 together.<br></p>	In our example:<br></p>	<code>37 + 27 = 64</code><br><br></li></p> <li>Take the value calculated in step 4 and calculate the remainder when it is divided by 10. If the remainder is zero, then it's a valid number, otherwise it's invalid.<br></p>	In our example:<br></p>	<code>64 / 10 = 6</code> with remainder 4.<br></p>	So, our example number is not a valid card number, as the remainder is not 0.</li></p></ol></p><p><p></p>Now we understand how it works, let's look at the code in our method that uses it.</p></p></p><p><p></p>First we check if <code>isValid</code> is <code>true</code> (that is, if all other checks so far proved satisfactory). Then, after our variable declarations, we have the main for loop that will go through the credit card number a digit at a time starting with the last digit and moving to the first.</p></p></p><p><pre></p>  if (isValid)</p>  {</p>    var numberProduct;</p>    var numberProductDigitIndex;</p>    var checkSumTotal = 0;</p><p>    for (digitCounter = cardNumberLength - 1; </p>      digitCounter > 0; </p>      digitCounter--)</p>    {</p></pre></p><p><p></p>In this <code>for</code> loop we do a number of things. Firstly we add a digit's value to the running total, <code>checkSumTotal</code>.</p></p></p><p><pre></p>      checkSumTotal += parseInt (cardNumbersOnly.charAt(digitCounter));</p></pre></p><p><p></p>Then we move to the digit that is one nearer the start of the card number string. We multiply this next digit by 2.</p></p></p><p><pre></p>      digitCounter--;</p>      numberProduct = String((cardNumbersOnly.charAt(digitCounter) * 2));</p></pre></p><p><p></p>We take the digits forming the results of the product calculation and in the inner <code>for</code> loop we add these digits to the running total.</p></p></p><p><pre></p>      for (var productDigitCounter = 0;</p>        productDigitCounter < numberProduct.length; </p>        productDigitCounter++)</p>      {</p>        checkSumTotal += </p>          parseInt(numberProduct.charAt(productDigitCounter));</p>      }</p></pre></p><p><p></p>Our outer <code>for</code> loop continues by moving to the next digit to the left, and iterates until we reach the first digit in the credit card number string.</p></p></p><p><p></p>If we think back to the explanation of the Luhn formula, our approach is out of step in that we are not doing step 1, then step 2, and so on, but instead are merging steps 1-4 and processing the number on a digit by digit basis, keeping a running total. It amounts to exactly the same thing, but reduces the number of loops required.</p></p></p><p><p></p>Let's summarize the steps in our outer and inner <code>for</code> loops:</p></p></p><p><ul></p> <li>Extract the character whose position is specified by <code>digitCounter</code>, from the string in <code>cardNumbersOnly</code>.</li></p> <li>Add this number to our running total, which is kept in variable <code>checkSumTotal</code>.</li></p> <li>Decrement the character counter, <code>digitCounter</code>. This now refers to the next digit to the left in our string <code>cardNumbersOnly</code>.</li></p> <li>Extract the next digit, convert it to a number, and then double it. This is all done on one line and this product is stored in variable <code>numberProduct</code>.</li></p> <li>Convert the product calculated in step 4 to a string.</li></p> <li>Loop through each digit in the product string, convert it to an integer, and add to the running total. This is our inner <code>for</code> loop. For example, if the character extracted in step 4 was 8, its product would be 16, and so we'd add 1 and then 6 to our running total.</li></p> <li>Decrement the <code>digitCounter</code> and move to step 1.</li></p></ul></p><p><p></p>In the table below, we show what digits are extracted and what values added to the running total for the example card number 4221 3456 1243 1287.</p></p></p><p><table cellspacing="0" class="data"></p><thead></p> <tr></p>  <th>Character Extracted</th></p>  <th align="left">What happens to it</th></p>  <th align="left">What happens to running total</th></p>  <th align="right">Running total Value</th></p> </tr></p></thead></p> <tr></p>  <td align="center">7</td></p>  <td>Added to running total</td></p>  <td>Running total (0) + character extracted (7)</td></p>  <td align="right">7</td></p> </tr></p> <tr></p>  <td align="center">8</td></p>  <td>Doubled (16), then each digit in the product added to running total</td></p>  <td>Running total (7) + first digit in product (1) + second digit in product (6)</td></p>  <td align="right">14</td></p> </tr></p> <tr></p>  <td align="center">2</td></p>  <td>Added to running total</td></p>  <td>Running total (14) + character extracted (2)</td></p>  <td align="right">16</td></p> </tr></p> <tr></p>  <td align="center">1</td></p>  <td>Doubled (2), then each digit in the product added to running total</td></p>  <td>Running total (16) + first digit in product (2)</td></p>  <td align="right">18</td></p> </tr></p> <tr></p>  <td align="center">3</td></p>  <td>Added to running total</td></p>  <td>Running total (18) + character extracted (3)</td></p>  <td align="right">21</td></p> </tr></p> <tr></p>  <td align="center">4</td></p>  <td>Doubled (8), then each digit in the product added to running total</td></p>  <td>Running total (21) + first digit in product (8)</td></p>  <td align="right">29</td></p> </tr></p> <tr></p>  <td align="center">2</td></p>  <td>Added to running total</td></p>  <td>Running total (29) + character extracted (2)</td></p>  <td align="right">31</td></p> </tr></p> <tr></p>  <td align="center">1</td></p>  <td>Doubled (2), then each digit in the product added to running total</td></p>  <td>Running total (31) + first digit in product (2)</td></p>  <td align="right">33</td></p> </tr></p> <tr></p>  <td align="center">6</td></p>  <td>Added to running total</td></p>  <td>Running total (33) + character extracted (6)</td></p>  <td align="right">39</td></p> </tr></p> <tr></p>  <td align="center">5</td></p>  <td>Doubled (10), then each digit in the product added to running total</td></p>  <td>Running total (39) + first digit in product (1) + second digit in product(0)</td></p>  <td align="right">40</td></p> </tr></p> <tr></p>  <td align="center">4</td></p>  <td>Added to running total</td></p>  <td>Running total (40) + character extracted (4)</td></p>  <td align="right">44</td></p> </tr></p> <tr></p>  <td align="center">3</td></p>  <td>Doubled (6), then each digit in the product added to running total</td></p>  <td>Running total (44) + first digit in product (6)</td></p>  <td align="right">50</td></p> </tr></p> <tr></p>  <td align="center">1</td></p>  <td>Added to running total</td></p>  <td>Running total (50) + character extracted (1)</td></p>  <td align="right">51</td></p> </tr></p> <tr></p>  <td align="center">2</td></p>  <td>Doubled (4), then each digit in the product added to running total</td></p>  <td>Running total (51) + first digit in product (4)</td></p>  <td align="right">55</td></p> </tr></p> <tr></p>  <td align="center">2</td></p>  <td>Added to running total</td></p>  <td>Running total (55) + character extracted (2)</td></p>  <td align="right">57</td></p> </tr></p> <tr></p>  <td align="center">4</td></p>  <td>Doubled (8), then each digit in the product added to running total</td></p>  <td>Running total (57) + first digit in product (8)</td></p>  <td align="right">65</td></p> </tr></p></table></p><p><p></p>Once we have our result, in the table above that's 65, we then find its modulus 10 value, that is the remainder left over when the running total is divided by ten. If it's zero, we have ourselves a valid credit card number, otherwise it's a fake. We set <code>isValid</code> to the result of the Boolean expression comparing the remainder to zero &#8212; if <code>true</code> it's valid, if <code>false</code> it's invalid. In our example, we have 65, the modulus 10 value of which is 5, so the example number is invalid &#8212; you didn't really think I'd give my credit card number out now did you?</p></p>