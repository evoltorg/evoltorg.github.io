---
layout: post
permalink: node/60149
ratings: 7
avgrate: 1.5714
user: tag
real_name: "Scott McCoy"
user_since: 10 May 2003
avatar: "/images/pictures/picture-60774.jpg"
article_count: 1
excerpt: "Implementing fast, portable SQL Phrasebooks using string formatting.  Examples in PHP and Perl."
---
<p>This article describes effective and portable implementations of </p>SQL Phrasebooks, using formatted constants as opposed to the currently accepted methods</p>which call for XML Configuration files and dynamic general SQL Query generation</p>routines.  Formatting is a very old and standardized method of making</p>strings dynamic, and although there are currently numerous implementations</p>that vary depending on language, the formatted strings we will use are completely</p>portable and standardized among all popular languages today.</p></p><p><p>Why not use XML?  Well, there is an argument (taken from </p><a href="http://www.Perl.com/pub/a/2002/10/22/Phrasebook.html" target="_blank"</p> title="opens in new window">The Phrasebook Design Pattern</a>) </p>that mixing languages is bad. My feeling is that mixing SQL and</p>XML, with library specific scalars intended to be parsed by the current </p>application, is hardly better than mixing SQL with Perl, PHP, or any other programming</p>language.  So our response is to isolate the SQL.  This keeps us from having</p>a statement for any one table more than once, ever.  We do this</p>by only using completely constant values where we don't need variations of the</p>same query, and otherwise using strict prototyping.  This gives three distinct</p>advantages when writing Phrasebooks as libraries.</p></p><p>The first is the obvious</p>speed advantage, resulting from not having to parse the XML file.  The second is</p>that string formatting is extremely standard among today's modern languages, which</p>means our formatted queries are quite portable, and porting the Phrasebooks</p>themselves to different languages can be done with minimal effort.  </p></p><p>The third advantage is that it helps reduce repetition.</p>Reducing repetition is the main focus behind Phrasebook design.  Repeating</p>yourself in the code is quite possibly the worst thing you can do, especially</p>when your repetition is large chunks of an alternate language within your</p>program.  Why worry about repetition?  Well, repetition makes maintaining code</p>quite difficult, especially with SQL, since if you change your database, you</p>have to remember to search all your programs that access the specific tables</p>you have changed, for whatever unanticipated reason you changed them, and</p>change the queries contained in them.  If you have all of your queries in a single</p>location, and even then only once, this makes this process much less painful.</p></p><p>When I first began discussing this in a public forum, the first question I</p>received was, "Well, then won't we need a bunch of extra sprintfs?  I think that</p>is kind of annoying."  Of course, my response was "Yes, but you don't have to see</p>them."  The way we get around this is by writing our own extremely mild wrappers</p>to whichever DBI we are using.  The wrappers are quite simple; for instance,</p>in PHP we simply make a class to wrap around the long, ugly mysql_* functions</p>that PHP's mysql DBI provides:</p></p><pre></p>/* Simple DBI Wrapper */</p>class EasyMySQL {</p>var $Result;</p>var $Link;</p><p>function EasyMySQL ($User,$Pass,$Data,$Host = "localhost") {</p>&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;Link = mysql_connect($Host,$User,$Pass);</p>&nbsp;&nbsp;&nbsp;&nbsp;mysql_select_db($Data,$this-&gt;Link);</p>}</p>function rqueryf () {</p>&nbsp;&nbsp;&nbsp;&nbsp;$args = func_get_args();</p>&nbsp;&nbsp;&nbsp;&nbsp;return mysql_fetch_object(mysql_query</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( call_user_func_array( 'sprintf', $args ), $this-&gt;Link));</p>}</p>function queryf () {</p>&nbsp;&nbsp;&nbsp;&nbsp;$args = func_get_args();</p>&nbsp;&nbsp;&nbsp;&nbsp;return mysql_query(call_user_func_array( 'sprintf', $args ));</p>}</p>function rquery ($Query) {</p>&nbsp;&nbsp;&nbsp;&nbsp;return mysql_fetch_object(mysql_query($Query, $this-&gt;Link));</p>}</p>function query ($Query) {</p>&nbsp;&nbsp;&nbsp;&nbsp;return $this-&gt;Result = mysql_query($Query, $this-&gt;Link);</p>}</p>function next ($Handle="") {</p>&nbsp;&nbsp;&nbsp;&nbsp;return mysql_fetch_object($Handle ? $Handle : $this-&gt;Result);</p>}</p><p>/* Destruction Function [ php has no destructor, call explicitly ] */</p>function close () {</p>&nbsp;&nbsp;&nbsp;&nbsp;mysql_close($this-&gt;Link);</p>&nbsp;&nbsp;&nbsp;&nbsp;return NULL;</p>}</p>}</p></pre></p><p>This specific class may leave you with a few questions.  It provides more</p>than just a simple wrapper around sprintf and the query at hand. It also provides</p>slightly enhanced syntax for iterations, formatted and nonformatted</p>functions, and an internal Link and Result reference.  I used these because in</p>the particularprogram I wrote this class for, my module API left the global</p>mysql link available to extensions, without interference.  Why did we fetch our</p>rows as objects, instead of arrays or associative arrays?  That's a matter of</p>personal preference.  You can use whichever methods you want.</p></p><p>So, when does the Phrasebook come in?  It comes in now.  Personally, my</p>favorite way to design Phrasebooks in PHP is as a class that inherits my DBI</p>wrapper.  Here is a simple example:</p></p><pre></p>class Phrasebook extends EasyMySQL {</p>function Q ($Query) {</p>&nbsp;&nbsp;&nbsp;&nbsp;switch ($Query):</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ACCOUNT:</p>return &lt;&lt;&lt;SQL</p>SELECT  id,</p>&nbsp;&nbsp;&nbsp;&nbsp;name,</p>&nbsp;&nbsp;&nbsp;&nbsp;address,</p>&nbsp;&nbsp;&nbsp;&nbsp;city,</p>&nbsp;&nbsp;&nbsp;&nbsp;state,</p>&nbsp;&nbsp;&nbsp;&nbsp;zip</p>FROM&nbsp;&nbsp;&nbsp;&nbsp;accounts</p>WHERE   id = %d</p>SQL;</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case HITS:</p>return &lt;&lt;&lt;SQL</p>SELECT  sum(raw) as raw,</p>&nbsp;&nbsp;&nbsp;&nbsp;sum(uni) as uni,</p>&nbsp;&nbsp;&nbsp;&nbsp;date</p>FROM&nbsp;&nbsp;&nbsp;&nbsp;stats</p>WHERE   id = %d</p>AND date &gt;= %d</p>AND date &lt;= %d</p>SQL;</p>&nbsp;&nbsp;&nbsp;&nbsp;endswitch;</p>}</p>}</p></pre></p><p>Here is an example of how we would use this:</p></p><pre></p>/* Was like this... */</p>mysql_connect($User, $Pass);</p>mysql_select_db($Database);</p><p>$result = mysql_query("SELECT id, name, address, city, state, zip</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM accounts WHERE id = $id");</p>while ($Data = mysql_fetch_object($result)) {</p>...</p>}</p><p>/* Now it's like this */</p>$Database = new Phrasebook ($User, $Pass, $Database);</p><p>$Database-&gt;queryf($Database-&gt;Q("ACCOUNTS"), $id);</p>while ($Data = $Database-&gt;next()) {</p>...</p>}</p></pre></p><p>Obviously, the end result is a lot less code, especially for very large</p>queries, and looks much nicer, with all of the advantages discussed earlier.</p></p><p>So what about Perl?  Well, Perl actually has specific advantages in</p>Phrasebooks over PHP, mostly, that we can contain our SQL Phrasebook in a </p>package with constant, null prototyped definitions (when possible) and this</p>increases the speed of the Phrasebook access exponentially (not that it isn't</p>already very fast in the example above).  One rule to keep in mind with Perl</p>is that if you only use a table once, you should use a null prototype for that</p>query.  Why?  Well if we're not doing anything dynamic, we don't need to pass</p>parameters.  If we use a null prototype, the Perl compiler flags that method</p>as a constant, and compiles it as if it were a single quoted string into our</p>code.  So it has absolutely no runtime loss over single quoted, static string</p>formatting.  That's pretty impressive, abstracting the code without slowing it</p>down whatsoever.</p></p><p>Here is an example Phrasebook package in Perl that executes the same</p>queries as the above PHP example:</p></p><pre></p>package Phrase;</p><p>sub ACCOUNT () { </p>&lt;&lt;SQL;</p>SELECT  id,</p>&nbsp;&nbsp;&nbsp;&nbsp;name,</p>&nbsp;&nbsp;&nbsp;&nbsp;address,</p>&nbsp;&nbsp;&nbsp;&nbsp;city,</p>&nbsp;&nbsp;&nbsp;&nbsp;state,</p>&nbsp;&nbsp;&nbsp;&nbsp;zip</p>FROM&nbsp;&nbsp;&nbsp;&nbsp;accounts</p>WHERE   id = %d</p>SQL</p>}</p><p>sub HITS&nbsp;&nbsp;&nbsp;&nbsp;() {</p>&lt;&lt;SQL;</p>SELECT  sum(raw) as raw,</p>&nbsp;&nbsp;&nbsp;&nbsp;sum(uni) as uni,</p>&nbsp;&nbsp;&nbsp;&nbsp;date</p>FROM&nbsp;&nbsp;&nbsp;&nbsp;stats</p>WHERE   id = %d</p>AND date &gt;= %d</p>AND date &lt;= %d</p>SQL</p>}</p></pre></p><p></p>Here is an example of how we would use this:</p></p><pre></p># What was this</p>$sth = $dbh-&gt;prepare</p>("SELECT id, name, address, city, state, zip FROM accounts WHERE id = $id");</p><p># Now becomes this</p>$sth = $dbh-&gt;prepare(sprintf(Phrase-&gt;ACCOUNT, $id));</p></pre></p><p></p>This is obviously not only more pleasant to have in your code if you're not </p>currently worrying about the SQL, but also has all the advantages mentioned</p>earlier.</p></p><p>As you can see here, we didn't exercise the database abstraction as in the</p>PHP example mentioned, because the robustness of Perl's DBI doesn't</p>really require it.  If you wanted, however, to rid your code of the</p>extra sprintfs, considering that Perl's DBI already offers the other conveniences our</p>PHP wrapper had, write a simple object to inherit a DBI object and call</p>prepare with a sprintf.  Here is an extremely simple example:</p></p><pre></p>package FormatDBI;</p>use DBI;</p>use Data::Dumper;</p><p>@FormatDBI::ISA = qw(DBI);</p><p>package FormatDBI::db;</p>@FormatDBI::db::ISA = qw(DBI::db);</p><p>sub preparef {</p>return $_[0]-&gt;prepare(sprintf($_[1], @_[2..$#_]));</p>}</p><p>package FormatDBI::st;</p>@FormatDBI::st::ISA = qw(DBI::st);</p><p>package main;</p>use strict;</p>use warnings FATAL =&gt; qw( all );</p><p>use Phrase;</p><p>my $dsn = "DBI:mysql:database=aff;host=localhost";</p>my $dbh = FormatDBI-&gt;connect($dsn, "username", "password");</p><p>my ($Data,$sth);</p><p>$sth = $dbh-&gt;preparef(Phrase-&gt;ACCOUNT, 40);</p>...etc...</p></pre></p><p>Hope you find this useful.</p>