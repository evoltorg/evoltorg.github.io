---
layout: post
permalink: node/21927
ratings: 9
avgrate: 4.1111
categories: [Code]
user: andrewpander
real_name: "Andrew Forsberg"
user_biog: "<p>Give him a  manhattan or two and he\'ll mumble for hours about how he shaved 10 milliseconds off a recursive php routine, the necessity of the fibonacci series in well typeset printed documents, or perdita the cat.</p>
<p>He lives in Auckland, New Zealand, and listens to way too much Wu-Tang Clan and Philip Glass for Vanessa\'s taste. Andrew is a part owner, and runs the technical side, of <a href=\"http://uber.net.nz\" rel=\"nofollow\" target=\"blank\">uber.net.nz</a>.</p>"
user_since: 09 Jan 2001
avatar: 
article_count: 1
excerpt: "An introduction to using the PEAR::DB classes. Avoid re-writing frequently used routines to suit different vendors\' databases, or the time-consuming process of building your own wrapper functions."
---
<p>With the <acronym title="PHP Extensions and Applications Repository">PEAR</acronym>::DB classes you can avoid: re-writing frequently used routines to suit different vendors' databases, or the time-consuming process of building your own wrapper functions.</p></p><p></p><p><h2>Why abstract your database code?</h2></p><p><p>Because often there's no reason why that useful section of code can't be reused on other database servers. Whether it's a ten line algorithm you spent half a day on, or a ten thousand line monster you just know you will need to migrate someday from MySQL to Oracle or PostgreSQL. You might also develop on one database server while targeting several production servers from different vendors. It makes good sense to avoid replacing all the database specific functions and routines by using an abstraction layer between your code and database vendor specific functions.</p></p><p><p>Does that sound like a good idea? I thought so. One way to achieve this is to build wrapper scripts to hide the real access functions from your programs. Building a library of these wrappers to support all the functions of supported databases in the PHP <acronym title="Application Program Interface">API</acronym> is a <strong>really big nasty project</strong>. Fortunately most of it has already been done, and is available via the <acronym title="PHP Extensions and Applications Repository">PEAR</acronym> repository, included in recent PHP releases by default.</p></p><p><p>By using PEAR::DB and a simple configuration script, you can avoid much of the database function related hassle associated with migrating scripts. You also get access to a comprehensive, standardized error handling system, and several functions not yet available in some of PHP's individual database APIs (like <code>prepare()</code> and <code>execute()</code>).</p></p><p></p><p></p><h2>So, what do I need?</h2></p><p><ul></p><li>First, you need to be familiar with at least one of PHP's sets of database access functions, it doesn't matter which group (<a href="http://www.php.net/manual/en/ref.mysql.php" title="The PHP MySQL function docs" target="_new">MySQL</a>, <a href="http://www.php.net/manual/en/ref.oci8.php" title="The PHP Oracle 7/8/8i function docs" target="_new">Oracle</a>, <a href="http://www.php.net/manual/en/ref.pgsql.php" title="The PHP PostgreSQL function docs" target="_new">PostgreSQL</a>, &hellip;).</li></p><li>Second, you will need access to a PHP build which includes PEAR. If you can execute <code>&lt;?php require_once 'DB.php'; ?&gt;</code> without an error then you are good to go (Windows users may need to add the PEAR path to their php.ini file, the <a href="http://pear.php.net/faq.php" title="PEAR Frequently Asked Questions" target="_new">PEAR FAQ</a> explains this).<br><br></p>If, after the <a href="http://security.e-matters.de/advisories/012002.html" title="PHP remote access vulnerability" target="_new">security announcement</a> (2002 / 2 / 27) your host still hasn't, and doesn't intend to, <a href="http://php.net/downloads.php" title="PHP download page" target="_new">upgrade</a>, then <acronym title="in my opinion">IMO</acronym> <strong>you need to find a new host</strong>. Version 4.1.2 of PHP builds PEAR by default.</li></p><li>Finally, you will need a database to play with. Doh!</li></p></ul></p><p><p>Caveat: the SQL statements will need to be generic enough to work on all of your target databases, otherwise they should be built separately from each other (via a <code>switch</code> block, or the <code>prepare()</code> strategy described at the end of this introduction). PEAR::DB only helps abstract access to the database, it cannot abstract SQL statements. For accurate information about what each supported database is capable of, implemented in PEAR, and tested for, read the document at your pear_base_dir/DB/STATUS.</p></p><p></p><p></p><h2>The config file</h2></p><p><p>PEAR::DB needs to know about the usual suspects for a database connection (the server hostname, username, password, and database name), just like <code>mysql_connect()</code> or <code>pg_connect()</code> do. By using an external config file instead of listing this information inline you:</p></p><p><ul></p><li>save time and increase portability by only needing to change a parameter in one place;</li></p><li>gain some security because you can move the file with password information outside the web accessible directory on the server; and</li></p><li>avoid having to type that stuff out again and again, or waste time hunting down the inevitable typo.</li></p></ul></p><p><pre></p>// /home/foo/incs/db_config.php</p>// put this file somewhere safe, preferably outside the document root</p><p>$DB_host    = "bigBoxInTheCorner";  // the hostname of the database server</p>$DB_user    = "thatIsMe";           // the username to connect with</p>$DB_pass    = "notTellingYou";      // the user's password</p>$DB_dbName  = "myDatabase";         // the name of the database to connect to</p>$DB_dbType  = "seeBelow";           // the type of database server.</p><p></pre></p><p><p>At the time of writing, the supported database types for the $DB_dbType variable are:</p></p><p><table cellspacing="0" class="data"></p><thead></p><tr valign="top"><th>Database Type</th><th>Database Type String</th></tr></thead></p><tbody></p><tr valign="top"><td>MySQL</td><td><code>mysql</code></td></tr></p><tr valign="top"><td>PostgreSQL</td><td><code>pgsql</code></td></tr></p><tr valign="top"><td>InterBase</td><td><code>ibase</code></td></tr></p><tr valign="top"><td>Mini SQL</td><td><code>msql</code></td></tr></p><tr valign="top"><td>Microsoft SQL Server</td><td><code>mssql</code></td></tr></p><tr valign="top"><td>Oracle 7/8/8i</td><td><code>oci8</code></td></tr></p><tr valign="top"><td>ODBC (Open Database Connectivity)</td><td><code>odbc</code></td></tr></p><tr valign="top"><td>SyBase</td><td><code>sybase</code></td></tr></p><tr valign="top"><td>Informix</td><td><code>ifx</code></td></tr></p><tr valign="top"><td>FrontBase</td><td><code>fbsql</code></td></tr></p></tbody></p><tfooter></p><tr valign="top"><td colspan="2">Use the database type string in the config file so PEAR::DB can create the right connection type.</td></tr></p></tfooter></p></table></p><p></p><p><h2>The PEAR::DB object</h2></p><p><p>Once you've saved the config file somewhere creating a connection with a PEAR::DB object is really easy:</p></p><p><pre></p>require_once 'DB.php';          // You know you're gonna need this</p>                                // Imports all the PEAR::DB classes, static</p>                                // methods, etc...</p><p>                                // Get the connection variables:</p>require_once '/home/foo/incs/db_config.php';</p><p>$dsn = $DB_dbType . "://"       // Build a DSN string (Data Source Name)</p>        . $DB_user . ":"        // Required by DB::connect()</p>        . $DB_pass . "@" </p>        . $DB_host . "/" </p>        . $DB_dbName;</p><p>$db = DB::connect($dsn, TRUE);  // Creates a database connection object in $db</p>                                // or, a database error object if it went wrong.</p>                                // The boolean specifies this is a persistent</p>                                // connection like mysql_pconnect(), it</p>                                // defaults to FALSE.</p><p>if (DB::isError($db)) {         // Check whether the object is a connection or</p>                                // an error.</p>    die($db-&gt;getMessage());     // Print out a message and exit if it's </p>                                // an error object.</p>}</p><p>// Do all sorts of stuff with your database connection here.</p><p>$db-&gt;disconnect();              // Close the connection.</p></pre></p><p><p>So, creating database connections with PEAR::DB objects doesn't take that much more effort than a regular PHP database <code>whatever_connect()</code> function. Building, executing, and processing SQL queries is also a piece of cake:</p></p><p><pre></p>// Get a connection as above</p><p>$sql = "SELECT first_name</p>        , last_name</p>        , pet_name</p>        FROM person</p>        WHERE person_id > 0";   // Build your SQL query</p>    </p>$res = $db-&gt;query($sql);        // $db-&gt;query processes the query in the</p>                                // string $sql, using the database</p>                                // connection we built before in $db.</p>                                //</p>                                // $res will be a result resource object</p>                                // or an error object</p><p>if (DB::isError($res)) {        // Check the result object in case there</p>    die($res-&gt;getMessage());    // was an error, and handle it here.</p>}</p><p>while ($row = $res-&gt;fetchRow(DB_FETCHMODE_OBJECT)) {</p>    // Fetch a row from the result resource object $res.</p>    //</p>    // DB_FETCHMODE_OBJECT returns a row with column names as keys.</p>    // Other possibilities are listed here:</p>    // http://pear.php.net/manual/en/core.db.tut_fetch.php</p><p>    if (DB::isError($row)) {</p>        die($row-&gt;getMessage());  // fetchRow can return an error object</p>                                  // like most PEAR::DB methods.</p>    }</p>    </p>    print ("&lt;p&gt;Hey, it's:&lt;br /&gt;" </p>            . $row-&gt;first_name . " " . $row-&gt;last_name </p>            . " ... and their freaky pet: " . $row-&gt;pet_name </p>            . "&lt;/p&gt;</p>");</p>}</p><p>$res-&gt;free();                   // Release the result resource object.</p>                                // Similar to: mysql_free_result($result)</p><p>// Disconnect as above</p></pre></p><p></p><p><h2>Other handy PEAR::DB features</h2></p><p><h3>Just <code>get*()</code> the data already</h3></p><p><p>The fun doesn't stop there folks. There are also some neat time-saving methods in PEAR::DB. The <code>get*()</code> group (<code>getOne()</code>, <code>getRow()</code>, <code>getCol()</code>, <code>getAssoc()</code>, and <code>getAll()</code>) takes an SQL query string as an argument, queries the database, fetches the results, then frees the result resource, <strong>all in one go</strong>. Explanations and examples are available at the bottom of the <a href="http://pear.php.net/manual/en/core.db.tut_fetch.php" title="PEAR::DB Fetch Tutorial" target="_new">fetch() tutorial</a>.</p></p><p><h3><code>prepare()</code> to <code>execute()</code>!</h3></p><p><p>Some database servers allow you to save an SQL query with place holders, then use it later by filling in the blanks. For example: say you want to insert a variable number of rows into a table, but would like to avoid putting the INSERT query inside a loop. PEAR::DB <strong>emulates</strong> this functionality for those databases that don't support it natively. (As at the release of PHP v. 4.1.2, a fully tested, native implementation of this feature is only available for Oracle, and an untested implementation for InterBase; it is emulated on all the other supported databases. See the pear_base_dir/DB/STATUS document for full details of the implemented / emulated, tested / untested, features of your target databases.)</p></p><p><p>Here's an example of how the <code>executeMultiple()</code>function could be used on a table like the one in our previous SELECT example:</p></p><p><pre></p>// Get a connection as above</p><p>    // First we translate a normal INSERT query into a generic </p>    // one we can re-use. So, if this is a valid INSERT query:</p>    //</p>    // INSERT INTO person (first_name, last_name, pet_name) </p>    //        VALUES ("jonnie", "walker", "tipples");</p>    // </p>    // Replace the quoted values with ? and your good to go:</p><p>$sth = $db-&gt;prepare("INSERT INTO person"</p>            . " (first_name, last_name, pet_name)"</p>            . " VALUES (?, ?, ?)");    </p><p>    // You can also use ! instead of ? to insert data as is (not quoted),</p>    // or & to insert the data from a filename.</p><p></p>    // Next we build a two dimensional array that contains the</p>    // values we want to insert. </p>    // executeMultiple() will process all of these in a single step.</p>    // execute() will process only one SQL command at a time.</p><p>$data = array (</p>            array ("johnnie", "walker", "tipples"),</p>            array ("mandy", "morrison", "mumpy"),</p>            array ("jumpy", "jones", "jiggles"),</p>            array ("willy", "the menace", "groutch"));</p><p></p>    // executeMultiple() takes the above prepared statement handler ($sth)</p>    // and the array of data ($data), and processes it. </p><p>$res = $db-&gt;executeMultiple($sth, $data);</p><p>    // If everything went ok executeMultiple returns a Result object </p>    // (in the case of SELECT statements).</p>    // If anything went wrong then a DB Error object will return, just</p>    // like nearly everywhere else in the PEAR project.</p><p></p>if (DB::isError($res)) {         // Check the result object in case there</p>    die($res-&gt;getMessage());  // was an error, and handle it here.</p>}</p><p>// Disconnect as above</p></pre></p><p><p>More details can be found in PEAR's <a href="http://pear.php.net/manual/en/core.db.tut_execute.php" title="PEAR::DB Execute Tutorial" target="_new">execute() tutorial</a>. They also suggest a nifty solution for handling different database's SQL syntax with an array of prepared statements where the key is the database type:</p></p><p><pre></p>// Get a connection as above</p><p>    // Create an array where the database type string is the key</p>    // to the appropriate SQL statement.</p>    // MySQL supports either syntax, but you get the general idea.</p><p>$sql['oci8']['INSERT_PERSON']�=�"INSERT INTO person"</p>    . " (first_name, last_name, pet_name)"</p>    . " VALUES ( ?, ?, ? )"�;</p>$sql['mysql']['INSERT_PERSON']�=�"INSERT INTO person"</p>    . " SET first_name=?, last_name=?, pet_name=?"�;</p>    </p>    // And so on with all the types of syntax you need to support.</p><p>    // Next, prepare the query, using the $DB_dbType variable</p>    // to access the correct SQL syntax:</p><p>$sth = $db-&gt;prepare($sql[$DB_dbType]['INSERT_PERSON']);    </p><p>    // The rest as in the previous executeMultiple() example.</p><p></pre></p><p></p><p><h2>Summary</h2></p><p><p>PEAR::DB supplies us with a standard, fairly easy-to-use, API for database connections. By using the methods it supplies we can more easily write portable code than is possible using PHP's vendor-specific database functions. And, the icing on the cake, we get new functionality previously not available for all databases.</p></p><p></p><h2>References</h2></p><p><p>The <a href="http://pear.php.net/manual/en/" title="PEAR Docs">core documentation</a> for PEAR, the <a href="http://pear.php.net/manual/en/core.db.php" title="PEAR::DB Docs" target="_new">PEAR::DB docs</a>, and the <a href="http://pear.php.net/download-docs.php" title="Download the Manual" target="_new">downloadable docs</a> will be very handy. The <a href="http://pear.php.net/faq.php" title="PEAR FAQ" target="_new">PEAR FAQ</a> is primarily targeted at PEAR developers.</p></p><p><p>PHP lists, including the PEAR Project list archives can be found at <a href="http://www.zend.com/lists.php" title="PHP Mailing Lists" target="_new">Zend's Mailing List</a> page.</p></p><p><p>Tutorials, reviews, and information about PEAR classes are listed on this <a href="http://php.weblogs.com/php_pear_tutorials" title="PHP Weblog" target="_new">PHP Weblog</a>.</p></p><p><p><a href="http://www.phpbuilder.com/" title="PHP Builder" target="_new">PHP Builder</a> have a more detailed <a href="http://www.phpbuilder.com/columns/allan20010115.php3" title="Allan Kent's PEAR::DB tutorial" target="_new">tutorial</a> by Allan Kent.</p>