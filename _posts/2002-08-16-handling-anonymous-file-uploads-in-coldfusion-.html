---
layout: post
permalink: node/35926
ratings: 5
avgrate: 4.2000
user: Nepolon
real_name: "Steve Lewis"
user_since: 01 May 2002
avatar: ""
article_count: 1
excerpt: "Sometimes it is necessary to allow absolute strangers to upload files to your server through a form. When that happens you can find yourself giving away the keys to the server. This article intends to show you where to start with limiting the files submitted by unauthenticated users."
---
<p>File uploads to your web server can be a real pain in the security. Consider the obvious case of uploading an executable and trying to engineer a way to get you to execute it... scary. Consider also the unobvious case of uploading a ColdFusion script that executed malicious code using your web server.</p></p><p><p>When you allow file uploads you are essentially allowing someone to place arbitrary arrangements of 1s and 0s on your server's disk and hoping that the user doesn't do anything mean with them. I have heard this referred to as the rhythm method of security. I hear it works about as well.</p></p><p><p>I don't know about you, but I tend to have difficulty sleeping at night whenever I am forced to allow folks permission to upload something to my servers. This is most commonly a problem on my web servers. On web servers folks often want to be able to store images, maybe a Word document or some <abbr title="Adobe's Portable Document Format">PDF</abbr>s, or maybe even some Zip files for an indefinite period of time and presumably with the understanding that someone will link to that file in an HTML file, and then sometime later someone will follow that link. </p></p><p><p>In order to get my uninterrupted sleepy time, I like to do what I can to limit the chance that someone will abuse this permission to upload pooh to my web server. Lets define our risks. There are two distinct cases for file uploads:</p></p><p><ol></p><li>The sender is someone who has paid me for the right to personally put files on my web server. I know who this person is, and have assigned a scheme for authenticating this person's identity before the upload happens. If things go wrong I have this person's phone number, a valid email address, and maybe even a hostage credit card. </li></p><li>The sender is visiting a website on my server, is an unauthorized and anonymous user. I don't know who to yell at when I find several gigabytes of bootlegged <abbr title="Mpeg layer 3 audio">MP3</abbr>s of the upcoming tribute album to Artis the Spoonman on my server.</p></li></p></ol> </p><p><p>Let us presume that we trust the authenticated users and ignore them for right now. We want to focus on the second case and try to eliminate some of the potential risks.</p></p><p><p>First how do we create a form where someone can upload a file?</p></p><p><pre></p>&lt;!--- Beginning for your file-upload form ---&gt;</p>&lt;form action=&quot;#BuildSelfURL()#&quot; method=&quot;POST&quot; </p>  name=&quot;MyForm&quot; enctype=&quot;multipart/form-data&quot;&gt;</p>  &lt;input type=&quot;file&quot; name=&quot;document&quot; size=&quot;35&quot; </p>    class=&quot;ft&quot; accept=&quot;text/plain,application/msword,&quot; </p>      &quot;application/pdf,application/rtf,application/mspowerpoint,&quot; &amp; </p>      &quot;application/x-visio,application/excel,application/x-msexcel,&quot; &amp;</p>      &quot;application/x-compressed,application/x-zip-compressed,&quot; &amp;</p>      &quot;application/vnd.ms-excel,application/x-excel,application/zip&quot;&gt;</p>&lt;/form&gt;</p></pre></p><p><p>Here, I am using a <abbr title="User-Defined Function">UDF</abbr> called <code>BuildSelfURL()</code> which will write a correct destination for my form with appropriate query string elements. You should probably replace it with whatever URL will handle your input validation and processing if you don't have this sort of thing built yet.</p></p><p><p>The <code>enctype=&quot;multipart/form-data&quot;</code> in the form is <strong>essential</strong>. Don't ask why if you don't want me to explain the reason to you in mind numbing detail. As you may guess the <code>input type=&quot;file&quot;</code> is what really telling the browser to help your user to select a file from his/her file system, and to send this file to the server when he/she submits the form. The <code>accept=&quot;...&quot;</code> bit is nice because it can help some of your potential users select acceptable files to begin with. This is not reliable because it is not widely implemented, and secondly because you can <strong>never trust clients</strong>. Client-side error checking should be done as a convenience to the user only, never as a safeguard for <em>anything</em>.</p></p><p><p>So how do we determine if the uploaded file is malicious?  We don't believe in achieving a secure computer system, short of unplugging the server and throwing it off the continental shelf. Since that won't help you secure your <em>functional</em> file upload system I will try to be practical and help you reduce the risk by trying to determine if a file is <em>unlikely</em> to be malicious and we let it in if it doesn't scare us too badly. Sound good?  OK, here we go.</p></p><p><pre></p>&lt;!---</p> Now test that any uploaded files are of an acceptable format before </p> we do any DB work. Presume we are working in a windows environment. </p> Upload destination uses \ notation to identify a directory.</p> ---&gt;</p><p>&lt;!--- uploaded file is of a generic business document format ---&gt;</p>&lt;cfif Len(form.document)&gt;</p>  &lt;cfset request.badext =&quot;cfml,cfm,asp,shtml,php,cgi&quot;&gt;</p>  &lt;cfset request.accept =&quot;text/plain,application/msword,&quot; &amp;</p>    &quot;application/pdf,application/rtf,application/mspowerpoint,&quot; &amp;</p>    &quot;application/x-visio,application/excel,application/x-msexcel,&quot; &amp;</p>    &quot;application/x-compressed,application/x-zip-compressed,&quot; &amp;</p>    &quot;application/vnd.ms-excel,application/x-excel,application/zip&quot;&gt;</p>  &lt;cffile action=&quot;UPLOAD&quot; filefield=&quot;form.document&quot; </p>    destination=&quot;#request.uploadtemp#\&quot; </p>    nameconflict=&quot;MAKEUNIQUE&quot;&gt;</p>  &lt;cfset request.tmpfilename = CFFile.ServerFile&gt;</p>  &lt;cfset request.filetype = CFFile.ContentType &amp; &quot;/&quot; &amp; </p>    CFFile.ContentSubType&gt;</p>  &lt;cfif ListFindNoCase(request.accept, request.filetype) AND NOT </p>    ListFindNoCase(request.badext, CFFile.ClientFileExt)&gt;</p>    &lt;cfset request.clientfile = CFFile.ClientFile&gt;</p>  &lt;cfelse&gt;</p>    &lt;cffile action=&quot;DELETE&quot; </p>      file=&quot;#request.uploadtemp#\#CFFile.ServerFile#&quot;&gt;</p>    &lt;cfset request.errors.document = &quot;Field: Document. The file &quot; &amp;</p>      &quot;format provided (#CFFile.ContentType#/&quot; &amp;</p>      &quot;#CFFile.ContentSubType#) is not allowed.&quot;&gt;</p>  &lt;/cfif&gt;</p>&lt;/cfif&gt;</p></pre></p><p><p>How do we decide what file extensions are bad?  Any scripting system can be dangerous.  Depending on what scripting languages your server offers and what permissions look like you may need to modify the list of bad file extensions.  You should also probably only allow those document MIME types that you need to.  Any MS Office format could be potentially dangerous for instance, depending on what DLLs live on your server and what bugs Microsoft has left behind.</p></p><p><p>What is <code>request.uploadtemp</code> anyway?  This is a temp directory <em>outside</em> of the web root. This directory must be outside the web root to eliminate a race condition in our system. That means that we do not, <em>even for a moment</em>, allow unacceptable file types to live on our file system where an http request could find it.</p></p><p><p>Why do we <code>MAKEUNIQUE</code>?  Because we don't know how many folks are uploading files at any given time, trying to get through our defenses. Best to not let them clobber each other's files.</p></p><p><p>Now <code>request.tmpfilename</code> stores the filename of the uploaded file as it was stored in our temp directory. This will be different from the file name that the client used for the file if there was a conflict with another file in the temp directory. I prefer to preserve the user's file name, so we stored that in <code>request.clientfile</code> as well.</p></p><p><p>At this point we have taken the file and placed it in this temp directory and looked at it's file type and file extension. If the type was known to be good, and the extension was not known to be bad, than we make a note of where we parked the file in our temp directory and what it was originally named. Otherwise, we delete the file and generate an error message. </p></p><p><p>NOTE: <code>request.errors</code> is a structure I use to manage error messages on forms. This code segment does not include the <code>StructNew()</code> that occurs elsewhere, but the later code depends on this.</p></p><p><p>When I am expecting an uploaded image I use a slightly different approach:</p></p><p><pre></p>[...]</p>&lt;cfset accept=&quot;image/gif,image/jpeg,image/pjpeg,image/jpg,image/png&quot;&gt;</p>&lt;cfset goodext=&quot;gif,jpg,jpeg,png&quot;&gt;</p>[...]</p>ListFindNoCase(request.goodext, CFFile.ClientFileExt)&gt;</p>[...]</p></pre></p><p><p>The changes should speak for themselves. Now we have this uploaded file that doesn't appear to be likely to harm us. How do we get the file to its permanent home?</p></p><p><pre></p>&lt;!--- </p> Only continue if no errors have been generated by form validation</p> ---&gt;</p>&lt;cfif NOT StructCount(errors)&gt;</p>  &lt;cftransaction&gt;</p>    &lt;!--- </p>     Generate DB record for this entry, used in producing file names</p>     ---&gt;</p>    &lt;cfquery name=&quot;insert&quot; datasource=&quot;#request.dsource#&quot; </p>      dbtype=&quot;#request.dbtype#&quot;&gt;</p>      INSERT INTO element (uploaded) VALUES (#Now()#)</p>    &lt;/cfquery&gt;</p>    &lt;cfquery name=&quot;getid&quot; datasource=&quot;#request.dsource#&quot; </p>      dbtype=&quot;#request.dbtype#&quot;&gt;</p>      SELECT MAX(id) AS id FROM element</p>    &lt;/cfquery&gt;</p><p>    &lt;!--- Perform final file activity ---&gt;</p>    &lt;cfif Len(request.clientfile)&gt;</p>      &lt;cfset request.filename=&quot;#getid.id##request.clientfile#&quot;&gt;</p>      &lt;cffile action=&quot;MOVE&quot; </p>        source=&quot;#request.uploadtemp#\#request.tmpfilename#&quot; </p>        destination=&quot;#session.mainuploadpath#\element\#filename#&quot; </p>        nameConflict=&quot;OVERWRITE&quot;&gt;</p>    &lt;/cfif&gt;</p>        </p>    &lt;!--- Update DB record ---&gt;</p>    &lt;cfif Len(request.filename)&gt;</p>      &lt;cfquery name=&quot;update&quot; datasource=&quot;#request.dsource#&quot; </p>        dbtype=&quot;#request.dbtype#&quot;&gt;</p>        UPDATE element</p>        SET document = '#request.filename#',</p>        WHERE id = '#getid.id#'</p>      &lt;/cfquery&gt;</p>    &lt;cfelse&gt;</p>      &lt;cfquery name=&quot;delete&quot; datasource=&quot;#request.dsource#&quot; </p>        dbtype=&quot;#request.dbtype#&quot;&gt;</p>        DELETE </p>        FROM element</p>        WHERE id = '#getid.id#'</p>      &lt;/cfquery&gt;</p>    &lt;/cfif&gt;</p>  &lt;/cftransaction&gt;</p>&lt;/cfif&gt;</p></pre></p><p><p>I am inserting a record into my database to record this file upload. Put in whatever interesting data fields and content you like here.... you may have other form fields on the page and may want to store data about them too.</p></p><p><p>Then I get the (primary key &amp; auto-incremented identity) id for that newly-inserted record.</p></p><p><p>Next I move the file to its permanent home. I use the record id and the client's chosen filename together here to store the file, that way two different people could upload two different files with the same file name, and they would not end up clobbering each other, plus it is easy to connect the files in your file system with the DB records later. Note that I chose to overwrite this time. This is the behavior I prefer, <abbr title="Your milage may vary.">YMMV</abbr>.</p></p><p><p>Finally, now that I know what the final file name of this uploaded document is, I can save that in the database so I update the record I just inserted. Sleep well.</p></p><p><p>As a final note, you should always use proper error handling techniques.  In particular, there are a number of instances where <code>CFTRY/CFCATCH</code> blocks should be used to trap potential errors.  The error handling code has not been included in the code samples above for simplicity and clarity.</p>