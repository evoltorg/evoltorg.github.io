---
layout: post
permalink: node/35930
ratings: 8
avgrate: 4.2500
user: codepo8
real_name: "Chris Heilmann"
user_since: 29 Jul 2002
avatar: "/images/pictures/picture-35456.jpg"
article_count: 17
excerpt: "XML is sexy, PHP and XML is a cheap and good way to create and syndicate your website. Now, when you have your own server, you can set up all the necessary apache add-ons to explore the PHP-XML relationship to the full extend. When you own a virtual server at an ISP, you can't do that. Still, there "
---
<h2>Admin, can I play with XML please?</h2></p><p>So you learnt about the beauty of XML, and you want to use it. You scan the web to find out how to do that. You find half-baked Internet Explorer solutions like Data Islands and loads of XSLT parsers and apache add-ons that help you using XML.</p></p><p>Great, all you need to do is patch and upgrade your server and the world of content and display separated web development is open for you to explore.</p></p><p>You read the specifications of the various techniques (Cocoon, Sablotron, Saxon, Xalan, Xerxes and the whole lot) and mail the tech support of your web space provider to please install them for you so you can XML-enable your site.</p></p><p>Just to get an email back stating <em>"sorry, we don't do that"</em>.</p></p><p>The end of the road? Not really, there's a very quick and dirty way how to use XML to generate your pages, by using two really easy PHP functions and some clever HTML.</p></p><p>This solution has some drawbacks, which will be explained, at the end of this article. However, with a bit of clever XML structure, you can do a lot without getting your head around XPATH, XSLT and server administration.</p></p><h2>PHP untag() to the rescue</h2></p><p>The main PHP function is this:</p></p><pre></p>function untag($string,$tag,$mode){ </p>    $tmpval=""; </p>    $preg="/&lt;".$tag."&gt;(.*?)&lt;/".$tag."&gt;/si"; </p>    preg_match_all($preg,$string,$tags); </p>    foreach ($tags[1] as $tmpcont){ </p>        if ($mode==1){$tmpval[]=$tmpcont;} </p>        else {$tmpval.=$tmpcont;} </p>        } </p>    return $tmpval; </p>}</p></pre></p><p>What it does is to extract the content of all tags "$tag" in string "$string". When "$mode" is 1 it returns the content as an array, otherwise as a string. </p></p><p>No rocket science, just another example of what regular expressions can do for you.</p></p><p>And that is all you want to do: extract the content from the XML tags.</p></p><p>With XSLT you can do that a lot better, but for smaller solutions, and with a bit of PHP knowledge, a lot can be done.</p></p><p>Now, how to use that? Let's say you want to create a news page on your site and you want to use XML to store the data.</p></p><p>You want to make sure that only the last three news-items are displayed, and the rest will be stored in an archive. To make the news page really handy, toss in a "search" functionality.</p></p><p>The first step would be to define the XML you will use. For this exercise, you type this XML, in a second phase we can also explore how to generate it via a web form. This will make your news page fully maintainable online.</p></p><h2>Enter: The XML data</h2></p><p>The XML is as follows:</p></p><pre></p>&lt;?xml version="1.0"?&gt; </p>&lt;page&gt; </p>    &lt;item&gt; </p>        &lt;id&gt;&lt;/id&gt; </p>        &lt;date&gt;&lt;/date&gt; </p>        &lt;headline&gt;&lt;/headline&gt; </p>        &lt;copy&gt;&lt;/copy&gt; </p>    &lt;/item&gt; </p>&lt;/page&gt; </p></pre></p><p>Each piece of news is an item and has a unique ID (to make it easier to identify in the editable version), the date it was entered, a headline and the news text (as copy).</p></p><p>Now, as you want to separate display from logic and content, use an HTML template for display. Of course the whole HTML could be in the PHP page, but by using a template, the display could also be tweaked by someone not knowing PHP at all.</p></p><p>To tell PHP what to display, add HTML comments to the template. The script will replace them with the real data later. Furthermore add comments with "start:" and "end:" to allow PHP to keep or delete parts of HTML according to which page should be displayed.</p></p><p><h2>Teaching your HTML how to speak PHP</h2></p><p>The template in the zip to this article has all the necessary comments added and explained. For the moment let's focus on the display of the news only:</p></p><pre></p>&lt;!-- start:newsitem --&gt; </p>    &lt;div class="date"&gt; &lt;!-- date --&gt; &lt;/div&gt;</p>    &lt;div class="headline"&gt; &lt;!-- headline --&gt; &lt;/div&gt; </p>    &lt;div class="copy"&gt; &lt;!-- copy --&gt; &lt;/div&gt; </p>    &lt;div class="shadow"&gt;&lt;/div&gt; </p>    &lt;br /&gt; </p>&lt;!-- end:newsitem --&gt;</p></pre></p><p>This is how one piece of news will be displayed. The date, the headline and the copy comments will be replaced by the XML data.</p></p><p>To embed the template and the XML we use a function called load(), which does nothing but load the content of a file, and store it in a variable.</p></p><p><p>To extract the "news HTML block" from the template, use preg_match:</p></p><p><code>preg_match("/&lt;!-- start:newsitem --&gt;(.*?)&lt;!-- end:newsitem --&gt;/si", $template, $newshtml);</code></p><p><p>this grabs everything within those two comments and stores it in the array $newshtml.</p></p><p><p>From the XML, grab all the news items by calling</p></p><p><code>$items=untag($xml,"item",1);</code></p><p><p>and reverse the order of this array, so that the most recent news come first.</p></p><p><p>Now you have all the news items in an array called items. Each item contains the date, the headline, the copy and the id.</p></p><p><h2>Displaying the news</h2></p><p>To display the news on the page, loop through the array.</p></p><p>Grab the "news HTML block" each time and replace the comments with the corresponding XML data, using untag(). Add each of these HTML chunks to an include variable.</p></p><p><pre></p>foreach ($items as $i){ </p>    $tmphtml=$newshtml[0]; </p>    $tmphtml=str_replace("&lt;!-- date --&gt;",untag($i,"date",0),$tmphtml); </p>    $tmphtml=str_replace("&lt;!-- headline --&gt;",untag($i,"headline",0),$tmphtml); </p>    $tmphtml=str_replace("&lt;!-- copy --&gt;",untag($i,"copy",0),$tmphtml); </p>    $newsinclude.=$tmphtml; </p>}</p></pre></p><p>Then replace the raw "news HTML block" in the template with the include:</p></p><p><code>$template= preg_replace ("/&lt;!-- start:newsitem --&gt;(.*?)&lt;!-- end:newsitem --&gt;/si", $newsinclude, $template);</code></p><p>and display it.</p></p><p><p>To differentiate between news and archive page, you simply don't use a "foreach" but display only a part of the news items (1 to 3 for the news page, 4 to the end for the archive). To find search results, compare each item with a search query.</p></p><p><p>Put all together and you have your XML based news page.</p></p><p><p>The script to this article is highly commented, and should be quite self-explanatory. After all this here should just explain what power the small but fine function untag() gives you.</p></p><p><h2>The good, the bad and the ugly</h2></p><p>This technique does not give you full control over XML documents. It's just an easy way to use basic XML and create HTML from that.</p></p><p>By adding a possibility to add, delete and alter the XML via a form, you can create a basic, lightweight CMS tool.</p></p><p>The flat-file ASCII data in XML format is also readable and editable directly, much unlike the oldschool flatfiles separating the news bit by pipe characters or commas.</p></p><p>The news data can contain any character, even HTML, without breaking apart (a thing that easily happens with comma separated data files).</p></p><p>However, it cannot handle the more complex XML structures, a real solution using XSLT and a parser can handle.</p></p><p><p>This technique does not recognise:</p></p><ul></p><li>empty tags being closed in themselves like <code>&lt;empty/&gt;</code></li></p><li>attributes like <code>&lt;empty isneeded="true" /&gt;</code></li></p></ul></p><p>Furthermore you need to use unique tags for each item. A real XSLT parser can differentiate between the &lt;element&gt;s in this example:</p></p><p><pre></p>&lt;item&gt; </p>    &lt;element&gt</p>        &lt;element&gt;&lt;/element&gt</p>    &lt;/element&gt;</p>&lt;/item&gt; </p></pre></p>       </p><p>untag() returns the first element value with the second one embedded.</p></p><p><p>It works much like an &lt;xsl:value-of select="//element"/&gt; command in XSLT.</p></p><p><p>Now grab the sample script, template and XML and see for yourself. <a href="http://www.onlinetools.org/articles/xml_with_php_demofiles.zip" title="Demofiles for the evolt article">Download demo files</a></p>