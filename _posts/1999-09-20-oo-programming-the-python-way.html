---
layout: post
permalink: node/449
---
<h2>Unrelevant matters</h2></p><p><p>\nOk, now we are in part two, the sequel, the continuation, the second awakening.  We are moving closer to discussing Zope, the coolest web application server around. I actually type this article in Zope-structured format (which is just an ASCII file with indentation rules) and let Zope render it as an HTML file. There is no need for me to worry about HTML tags. Check out at <a href="http://www.zope.org">Zope.org</a> and don't forget to take the picture of your face with your jaw dropped.\n</p></p><p><p>\nThe last article gives you the absolute basics of using Python. This time, we'll do the OO side of Python. Yes, Python: a true object-oriented language with classes, inheritance and all.\n</p></p><p><p>\nOk, my OO background comes from the usual suspects of OO language, C++, Java and Object Pascal (Delphi). So I have this preconceived idea about what Python OO <em>should</em> be.  When I discover how OO is implemented in Python, my first reaction was: "What the <code>expletive</code> is this s#~! ?" My idealism about OO is offended by what Python does with object and classes. It offers a new perspective on what can be done with classes and object. Over time Python has grown on me, and now I can really appreciate what it can do. So if you have the same reaction as mine, keep reading. It will grow on you as well.\n</p></p><p><p>\nWe are going to tear down and really push object today. Have your seat belt on?\n</p></p><p><p>\nThis is what you get in a Python class. (I assume you already know OO. If not, get a decent book on it, as it's very important to understand the concept. If you code exclusively in VB, learn another language, you haven't used OO yet.)\n</p></p><p><p>\nThese are some of the OO goodies that come with Python:\n</p></p><p><ul>\n<li>No explicit support for private, protected or public method and data member</li>\n<li>Multiple Inheritance</li>\n<li>All methods are virtual</li>\n<li>Run time object modification</li>\n<li>Ability to create your object, and forget about it. The system takes care of it, just like Java (albeit with different mechanism -- Python uses reference counting instead of garbage collector)</li>\n<li>Polymorphism -- well of course you get it, although it's different from what you might think</li>\n<li>Easy-to-use persistency support</li>\n<li>How about generic object container that can contain objects of any kind ?</li>\n</ul></p><p><p>\nBut before dwelling on the class, let's talk briefly about using external libraries.<br><code>import string</code>\n</p></p><p><p>\nNow you can use all the function in string module. Check the library reference that comes with your Python installation for more external function libraries:<br><code>string.split('Split;This',';')</code>\n</p></p><p><p>\nYou need to qualify them. I usually use this notation if I don't use the function often in my code. Otherwise, you can always use function aliasing (remember the previous article):\n</p></p><p><pre>\nsplit = string.split\nsplit('Split;This',';')\n</pre></p><p><p>\nAnother way is to use explicit function import:<br><code>from string import split, find</code>\n</p></p><p><p>\nThis imports the function explicitly so you can use without the module prefix:<br><code>split('Split;This',';')</code>\n</p></p><p><p>\nOf course, you can just import the whole lot of them. Now you can use all the  exportable function from string module without using module prefixes. Remember the word "exportable":<br><code>from string import *</code>\n</p></p><p><h2>Create your own module</h2></p><p><p>\nCreate your collection of functions and put them in a file. All functions defined in the file where names aren't started with _ prefix are exportable. To keep the function "private" in the module, add _ (underscore) prefix in front of the function name:\n</p></p><p><pre>\ndef PrintMyName():\nprint &quot;My Name&quot;</p><p>def PrintMyAge():\n print &quot;Your age&quot;</p><p>def _PrintMe():\nprint &quot;This can't be used&quot;\n</pre></p><p><p>\nand save it as <code>myLib.py</code>. Then use it like this. See that the file name becomes the module name. That applies for other libraries as well. The string library would be stored in a file called <code>string.py</code>. You can find it in your (python directory)/bin/lib directory:\n</p></p><p><pre>\nimport myLib </p><p>myLib.PrintMyName()   myLib.PrintMyAge() </p><p> #This will result in error  \n myLib._PrintMe()\n</pre></p><p><h2>Wacky class</h2></p><p><p>\nMany papers uses the terms class and class instance. I don't like them because they can be hard to understand. I will use classes and objects instead in this article. Class is well, class, and object is what you create from the class. Object is run-time.\n</p></p><p><p>\nThis is how you declare an empty class. The "pass" is a keyword which does nothing. You use it  just to meet the requirements of a construct that requires at least one statement:<br><code>class Person :  pass</code>\n</p></p><p><p>\nThis is the simplest form of class.\n</p></p><p><p>\nThen to be useful, you should make the object out of it:<br><code> p = Person()</code>\n</p></p><p><p>\nOf course, the object does nothing at this point. You are about to see the "run time object modification" features of Python.\n</p></p><p><p>\nNow you can declare a new variable for the object:<br><code> p.Name = "John" <br> p.Age  = 20</code>\n</p></p><p><p>\nNotice that <em>you</em> are actually assigning a new variable to an object. Of course you can retrieve it again:<br><code>print "My name is",p.Name,"and my age is",p.Age</code>\n</p></p><p><p>\nHow about function ? Well, you can do it as well:\n</p></p><p><pre>\ndef Address()\nprint &quot;Omaha, Nebraska, USA&quot; </p><p>p.Address = Address </p><p>#then use it as usual \n p.Address()\n</pre></p><p><p>\nIt would be the end of the world before Java allows you to do this. Imagine what you can do with this feature. How about creating a class factory that keeps enhancing the currently live object by <code>patching</code> them with more and more data and attributes (or delete them)? Genetic programming, anyone ? You can also use the class to act like record or structure to store data. Or as a more efficient variant records (Object Pascal) or union (C/C++).\n</p>  </p><p><h2>Object assignment</h2></p><p><p>\nContinuing the previous example, if you assign <code>p</code> to another variable, you are actually copying the reference to the object, not the copy of the object itself. The following example should make it clear:\n</p></p><p><pre>\nm = p \nm.Age = 30 \nprint p.Age,&quot;is the same as&quot;,m.Age\n</pre></p><p><p>\nChanging the Age attributes thru m  changes the object it points to. Because <code>p</code> points to the same object, of course the printed value is the same.\n</p></p><p><h2>Copy by value</h2></p><p><p>\nPython does not support copy by value in the language. But there is a module which provides the facility for object copy. It's the creatively-named <b>copy</b> module.\n</p></p><p><p>\nThe module provides two type of copies:\n</p></p><p><h3>Shallow Copy</h3></p><p><p>\nThis will create a new object and copy the value of the copied object to this new object. However, if the copied object has a reference to another object (aggregation) , the new object would get the reference to this <code>child</code> object. So in the end, you would have two object that points to the same child object:\n</p></p><p><pre>\n    class Parent : \n         def __init__(self,name):  self.name = name \n         def HasChild (self,child): self.child = child \n   class Child :  def __init__(self,name):  self.name = name \n   A = Parent(&quot;John&quot;)   A.HasChild (Child(&quot;David&quot;)) \n   import copy \n   B = copy.copy (A) \n   B.name = &quot;Marco&quot;   B.child.name = &quot;Emmanuella&quot; \n   print B.name, 'has a child named',B.child.name\n   print A.name, 'also has a child named',A.child.name\n</pre></p><p><h3>Deep Copy</h3></p><p><p>\nLike shallow copy, it creates a new object and copies the value from the copied object   to the new object. For child object, the child object is recreated for the new object.  So in the end, the new object would get a <code>child</code> object of its own, instead of just    getting the object reference. This way, you got two object with two child object:\n</p></p><p><pre>\n    B = copy.deepcopy (A) \n B.name = &quot;Marco&quot;   B.child.name = &quot;Emmanuella&quot; \n print B.name, 'has a child named',B.child.name  \n print A.name, 'has a child of different name',A.child.name    \n</pre></p><p><h2>Proper class : constructor</h2></p><p><p>\nThis is how you declare constructor in Python classes:\n</p></p><p><pre>\nclass Person:\ndef __init__(self):  self.Name = 'Me'\nself.Age  = 20\n</pre></p><p><p>\nI bet the first thing you ask is, "What is self"? Python class requires every method to have at least  one argument to pass the object itself implicitly. So if you use __init__() it will actually generate an error. Python uses the first argument for passing the object itself to the methods. The convention is to use self as the name of this argument. You can use another name for this, but it would make life easier for you and others if you stick with the convention <code>self</code>.\n</p></p><p><p>\nIn Python, there is no method overloading.\n</p></p><p><p>\nThe statement self.Name and self.Age creates object data member. In other words, this data member would be created exclusively for each object, as opposed to class data member, where the values are shared by all objects. Let's add some more new stuff:\n</p></p><p><pre>\n class Person:\n 	def __init__(self,Name='Me',Age=20):\n                 self.Name = Name  self.Age  = Age \n         def AboutMe(self):\n          print 'My name is',self.Name,'and I am',self.Age,'old' \n         def SetName(self, Name):  self.Name = Name \n         def SetAge (self, Age):  self.Age  = Age\n</pre></p><p><p>\nThe class is more complete right now. Notice that I use default arguments for the  constructor. Let's see how we use it:\n</p></p><p><pre>\n   me  = Person('Dody',21)   you = Person() \n   me.AboutMe()   you.AboutYou() \n   you.SetName(&quot;Bobby Brown&quot;)   you.SetAge (30) \n   me.AboutMe()   you.AboutMe()\n</pre></p><p><p>\nYou see that we don't actually pass something to the AboutMe although the method has one argument. That's what I mean by saying Python uses the first argument implicitly to pass the object to the methods. So you can ignore it.\n</p></p><p><h2>It's public</h2></p><p><p>\nThe SetAge and SetName method in Person class in the previous example is redundant. Why? because the object data member Name and Age is public. So you can directly access it using, using the previous object creation:\n</p></p><p><pre>\n me.Name = &quot;John Kaster&quot;   me.Age  = 31 \n me.AboutMe()\n</pre></p><p><p>\nTo make it private, use the __ (double underscores) trick. This trick also applies for method as well:\n</p></p><p><pre>\n  class Person:\n def __init__(self,Name='Me',Age=20): self.__Name = Name  self.__Age  = Age \n          def AboutMe(self):\n           print 'My name is',self.__Name,'and I am',self.__Age,'old' \n          def SetName(self, Name): self.__Name = Name \n          def SetAge (self, Age): self.__Age  = Age \n          def __LieMyAge (Lie='5') self.__Age = self.__Age - Lie\n</pre></p><p><p>\nNow, you cannot access the Name and Age data member directly, and hat applies to LieMyAge as well. So this won't work:\n</p>  </p><p><pre>\n me = Person() \n me.__Name = 'Dody' \n me.__LieMyAge() \n me.AboutMe()\n</pre></p><p><p>\nBut off course it's all a scam, a deceit, a lie. Do you know what the __ does to your variable/methods ? Python interpreters actually do a name mangling with anything that has double underscores, in the form of  _classname__var/function name. That's why "me.__Name" or "me.__LieMyAge()" doesn't work, because they don't exist as far as Python is concerned. So the below example will actually work:\n</p></p><p><pre>\n    me = Person()   \n me._Person__Name = 'Dody'   \n me._Person__LieMyAge()   \n me.AboutMe()\n</pre></p><p><p>\nOf course, you need to be determined to access those attributes,  but again it is all possible with Python. Being able to use it doesn't mean that you <em>have</em> to use it. Use your own judgment as to when it is appropriate.\n</p></p><p><h2>Polymorphism</h2></p><p><p>\nPeople would laugh if someone actually talked about Polymorphism without explaining  inheritance first. But I can do this in Python due to the way Python handles variables.  Python variables do not have a type, so the traditional concept of Polymorphism where a parent class variable can call it's children methods doesn't exist or make a difference. I can use one variable to hold any kind of objects. No matter what kind of object the variable is referring too, as  long as the object has the method name I call, everything is OK. Object type is not important. Virtual methods make no difference in terms of Polymorphism in Python,  but it does have an effect in inheritance:\n</p></p><p><pre>\n class Monkey:\n  	def show(self):\n                  	print &quot;This is monkey&quot; \n class Car:\n          	def show(self):\n                 print &quot;This is a car&quot; \n class House:\n 	def show(self):\n                  print &quot;This is a house&quot; </p><p> #Create empty list   \n list = [ ]</p><p> #Add objects to the list    \n list.append (Monkey())   \n list.append (Car())   \n list.append (House()) </p><p> #Iterates on the list  \n for x in list: \n x.show() \n #The loop prints   \n #&quot;This is monkey&quot;    \n#&quot;This is a car&quot;    \n#&quot;This is a house&quot;  \n</pre></p><p><p>\nThe above example uses the usual algorithm other books use to demonstrate polymorphism. It works simpler in Python. However, you probably missed a subtle thing that the example shows. It is that the list can hold three object of different type and call the methods without any typecasting at all. Generic object containers are the holy grails of other OO languages. You can't do this directly in C++, Object Pascal or even in Java. In Java at least you can use list-type interfaces, which the objects have to support. In C++ or Object Pascal, the list has to be the parent type of those objects, which is more restrictive than an interface. Can you see what Python offers for the OO world?\n</p></p><p><p>\nThe statement <code>x.show()</code> is an exception if the current object referred by x does have show() method. However, you can detect whether the object has a particular method by using the built-in function <em>hasattr(obj,name)</em>:\n</p></p><p><pre>\n   if hasattr(x,'show'): \n   # or \n   if hasattr(Monkey(),'show'):\n</pre></p><p><p>\nYou can use this before inserting the object into the list or just before executing the method <code>show()</code>. Notice you only insert the name, not the arguments (this is possible because there is no method overloading in Python).\n</p></p><p><h2>Inheritance</h2></p><p><p>\nInheritance and multiple inheritance will be discussed in the next article, including some other aspects of OO in Python. We will dissect  every line of code of the httplib object and see any way we can extend it using Python inheritance. You would be suprised how simple it is. And before I forget, some discussion about tuples will also be included. Until that time, enjoy your Python.\n</p>