---
layout: post
permalink: node/449
ratings: 3
avgrate: 4.0000
user: nirataro
real_name: "Dody Gunawinata"
user_since: 1999-08-23
avatar: ""
article_count: 5
excerpt: "Unrelevant matters Ok, now we are in part two, the sequel, the continuation, the second awakening.  We are moving closer to discussing Zope, the coolest web application server around."
---
<h2>Unrelevant matters</h2></p><p><p></p>Ok, now we are in part two, the sequel, the continuation, the second awakening.  We are moving closer to discussing Zope, the coolest web application server around. I actually type this article in Zope-structured format (which is just an ASCII file with indentation rules) and let Zope render it as an HTML file. There is no need for me to worry about HTML tags. Check out at <a href="http://www.zope.org">Zope.org</a> and don't forget to take the picture of your face with your jaw dropped.</p></p></p><p><p></p>The last article gives you the absolute basics of using Python. This time, we'll do the OO side of Python. Yes, Python: a true object-oriented language with classes, inheritance and all.</p></p></p><p><p></p>Ok, my OO background comes from the usual suspects of OO language, C++, Java and Object Pascal (Delphi). So I have this preconceived idea about what Python OO <em>should</em> be.  When I discover how OO is implemented in Python, my first reaction was: "What the <code>expletive</code> is this s#~! ?" My idealism about OO is offended by what Python does with object and classes. It offers a new perspective on what can be done with classes and object. Over time Python has grown on me, and now I can really appreciate what it can do. So if you have the same reaction as mine, keep reading. It will grow on you as well.</p></p></p><p><p></p>We are going to tear down and really push object today. Have your seat belt on?</p></p></p><p><p></p>This is what you get in a Python class. (I assume you already know OO. If not, get a decent book on it, as it's very important to understand the concept. If you code exclusively in VB, learn another language, you haven't used OO yet.)</p></p></p><p><p></p>These are some of the OO goodies that come with Python:</p></p></p><p><ul></p><li>No explicit support for private, protected or public method and data member</li></p><li>Multiple Inheritance</li></p><li>All methods are virtual</li></p><li>Run time object modification</li></p><li>Ability to create your object, and forget about it. The system takes care of it, just like Java (albeit with different mechanism -- Python uses reference counting instead of garbage collector)</li></p><li>Polymorphism -- well of course you get it, although it's different from what you might think</li></p><li>Easy-to-use persistency support</li></p><li>How about generic object container that can contain objects of any kind ?</li></p></ul></p><p><p></p>But before dwelling on the class, let's talk briefly about using external libraries.<br><code>import string</code></p></p></p><p><p></p>Now you can use all the function in string module. Check the library reference that comes with your Python installation for more external function libraries:<br><code>string.split('Split;This',';')</code></p></p></p><p><p></p>You need to qualify them. I usually use this notation if I don't use the function often in my code. Otherwise, you can always use function aliasing (remember the previous article):</p></p></p><p><pre></p>split = string.split</p>split('Split;This',';')</p></pre></p><p><p></p>Another way is to use explicit function import:<br><code>from string import split, find</code></p></p></p><p><p></p>This imports the function explicitly so you can use without the module prefix:<br><code>split('Split;This',';')</code></p></p></p><p><p></p>Of course, you can just import the whole lot of them. Now you can use all the  exportable function from string module without using module prefixes. Remember the word "exportable":<br><code>from string import *</code></p></p></p><p><h2>Create your own module</h2></p><p><p></p>Create your collection of functions and put them in a file. All functions defined in the file where names aren't started with _ prefix are exportable. To keep the function "private" in the module, add _ (underscore) prefix in front of the function name:</p></p></p><p><pre></p>def PrintMyName():</p>print &quot;My Name&quot;</p><p>def PrintMyAge():</p> print &quot;Your age&quot;</p><p>def _PrintMe():</p>print &quot;This can't be used&quot;</p></pre></p><p><p></p>and save it as <code>myLib.py</code>. Then use it like this. See that the file name becomes the module name. That applies for other libraries as well. The string library would be stored in a file called <code>string.py</code>. You can find it in your (python directory)/bin/lib directory:</p></p></p><p><pre></p>import myLib </p><p>myLib.PrintMyName()   myLib.PrintMyAge() </p><p> #This will result in error  </p> myLib._PrintMe()</p></pre></p><p><h2>Wacky class</h2></p><p><p></p>Many papers uses the terms class and class instance. I don't like them because they can be hard to understand. I will use classes and objects instead in this article. Class is well, class, and object is what you create from the class. Object is run-time.</p></p></p><p><p></p>This is how you declare an empty class. The "pass" is a keyword which does nothing. You use it  just to meet the requirements of a construct that requires at least one statement:<br><code>class Person :  pass</code></p></p></p><p><p></p>This is the simplest form of class.</p></p></p><p><p></p>Then to be useful, you should make the object out of it:<br><code> p = Person()</code></p></p></p><p><p></p>Of course, the object does nothing at this point. You are about to see the "run time object modification" features of Python.</p></p></p><p><p></p>Now you can declare a new variable for the object:<br><code> p.Name = "John" <br> p.Age  = 20</code></p></p></p><p><p></p>Notice that <em>you</em> are actually assigning a new variable to an object. Of course you can retrieve it again:<br><code>print "My name is",p.Name,"and my age is",p.Age</code></p></p></p><p><p></p>How about function ? Well, you can do it as well:</p></p></p><p><pre></p>def Address()</p>print &quot;Omaha, Nebraska, USA&quot; </p><p>p.Address = Address </p><p>#then use it as usual </p> p.Address()</p></pre></p><p><p></p>It would be the end of the world before Java allows you to do this. Imagine what you can do with this feature. How about creating a class factory that keeps enhancing the currently live object by <code>patching</code> them with more and more data and attributes (or delete them)? Genetic programming, anyone ? You can also use the class to act like record or structure to store data. Or as a more efficient variant records (Object Pascal) or union (C/C++).</p></p>  </p><p><h2>Object assignment</h2></p><p><p></p>Continuing the previous example, if you assign <code>p</code> to another variable, you are actually copying the reference to the object, not the copy of the object itself. The following example should make it clear:</p></p></p><p><pre></p>m = p </p>m.Age = 30 </p>print p.Age,&quot;is the same as&quot;,m.Age</p></pre></p><p><p></p>Changing the Age attributes thru m  changes the object it points to. Because <code>p</code> points to the same object, of course the printed value is the same.</p></p></p><p><h2>Copy by value</h2></p><p><p></p>Python does not support copy by value in the language. But there is a module which provides the facility for object copy. It's the creatively-named <b>copy</b> module.</p></p></p><p><p></p>The module provides two type of copies:</p></p></p><p><h3>Shallow Copy</h3></p><p><p></p>This will create a new object and copy the value of the copied object to this new object. However, if the copied object has a reference to another object (aggregation) , the new object would get the reference to this <code>child</code> object. So in the end, you would have two object that points to the same child object:</p></p></p><p><pre></p>    class Parent : </p>         def __init__(self,name):  self.name = name </p>         def HasChild (self,child): self.child = child </p>   class Child :  def __init__(self,name):  self.name = name </p>   A = Parent(&quot;John&quot;)   A.HasChild (Child(&quot;David&quot;)) </p>   import copy </p>   B = copy.copy (A) </p>   B.name = &quot;Marco&quot;   B.child.name = &quot;Emmanuella&quot; </p>   print B.name, 'has a child named',B.child.name</p>   print A.name, 'also has a child named',A.child.name</p></pre></p><p><h3>Deep Copy</h3></p><p><p></p>Like shallow copy, it creates a new object and copies the value from the copied object   to the new object. For child object, the child object is recreated for the new object.  So in the end, the new object would get a <code>child</code> object of its own, instead of just    getting the object reference. This way, you got two object with two child object:</p></p></p><p><pre></p>    B = copy.deepcopy (A) </p> B.name = &quot;Marco&quot;   B.child.name = &quot;Emmanuella&quot; </p> print B.name, 'has a child named',B.child.name  </p> print A.name, 'has a child of different name',A.child.name    </p></pre></p><p><h2>Proper class : constructor</h2></p><p><p></p>This is how you declare constructor in Python classes:</p></p></p><p><pre></p>class Person:</p>def __init__(self):  self.Name = 'Me'</p>self.Age  = 20</p></pre></p><p><p></p>I bet the first thing you ask is, "What is self"? Python class requires every method to have at least  one argument to pass the object itself implicitly. So if you use __init__() it will actually generate an error. Python uses the first argument for passing the object itself to the methods. The convention is to use self as the name of this argument. You can use another name for this, but it would make life easier for you and others if you stick with the convention <code>self</code>.</p></p></p><p><p></p>In Python, there is no method overloading.</p></p></p><p><p></p>The statement self.Name and self.Age creates object data member. In other words, this data member would be created exclusively for each object, as opposed to class data member, where the values are shared by all objects. Let's add some more new stuff:</p></p></p><p><pre></p> class Person:</p> 	def __init__(self,Name='Me',Age=20):</p>                 self.Name = Name  self.Age  = Age </p>         def AboutMe(self):</p>          print 'My name is',self.Name,'and I am',self.Age,'old' </p>         def SetName(self, Name):  self.Name = Name </p>         def SetAge (self, Age):  self.Age  = Age</p></pre></p><p><p></p>The class is more complete right now. Notice that I use default arguments for the  constructor. Let's see how we use it:</p></p></p><p><pre></p>   me  = Person('Dody',21)   you = Person() </p>   me.AboutMe()   you.AboutYou() </p>   you.SetName(&quot;Bobby Brown&quot;)   you.SetAge (30) </p>   me.AboutMe()   you.AboutMe()</p></pre></p><p><p></p>You see that we don't actually pass something to the AboutMe although the method has one argument. That's what I mean by saying Python uses the first argument implicitly to pass the object to the methods. So you can ignore it.</p></p></p><p><h2>It's public</h2></p><p><p></p>The SetAge and SetName method in Person class in the previous example is redundant. Why? because the object data member Name and Age is public. So you can directly access it using, using the previous object creation:</p></p></p><p><pre></p> me.Name = &quot;John Kaster&quot;   me.Age  = 31 </p> me.AboutMe()</p></pre></p><p><p></p>To make it private, use the __ (double underscores) trick. This trick also applies for method as well:</p></p></p><p><pre></p>  class Person:</p> def __init__(self,Name='Me',Age=20): self.__Name = Name  self.__Age  = Age </p>          def AboutMe(self):</p>           print 'My name is',self.__Name,'and I am',self.__Age,'old' </p>          def SetName(self, Name): self.__Name = Name </p>          def SetAge (self, Age): self.__Age  = Age </p>          def __LieMyAge (Lie='5') self.__Age = self.__Age - Lie</p></pre></p><p><p></p>Now, you cannot access the Name and Age data member directly, and hat applies to LieMyAge as well. So this won't work:</p></p>  </p><p><pre></p> me = Person() </p> me.__Name = 'Dody' </p> me.__LieMyAge() </p> me.AboutMe()</p></pre></p><p><p></p>But off course it's all a scam, a deceit, a lie. Do you know what the __ does to your variable/methods ? Python interpreters actually do a name mangling with anything that has double underscores, in the form of  _classname__var/function name. That's why "me.__Name" or "me.__LieMyAge()" doesn't work, because they don't exist as far as Python is concerned. So the below example will actually work:</p></p></p><p><pre></p>    me = Person()   </p> me._Person__Name = 'Dody'   </p> me._Person__LieMyAge()   </p> me.AboutMe()</p></pre></p><p><p></p>Of course, you need to be determined to access those attributes,  but again it is all possible with Python. Being able to use it doesn't mean that you <em>have</em> to use it. Use your own judgment as to when it is appropriate.</p></p></p><p><h2>Polymorphism</h2></p><p><p></p>People would laugh if someone actually talked about Polymorphism without explaining  inheritance first. But I can do this in Python due to the way Python handles variables.  Python variables do not have a type, so the traditional concept of Polymorphism where a parent class variable can call it's children methods doesn't exist or make a difference. I can use one variable to hold any kind of objects. No matter what kind of object the variable is referring too, as  long as the object has the method name I call, everything is OK. Object type is not important. Virtual methods make no difference in terms of Polymorphism in Python,  but it does have an effect in inheritance:</p></p></p><p><pre></p> class Monkey:</p>  	def show(self):</p>                  	print &quot;This is monkey&quot; </p> class Car:</p>          	def show(self):</p>                 print &quot;This is a car&quot; </p> class House:</p> 	def show(self):</p>                  print &quot;This is a house&quot; </p><p> #Create empty list   </p> list = [ ]</p><p> #Add objects to the list    </p> list.append (Monkey())   </p> list.append (Car())   </p> list.append (House()) </p><p> #Iterates on the list  </p> for x in list: </p> x.show() </p> #The loop prints   </p> #&quot;This is monkey&quot;    </p>#&quot;This is a car&quot;    </p>#&quot;This is a house&quot;  </p></pre></p><p><p></p>The above example uses the usual algorithm other books use to demonstrate polymorphism. It works simpler in Python. However, you probably missed a subtle thing that the example shows. It is that the list can hold three object of different type and call the methods without any typecasting at all. Generic object containers are the holy grails of other OO languages. You can't do this directly in C++, Object Pascal or even in Java. In Java at least you can use list-type interfaces, which the objects have to support. In C++ or Object Pascal, the list has to be the parent type of those objects, which is more restrictive than an interface. Can you see what Python offers for the OO world?</p></p></p><p><p></p>The statement <code>x.show()</code> is an exception if the current object referred by x does have show() method. However, you can detect whether the object has a particular method by using the built-in function <em>hasattr(obj,name)</em>:</p></p></p><p><pre></p>   if hasattr(x,'show'): </p>   # or </p>   if hasattr(Monkey(),'show'):</p></pre></p><p><p></p>You can use this before inserting the object into the list or just before executing the method <code>show()</code>. Notice you only insert the name, not the arguments (this is possible because there is no method overloading in Python).</p></p></p><p><h2>Inheritance</h2></p><p><p></p>Inheritance and multiple inheritance will be discussed in the next article, including some other aspects of OO in Python. We will dissect  every line of code of the httplib object and see any way we can extend it using Python inheritance. You would be suprised how simple it is. And before I forget, some discussion about tuples will also be included. Until that time, enjoy your Python.</p></p>