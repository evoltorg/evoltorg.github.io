---
layout: post
permalink: node/26852
ratings: 3
avgrate: 3.6667
category: Backend
user: ben_g
real_name: "Ben Gustafson"
user_biog: ""
user_since: 05 Nov 2001
avatar: 
article_count: 1
excerpt: "Everyone who develops a form for a website, be it a simple contact form or a more complex form for collecting order information for an e-commerce site, needs to address the issue of validating and handling the data collected from it. A server-side, object-oriented approach can lend scalabi..."
---
<p></p>Everyone who develops a form for a website, be it a simple contact form or a more complex form for collecting order information for an e-commerce site, needs to address the issue of validating and handling the data collected from it. There are opinions both <a href="http://evolt.org/article/Usable_Forms_for_an_international_audience/4090/15118/index.html#comment15252" target="_blank" title="Martin Burns's response to...">for</a> and <a href="http://evolt.org/article/Usable_Forms_for_an_international_audience/4090/15118/index.html" target="_blank" title="...Isaac Forman's &quot;Usable Forms (for an international audience)&quot; evolt article">against</a> validating form data. Let's assume, however, that you've designed your form with <a href="http://evolt.org/article/Usable_Forms_for_an_international_audience/4090/15118/index.html" target="_blank" title="Isaac's article again">international audience</a> in mind in order to cause no headaches to folks outside your country when it's validated. Let's also assume that your boss or client doesn't want a lot of the registrations from their lead-generation website being submitted empty or with &quot;asdf&quot; typed in every element of the form. Similarly, people sometimes mistakenly type their e-mail address in the line for their phone number, for example. And then there's the issue of how to collect the data from the form and process it in a methodical manner.</p></p></p><p><p></p>An object-oriented approach can lend scalability, code reusability and readability to such programming tasks. This article will describe an object-oriented methodology for form data validation and collection using ASP and JavaScript (or JScript, as the folks at Microsoft like to call their implementation in ASP). The methodology can be applied to other scripting languages that use a class or object orientation, such as VBScript, JSP or PHP.</p></p></p><p><p></p>Broadly defined, the steps followed here in processing a form are:</p></p></p><p><ol></p>	<li>Instantiate a form validation object;</li></p>	<li>Request data from the form; </li></p>	<li>Insert the data and corresponding form element names in arrays in the object; </li></p>	<li>Check the data for each element against validation rules (regular expressions or functions); </li></p>	<li>Flag invalid data in the object;</li></p>	<li>Display the form in the Web browser again with elements containing invalid data marked; </li></p>	<li>Repeat the above steps until all the data the visitor inputs is valid; </li></p>	<li>Process the validated data and redirect to the confirmation page. </li></p></ol></p><p><h2>Form design</h2></p><p><p></p>The method for marking form elements containing invalid entries requires that either the <code>&lt;P&gt;</code> tag containing the text label for the form element or the form element itself have an ID that matches the name of the form element (depending on which you want to be marked in the form). In the example below, the text label for the form element will be marked:</p></p></p><p><pre></p>&lt;p id=&quot;first_name&quot;&gt;First name &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;first_name&quot;&gt;&lt;/p&gt;</p>&lt;p id=&quot;last_name&quot;&gt;Last name &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;last_name&quot;&gt;&lt;/p&gt;</p></pre></p><p><p></p>A quirk in the Form Collection in ASP is that checkboxes and radio buttons are not included in the collection, and thus not added to the <code>Request.Form.Count</code> property, if they are not checked (or if one of the elements in a group of radio buttons or checkboxes is not checked). Thus, a group of radio buttons that does not have a button selected will be considered &quot;valid.&quot; To overcome this, include a hidden form element after each group of radio buttons and checkboxes with the same name as the group and an empty value, like so:</p></p></p><p><pre></p>&lt;p id=&quot;mood&quot;&gt;Mood&lt;/p&gt;</p>&lt;input type=&quot;radio&quot; name=&quot;mood&quot; value=&quot;good&quot;&gt; Good&lt;BR&gt;</p>&lt;input type=&quot;radio&quot; name=&quot;mood&quot; value=&quot;bad&quot;&gt; Bad&lt;BR&gt;</p>&lt;input type=&quot;radio&quot; name=&quot;mood&quot; value=&quot;indifferent&quot;&gt; Indifferent&lt;BR&gt;</p>&lt;input type=&quot;hidden&quot; name=&quot;mood&quot; value=&quot;&quot;&gt;</p></pre></p><p><p></p>A side-effect of this is that there will be an extra element containing a space in the <code>Request.Form</code> array, or a trailing comma and space after the last value if it is converted to a string. I'll show you how to trim it off the string in the function that processes valid data.</p></p></p><p><p></p>So that a visitor doesn't need to fill out the whole form again if some of the data is flagged as invalid, your server-side code should fill in the value with the data that the visitor input. For a radio button or checkbox, use:</p></p></p><p><pre></p>&lt;input type=&quot;radio&quot; name=&quot;mood&quot; value=&quot;good&quot; </p>&lt;% if (String(formData.str[&quot;mood&quot;]).indexOf(&quot;good&quot;) != -1) Response.Write(&quot; checked&quot;)%&gt;&gt;</p></pre></p><p><p>And for a text element, use:</p></p><p><pre></p>&lt;input type=&quot;text&quot; name=&quot;first_name&quot; </p>value=&quot;&lt;%=formData.str[&quot;first_name&quot;]%&gt;&quot;&gt;</p></pre></p><p><p></p>Give your Submit button a name and value so that you can use <code>Request.Form</code> to flag when the form has been submitted:</p></p></p><p><pre></p>&lt;input type=&quot;submit&quot; name=&quot;btnReg&quot; value=&quot;Register&quot;&gt;</p></pre></p><p><h2>The form validation object</h2></p><p><p></p>A form validation object consists of the following properties and methods:</p></p></p><p><ul></p>	<li>An array for storing the data;</li></p>	<li>An array for storing the name of the corresponding form element;</li></p>	<li>An array for storing a Boolean value (true or false) for the validity of the data;</li></p>	<li>A variable for indicating whether the object has any invalid entries;</li></p>	<li>A method for collecting the data;</li></p>	<li>A method for validating the data entries;</li></p>	<li>A method for flagging invalid entries;</li></p>	<li>A method for deciding whether to process the form or mark invalid entries in the browser;</li></p>	<li>A method for processing the data.</li></p></ul></p><p><p>The <code>formValidationObject</code> function creates the form validation object with the above properties and methods.</p></p><p><pre></p>function formValidationObject()</p>{</p>	this.str = new Array();</p>	this.elem = new Array();</p>	this.isValidEntry = new Array();</p>	this.hasInvalidEntry = false;</p>	this.getData = getData;</p>	this.validate = validate;</p>	this.flagInvalidEntries = flagInvalidEntries;</p>	this.processOrMarkInvalidEntries = processOrMarkInvalidEntries;</p>	this.processData = processData;</p>}</p></pre></p><p><h2>Requesting and inserting data into the form validation object</h2></p><p><p></p>Instantiate a form validation object in the form page and call its <code>getData</code> method to fill the array properties with data. You should make the form page also be the action page, to keep the form validation object alive throughout the process, and to fill in the form with the user's data if some is invalid.</p></p></p><p><pre></p>var formData = new formValidationObject();</p>if (Request.Form("btnReg") == "Register")</p>	formData.getData();</p></pre></p><p><p></p>The <code>getData</code> method creates an enumerator object to count the number of items in the Form object and loops through the object, inserting the data into the <code>str</code> array and the form element name in the <code>elem</code> array. Note that <code>str</code> is indexed by the counter, and <code>elem</code> is indexed by the name of the form element. The <code>isValidEntry</code> array property for the validity of the data is also filled here. (It is important to assume the data is valid by default.)</p></p></p><p><p></p>After the <code>while</code> loop finishes, the methods for validating the data and determining whether to process the data or mark invalid entries in the browser are called.</p></p></p><p><pre></p>function getData()</p>{</p>	var formItems = new Enumerator(Request.Form);</p>	</p>	var i = 0;</p>	while (!formItems.atEnd())</p>	{</p>		var elem = formItems.item();</p>		this.str[elem] = Request.Form(elem);</p>		this.elem[i] = elem;</p>		// assume data is valid:</p>		this.isValidEntry[i] = true;</p>		i++;</p>		formItems.moveNext();</p>	}</p>	this.validate();</p>	this.processOrMarkInvalidEntries();</p>}</p></pre></p><p><h2>Checking the data against validation rules</h2></p><p><p></p>The <code>validate</code> method loops through the <code>str</code> and <code>elem</code> arrays of the <code>formData</code> object, and checks the data against rules in regular expressions or functions within a <code>switch</code> statement. This is where it becomes important and useful that the <code>str</code> array is indexed by the name of the form element, and the <code>elem</code> array is indexed numerically. The <code>elem</code> array is used for setting the number of repetitions of the loop, and the name of the form element in <code>elem</code> at each increment of the loop is used as the index for <code>str</code> when testing <code>str</code>'s data in the <code>if</code> statements within the <code>switch</code>.</p></p></p><p><pre></p>function validate()</p>{</p>	// validation regular expression for characters</p>	//  that shouldn't appear in a person's name:</p>	var reJunkChars = /\; \[ \] \: \, \^ \? \{ \} \\ \! \@ \# \$ \% \& \* \( \) \+ \-$/;</p>	// to check if a string contains a number:</p>	var reNums = /\d/;</p>	for (var i = 0; i &lt; this.elem.length; i++)</p>	{</p>		switch (this.elem[i])</p>		{</p>			case &quot;first_name&quot;:</p>			case &quot;last_name&quot;:</p>				if (this.str[this.elem[i]] == &quot;&quot;   </p>     				 reJunkChars.test(this.str[this.elem[i]])   </p>				    reNums.test(this.str[this.elem[i]]))</p>				{</p>					this.isValidEntry[i] = false;</p>					this.hasInvalidEntry = true;</p>					break;</p>				}</p>			case &quot;mood&quot;:</p>				// convert to string and use indexOf for radio button and checkbox values, </p>				// since value will have a comma at the end of it from the hidden form field:</p>				if (this.str[this.elem[i]] == ""    this.str[this.elem[i]].indexOf(&quot;bad&quot;) != -1) // c'mon! cheer up!</p>				{</p>					this.isValidEntry[i] = false;</p>					this.hasInvalidEntry = true;</p>					break;</p>				}</p>			//' no default case, so that fields not required don't need to be filled out</p>		}</p>	}</p>}</p></pre></p><p><h2>Process or flag invalid data?</h2></p><p><p></p>Now that each piece of data in the <code>formData</code> object has been labeled as valid or invalid, we determine whether to process it or flag any invalid entries in the browser. The <code>processOrMarkInvalidEntries</code> method checks the <code>hasInvalidEntry</code> property to see if an element in the object was flagged as invalid. If not, we call the <code>processData</code> method; if so, we go back to the form by calling the <code>flagInvalidEntries</code> method.</p></p></p> </p><pre></p>function processOrMarkInvalidEntries()</p>{</p>	if (this.hasInvalidEntry)</p>		this.flagInvalidEntries();</p>	else</p>		this.processData();</p>}</p></pre></p><p><h2>Marking invalid data in the Web form</h2></p><p><p></p>If the <code>flagInvalidEntries</code> method is called, it will mark in the browser form elements containing invalid data. It does so by writing out a stylesheet that marks elements containing invalid data. Below, each element containing invalid data gets an ID selector that sets its color to red and font weight to bold. (This is where following the paragraph-ID-matching-the-form-element-name convention when designing your form comes into play.)</p></p></p><p><pre></p>function flagInvalidEntries()</p>{</p>	Response.Write(&quot;</p>&lt;P style=\&quot;color: red;\&quot;&gt;Please enter or correct data in the fields marked with bold red text.&lt;/P&gt;</p>&quot;);</p>	Response.Write(&quot;&lt;style type=\&quot;text/css\&quot;&gt;</p>&quot;);</p>	for (var i = 0; i &lt; this.elem.length; i++)</p>		if (this.isValidEntry[i] == false)</p>			Response.Write(&quot;P#&quot; + this.elem[i] + &quot;{ color: red; font-weight: bold; font-size: 14pt; }</p>&quot;);</p>	Response.Write(&quot;&lt;/style&gt;</p>&quot;);</p>}</p></pre></p><p><h2>Processing data</h2></p><p><p></p>When all the data the visitor has submitted is flagged as valid, you can now do something useful with it when the processData method is called. One way to process the data is to use a loop to write out SQL that inserts the data into a database. This assumes the database column names are the same as the form element names.</p></p></p><p><pre></p>function processData()</p>{</p>	var insertSQL = &quot;INSERT INTO registrant (&quot;;</p>	for (var i = 0; i &lt; this.elem.length; i++)</p>		if (this.elem[i] != "btnReg") // exclude the Submit button</p>			// add commas between column (form element) names</p>			insertSQL += this.elem[i] + &quot;, &quot;;</p>	// chop off the trailing comma at end of SQL string:</p>	insertSQL = insertSQL.substring(0, insertSQL.lastIndexOf(&quot;,&quot;));</p>	insertSQL += &quot;) VALUES (&quot;;</p>	</p>	for (var i = 0; i &lt; this.elem.length - 1; i++)</p>	{</p>		if (this.elem[i] != "btnReg")</p>		{</p>			var inp = String(this.str[this.elem[i]]);</p>			// get rid of trailing comma and space in radio button and checkbox data:</p>			if (inp.lastIndexOf(&quot;, &quot;) == inp.length - 2)</p>				insertSQL += &quot;'&quot; + inp.substring(0, inp.lastIndexOf(&quot;,&quot;)) + &quot;', &quot;;</p>			else</p>				insertSQL += &quot;'&quot; + inp + &quot;', &quot;;</p>		}</p>	}</p>	insertSQL = insertSQL.substring(0, insertSQL.lastIndexOf(&quot;,&quot;));</p>	insertSQL += &quot;)&quot;;</p><p>	insertData = conn.Execute(insertSQL);</p><p>	conn.Close();</p>	conn = null;</p>	insertData = null;</p>	insertSQL = null;</p>	// send the visitor to the confirmation page:</p>	Response.Redirect(&quot;thanks.htm&quot;);</p>}</p></pre></p><p><h2>Conclusion</h2></p><p><p></p>This methodology can be used for forms with one or 100 elements, by adding cases to the switch statement and rules for validating different types of data, and putting the appropriate form fill-in ASP code in your form elements. You could also have different types of data processing functions, depending on whether you wanted to insert data into a database as above, use an <a href="http://www.aspemail.com" target="_blank" title="ASPEmail will do the trick">e-mail object</a> to send it as a message, or use another processing method.</p></p>