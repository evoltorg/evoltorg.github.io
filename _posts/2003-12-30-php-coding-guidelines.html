---
layout: post
permalink: node/60247
ratings: 10
avgrate: 4.1000
categories: [Backend]
user: pwaring
real_name: "Paul Waring"
user_biog: "<p>Portfolio: <a href=\"http://www.pwaring.com/\" rel=\"nofollow\">www.pwaring.com</a></p>"
user_since: 03 Jun 2002
avatar: 
article_count: 3
excerpt: "The guidelines that I follow when writing my PHP scripts; can be helpful to have something like this if you\'re working on a joint project."
---
<h1>PHP coding guidelines</h1></p><p>The guidelines that I follow when writing my PHP scripts; can be helpful to have something like this if you're working on a joint project.</p></p><p><strong>N.B.</strong> These are only the guidelines that I personally chose to follow for the code I write. This is not an indication that any other coding styles, guidelines or standards are wrong. Feel free to use this document as a template to manage your own coding guideline and change whatever you wish as you see fit.</p></p><h2>Why are guidelines important?</h2></p><p>First of all, let's make one point crystal clear: it doesn't matter what your guidelines are, so long as everyone understands and sticks to them. I've worked on a team where the person in charge preferred to put braces following the expression, rather than on a line all by themselves. Whilst I didn't necessarily agree with this convention, I stuck to it because it made maintaining the whole project much easier.</p></p><p>It cannot be emphasised enough that guidelines are only useful if they are followed. It's no use having a definitive set of coding guidelines for a joint programming project if everyone continues to write in their own style regardless. It is arguable that you can get away with different coding styles if every team member works on a different section which is encapsulated and therefore their coding style doesn't affect the other developers. Unfortunately, this only holds true until a developer leaves and someone else has to take over their role.</p></p><p>If you are running a joint project, you might consider putting your foot down and basically refuse to accept any code that does not conform to your published guidelines, regardless of its technical merit (or lack thereof). This may sound somewhat draconian and off-putting to developers at first, but once everyone begins to code to the guidelines you'll find it a lot easier to manage the project and you'll get more work done in the same time. It will require a lot of effort from some of your developers who don't want to abandon their coding habits, but at the end of the day different coding styles will cause more problems than they're worth.</p></p><h2>Editor settings</h2></p><h3>Tabs v. spaces</h3></p><p>Ahh, the endless debate of tabs v. spaces. To be honest, I recommend using tabs all the time for the simple reasons that it is much easier to align everything using them, and tabs require less space in a file than multiple spaces. Also, if you set your editor to display a tab character as 8 spaces, but another developer prefers to have them represented as 4 spaces, it doesn't matter in the slightest.</p></p><p>A mention needs to be made of the <a href="http://pear.php.net/">PEAR</a> project, who insist on using four spaces instead of tabs in their guidelines. If you want to write code for them, just do it in tabs and then do a quick search/replace to change them all to four spaces.</p></p><h3>Linefeeds</h3></p><p>The three major operating systems &#40;Unix, Windows and Mac OS&#41; use different ways to represent the end of a line. Unix systems use the newline character &#40;<code></p></code>&#41;, Mac systems use a carriage return &#40;<code>\r</code>&#41;, and Windows systems are terribly wasteful in that they use a carriage return followed by a line feed &#40;<code>\r</p></code>&#41;.</p></p><p>I use simple newlines all the time, because the Windows way just doubles the size of your line breaks and the Mac OS way is technically incorrect in that a carriage return should only return you to the beginning of the line, ala the old typewriter systems.</p></p><p>If you develop on Windows &#40;and many people do&#41;, either set up your editor to save files in Unix format or run a utility that converts between the two file formats.</p></p><h2>Naming conventions</h2></p><h3>Variable names</h3></p><p>A lot of textbooks &#40;particulary those about Visual C++&#41; will try to drum hungarian notation into your head. Basically, this means having rules such as pre-pending g_ to global variables, i to integer data types etc. Not only is a lot of this irrelevant to PHP &#40;being a typeless language&#41;, it also produces variable names such as g_iPersonAge which, to be honest, are not easy to read at a glance and often end up looking like a group of random characters strung together without rhyme or reason.</p></p><p>Variable names should be all lowercase, with words separated by underscores. For example, <code>$current_user</code> is correct, but <code>$currentuser</code>, <code>$currentUser</code> and <code>$CurrentUser</code> are not.</p></p><p>Names should be descriptive, but also concise. Wherever possible, keep variable names to under 15 characters, although be prepared to sacrifice a few extra characters to improve clarity. There's no hard and fast rule when it comes to the length of a variable name, so just try and be as concise as possible without affecting clarity too much. Generally speaking, the smaller the scope of a variable, the more concise you should be, so global variables will usually have the longest names &#40;relative to all others&#41; whereas variables local to a loop might have names consisting only of a single character.</p></p><p>Constants should follow the same conventions as variables, except use all uppercase to distinguish them from variables. So <code>USER_ACTIVE_LEVEL</code> is correct, but <code>USERACTIVELEVEL</code> or <code>user_active_level</code> would be incorrect.</p></p><h3>Loop indices</h3></p><p>This is the only occassion where short variable names &#40;as small as one character in length&#41; are permitted, and indeed encouraged. Unless you already have a specific counting variable, use <code>$i</code> as the variable for the outermost loop, then go onto <code>$j</code> for the next most outermost loop etc. However, do <strong>not</strong> use the variable <code>$l</code> &#40;lowercase 'L'&#41; in any of your code as it looks too much like the number 'one'.</p></p><p>Example of nested loops using this convention:</p></p><?php</p>for ( $i = 0; $i < 5; $i++ )</p>{</p>	for ( $j = 0; $j < 4; $j++ )</p>	{</p>		for ( $k = 0; $k < 3; $k++ )</p>		{</p>			for ( $m = 0; $m < 2; $m++ )</p>			{</p>				foo($i, $j, $k, $m);</p>			}</p>		}</p>	}</p>}</p>?></p><p>If, for some reason, you end up nesting loops so deeply that you get to <code>$z</code>, consider re-writing your code. I've written programs &#40;in Visual Basic, for my sins&#41; with loops nested four levels deep and they were complicated enough. If you use these guidelines in a joint project, you may way to impose an additional rule that states a maximum nesting of <em>x</em> levels for loops and perhaps for other constructs too.</p></p><h3>Function names</h3></p><p>Function names should follow the same guidelines as variable names, although they should include a verb somewhere if at all possible. Examples include <code>get_user_data()</code> and <code>validate_form_data()</code>. Basically, make it as obvious as possible what the function does from its name, whilst remaining reasonably concise. For example, <code>a_function_which_gets_user_data_from_a_file()</code> would <strong>not</strong> be appropriate!</p></p><h3>Function arguments</h3></p><p>Since function arguments are just variables used in a specific context, they should follow the same guidelines as variable names.</p></p><p>It should be possible to tell the main purpose of a function just by looking at the first line, e.g. <code>get_user_data($username)</code>. By examination, you can make a good guess that this function gets the user data of a user with the username passed in the <code>$username</code> argument.</p></p><p>Function arguments should be separated by spaces, both when the function is defined and when it is called. However, there should not be any spaces between the arguments and the opening/closing brackets.</p></p><p>Some examples of correct/incorrect ways to write functions:</p></p><?php</p>get_user_data( $username, $password ); // incorrect: spaces next to brackets</p>get_user_data($username,$password); // incorrect: no spaces between arguments</p>get_user_data($a, $b); // ambiguous: what do variables $a and $b hold?</p>get_user_data($username, $password); // correct</p>?></p><h2>Code layout</h2></p><h3>Including braces</h3></p><p>Braces should <strong>always</strong> be included when writing code using <code>if</code>, <code>for</code>, <code>while</code> etc. blocks. There are <strong>no exceptions</strong> to this rule, even if the braces could be omitted. Leaving out braces makes code harder to maintain in the future and can also cause bugs that are very difficult to track down.</p></p><p>Some examples of correct/incorrect ways to write code blocks using braces:</p></p><?php</p>/* These are all incorrect */</p><p>if ( condition ) foo();</p><p>if ( condition )</p>	foo();</p><p>while ( condition )</p>	foo();</p><p>for ( $i = 0; $i < 10; $i++ )</p>	foo($i);</p><p>/* These are all correct */</p><p>if ( condition )</p>{</p>	foo();</p>}</p><p>while ( condition )</p>{</p>	foo();</p>}</p><p>for ( $i = 0; $i < 10; $i++ )</p>{</p>	foo($i);</p>}</p>?></p><h3>Where to put the braces</h3></p><p>Braces should always be placed on a line on their own; again there are no exceptions to this rule. Braces should also align properly &#40;use tabs to achieve this&#41; so a closing brace is always in the same column as the corresponding opening brace. For example:</p></p><?php</p>if ( condition )</p>{</p>	while ( condition )</p>	{</p>		foo();</p>	}</p>}</p>?></p><p>I know that a lot of programmers prefer to put the first brace on the first line of the block they are encoding, to prevent wasting a line. However, I strongly disagree with this as it makes code much easier to read &#40;in my opinion&#41; if braces line up correctly.</p></p><h3>Spaces between tokens</h3></p><p>There should always be one space on either side of a token in expressions, statements etc. The only exceptions are commas &#40;which should have one space after, but none before&#41;, semi-colons &#40;which should not have spaces on either side if they are at the end of a line, and one space after otherwise&#41;. Functions should follow the rules laid out already, i.e. no spaces between the function name and the opening bracket and no space between the brackets and the arguments, but one space between each argument.</p></p><p>Control statements such as <code>if</code>, <code>for</code>, <code>while</code> etc. should have one space on either side of the opening bracket, and one space before the closing bracket. However, individual conditions inside these brackets &#40;e.g. <code>($i < 9)    ($i > 16)</code>&#41; should <strong>not</strong> have spaces between their conditions and their opening/closing brackets.</p></p><p><p>In these examples, each pair shows the incorrect way followed by the correct way:</p></p><?php</p>$i=0;</p>$i = 0;</p><p>if(( $i<2 )  ( $i>5 ))</p>if ( ($i < 2)    ($i > 5) )</p><p>foo ( $a,$b,$c )</p>foo($a, $b, $c)</p><p>$i=($j<5)?$j:5</p>$i = ($j < 5) ? $j : 5</p>?></p><h3>Operator precedence</h3></p><p>I doubt very much that any developer knows the exact precedence of all the operators in PHP. Even if you think you know the order, don't guess because chances are you'll get it wrong and cause an unexpected bug that will be very difficult to find. Also, it will make maintaining your program a living nightmare for anyone who doesn't know the precedence tables in so much depth. <strong>Always</strong> use brackets to make it absolutely clear what you are doing.</p></p><?php</p>$i = $j < 5    $k > 6 && $m == 9    $n != 10 ? 1 : 2; // What *is* going on here?!?</p>$i = ( (($j < 5)    $k > 6)) && (($m == 9)    ($n != 10)) ) ? 1 : 2; // Much clearer</p>?></p><p><strong>N.B.</strong> If you are using expressions like the one above you should split them up into smaller chunks if possible, even if you are already laying them out in the correct format. No-one should have to debug code like that, there's too many conditions and logic operators.</p></p><h3>SQL code layout</h3></p><p>When writing SQL queries, capitialise all SQL keywords &#40;<code>SELECT</code>, <code>FROM</code>, <code>VALUES</code>, <code>AS</code> etc.&#41; and leave everything else in the relevant case. If you are using <code>WHERE</code> clauses to return data corresponding to a set of conditions, enclose those conditions in brackets in the same way you would for PHP <code>if</code> blocks, e.g. <code>SELECT * FROM users WHERE ( (registered = 'y') AND ((user_level = 'administrator') OR (user_level = 'moderator')) )</code>.</p></p><p><h2>General guidelines</h2></p><h3>Quoting strings</h3></p><p>Strings in PHP can either be quoted with single quotes &#40;<code>''</code>&#41; or double quotes &#40;<code>""</code>&#41;. The difference between the two is that the parser will use variable-interpolation in double-quoted strings, but not with single-quoted strings. So if your string contains no variables, use single quotes and save the parser the trouble of attempting to interpolate the string for variables, like so:</p></p><?php</p>$str = "Avoid this - it just makes more work for the parser."; // Double quotes</p>$str = 'This is much better.' // Single quotes</p>?></p><p>Likewise, if you are passing a variable to a function, there is no need to use double quotes:</p></p><?php</p>foo("$bar"); // No need to use double quotes</p>foo($bar); // Much better</p>?></p><p>Finally, when using associative arrays, you should include the key within single quotes to prevent any ambiguities, especially with constants:</p></p><?php</p>$foo = $bar[example]; // Wrong: what happens if 'example' is defined as a constant elsewhere?</p>$foo = $bar['example']; // Correct: no ambiguity as to the name of the key</p>?></p><p>However, if you are accessing an array with a key that is stored in a variable, you can simply use:</p></p><?php</p>$foo = $bar[$example];</p>?></p><h3>Shortcut operators</h3></p><p>The shortcut operators <code>++</code> and <code>--</code> should <strong>always</strong> be used on a line of their own, with the exception of <code>for</code> loops. Failure to do this can cause obscure bugs that are incredibly difficult to track down. For example:</p></p><?php</p>$foo[$i++] = $j; // Wrong: relies on $i being incremented after the expression is evaluated</p>$foo[--$j] = $i; // Wrong: relies on $j being decremented before the expression is evaluated</p>$foo[$i] = $j;</p>$i++; // Correct: obvious when $i is incremented</p><p>$j--;</p>$foo[$j] = $i; // Correct: obvious when $j is decremented </p>?></p><h3>Optional shortcut constructs</h3></p><p>As well as the useful increment and decrement shortcuts, there are two other ways in which you can make your PHP code easier to use. The first is to replace if statements where you are assigning one of two values to a variable based on a conditional. You may be tempted to write something like this:</p></p><?php</p>if ( isset($_POST['username']) )</p>{</p>	$username = $_POST['username'];</p>}</p>else</p>{</p>	$username = '';</p>}</p><p>if ( isset($_POST['password']) )</p>{</p>	$password = md5($_POST['password']);</p>}</p>else</p>{</p>	$password = '';</p>}</p>?></p><p>Whilst the above code works and makes it obvious what you are doing, it's not the easiest or clearest way if you want to run through a list of different variables and do a similar thing to all of them. A more compact way would be to use the ternary operator <code>? :</code> like so:</p></p><?php</p>$username = isset($_POST['username']) ? $_POST['username'] : '';</p>$password = isset($_POST['password']) ? md5($_POST['password']) : '';</p>?></p><p>I would recommend using the latter notation wherever you are checking assigning a number of variables one of two values depending on a boolean expression, simply because it makes the code easier to scan and also makes it obvious what you are doing without being unnecessarily verbose.</p></p><h3>Use constants where possible</h3></p><p>If a value is not going to change throughout the execution of your script, then use a constant rather than a variable to define it. That way, if you do change the value by accident, the PHP parser will output an error and allow you to fix the problem, without it causing any unforeseen side effects.</p></p><p>Remember that constants should never be enclosed in strings, either single or double. You must always use concatenation if you wish to include a constant's value in a string.</p></p><h3>Turn on all error reporting</h3></p><p>A lot of code I've downloaded from the web and tried to use has failed on my machines because the developers switched off the <code>E_NOTICE</code> flag in their PHP configuration for some reason or another. As soon as I bring it onto my system, where error reporting is set to <code>E_ALL</code> &#40;i.e. show all errors, including references to variables being used without being initialised&#41;, the PHP interpreter spews out dozens of error messages which I then have to fix before I can proceed to use the script.</p></p><p>What you need to remember as a developer is that the person who uses your script may not have exactly the same php.ini configuration as you so you aim for the worst possible case, i.e. when some awkard person like me has all error reporting enabled. If your code works with <code>E_ALL</code> set, then it will also work with any other error reporting configuration, including when all error reporting is turned off &#40;e.g. on sites where PHP errors are logged to a file instead&#41;.</p></p><p>It's not impossible to get scripts to work with all error reporting turned on, because I've managed it for all the code on all the sites I've ever written PHP code for. Admittedly I've not written any major projects such as a <abbr title="Content Management System">CMS</abbr>, but if you write proper object oreintated code and make sure that each class doesn't produce any errors, you should be able to make your program as a whole run without errors under normal circumstances.</p></p><p>Of course, on a production site you might want to turn off all errors, or at least redirect them to a file, to avoid admitting to users that your scripts are broken in some way &#40;we know that scripts can't handle every possible error, but users often don't see things this way!&#41;. That's perfectly fine and in many cases the recommended action to take. So long as your scripts work with all error reporting turned on, it doesn't matter where they are deployed.</p>