---
layout: post
permalink: Using_Files_to_Send_Emails_with_IIS_part_2_of_2
---
<p>(finally!)<br>\nIn the <a href="http://www.evolt.org/article/Using_files_to_send_emails_with_IIS_part_1_of_2/17/3419/index.html">first installment</a> we saw how to create emails and drop them off in the file system instead of talking directly to the email server. In this piece, we build on the code and add the ability to send text attachments.</p>\n<h2>The Evidence</h2>\n<p>First, let's see what an email file with an attachment looks like as it sits\nquietly, waiting for the SMTP server to come by and pick it up:</p>\n<pre>\nReturn-Path:&lt;sgd@thinksafely.com&gt;\nDate: Wed, Sep 27 2000 12:17 -0600\nTo: &lt;sgd@ti3.com&gt;\nFrom: &lt;sgd@thinksafely.com&gt;\nSubject: test -- attachment\nMIME-Version: 1.0\nContent-Type: multipart/mixed; boundary=&quot;XXXXMESSAGEBOUNDARYXXXX&quot;</p><p>--XXXXMESSAGEBOUNDARYXXXX\nContent-Type: text/plain; charset=&quot;US-ASCII&quot;\nContent-transfer-encoding: 7bit</p><p>this is an attachment test\n--XXXXMESSAGEBOUNDARYXXXX\n--XXXXMESSAGEBOUNDARYXXXX\nContent-Type: text/plain; name=&quot;reghelp.htm&quot;\nContent-Transfer-Encoding: quoted-printable\nContent-disposition: attachment; filename=&quot;reghelp.htm&quot;</p><p>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Simple page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;blow me&lt;/body&gt;\n&lt;/html&gt;\n--XXXXMESSAGEBOUNDARYXXXX--\n</pre>\n<h2>Reconstructing the Crime</h2>\n<p>\nThe first thing to notice is in order to make an attachment, we have to\nchange the MIME type so the email program on the receiving end knows to\nparse it out and separate the attachment from the email body. The MIME type\nis named "multipart/mixed" --a generic term that says, "Hey I've got\nmultiple pieces and each piece may have its own MIME type. Cool. But how do\nwe separate the pieces? Like so:</p>\n<pre>\n&lt;%\nConst MIMEBOUNDARY = &quot;XXXXMESSAGEBOUNDARYXXXX&quot;\nmimeheader = &quot;Content-Type: multipart/mixed; boundary=&quot;&quot;&quot; & MIMEBOUNDARY &\n&quot;&quot;&quot;&quot;\n%&gt;\n</pre>\n<p>The separator is up to you. <b>Make it lengthy, and convoluted</b>. What\nyou don't want is a separator string that may actually be found elsewhere in\nthe file. Next, we get to piece up the contents into email body and\nattachment. Looking at the format above, its pretty straightforward:\n<ol>\n<li> parts are encapsulated in "--" + separator boundaries. The last separator\nin the file has trailing "--" to signify it's the last part and the EOF is\ncoming up</li>\n<li> No line breaks between parts. Having anything --including line breaks--\nbetween parts will generate an additional attachment when the client reads\nit, and it will contain anything you put between separators (including just\nline breaks)</li>\n<li> redefine the MIME type of each part</li>\n</ol>\n<p>For the body of the email (from what I understand the body is always the\nfirst part in a multipart message), we use the MIME type from last time:</p>\n<pre>\n&lt;%\nbodyMIME = &quot;Content-Type: text/plain; charset=&quot;&quot;US-ASCII&quot;&quot;&quot; & vbNewLine\nbodyMIME = bodyMIME & &quot;Content-transfer-encoding: 7bit&quot; & vbNewLine &vbNewLine\n%&gt;\n</pre>\n<p>For the attachment, there are options. We can attach anything, from a jpeg\nfile to an Access database. Since we're limiting this to attaching text\nfiles (for demonstration), let's worry about just the minimum requirements:</p>\n<pre>\n&lt;%\nattachMIME = &quot;Content-Type: text/plain; name=&quot;&quot;reghelp.htm&quot;&quot;&quot; & vbNewLine\nattachMIME = attachMIME & &quot;Content-Transfer-Encoding: quoted-printable&quot; &vbNewLine\nattachMIME = attachMIME & &quot;Content-disposition: attachment;filename=&quot;&quot;reghelp.htm&quot;&quot;&quot;\nattachMIME = attachMIME & vbNewLine & vbNewLine\n%&gt;\n</pre>\n<p>In the first line I added the name attribute to identify the local filename\n(as it was named when the email was created). The transfer encoding is set\nto "quoted-printable" in order to pass the email from server to server to\nyour email reader without changing the data. The difference between 7-bit\nand quoted printable is that 7-bit encoding is really NO encoding, and it is\nunderstood that the content is already in emailable format (lines 76\ncharacters or less of US-ASCII data). Quoted printable is a way to keep\nthings intact. The last line is the magic one. We tell the email reader that\nthis is an attachment, and on top of that, we tell the email reader what to\nname it. The cool thing here is that the name attribute in the first line\n<b>does not have to equal the filename attribute</b>. Well, <i>I</i> found this a cool\nthing. But I send out attachments that have to have a date appended to the\nfilename =)</p></p><p><p>So after we have our MIME schtuff in order, we have to actually attach\nsomething, right? Let's slurp in a file from the file system, returning\nEmpty if it doesn't exist or encounter any errors (like the path not being\nfound):</p>\n<pre>\n&lt;%\nFunction ReadAttachment(byval filename)\nOn Error Resume Next\nDim ForAppending,fs,a,logstr\n' slurp in an attachment\nForReading = 1\nSet fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet a = fs.OpenTextFile(filename, ForReading)\n' first determine if it exists\nif a.AtEndOfStream then\n	slurped = Empty\nelse\n	slurped = a.ReadAll\nend if\na.Close\nSet a = Nothing\nSet fs = Nothing\nReadAttachment = slurped\nEnd Function%&gt;\n</pre>\n<p>\nThe caveat here is that <b>you have to know the FULL path to the file</b>,\notherwise you'll get an empty attachment. The other side of that coin is we\ndon't want the full path name in with the file name. I don't want the\nrecipient to know my directory structure. So to that end:</p>\n<pre>\n&lt;%\nFunction StripPath(ByVal strFilename)\n' grab the filename from the full path,\n'basically everything after the last \\npatharray = Split(strFilename, &quot;\&quot;)\ntmpname = patharray(UBound(patharray))\nIf InStr(tmpname, &quot;&quot;&quot;&quot;) &lt;&gt; 0 Then ' take out double quotes\n    tmpname = Replace(tmpname, &quot;&quot;&quot;&quot;, &quot;&quot;)\nEnd If\nStripPath = tmpname\nEnd Function\n%&gt;\n</pre>\n<p>Now that we know what to change, and we've got what we need to attach a\nfile, lets rip open the code from last time and add the changes. Let's make\nour boundary string a constant and tweak functions <code>GenMIMEHeaders()</code> and\n<code>GenMIMEEmail()</code>:</p>\n<pre>\n&lt;%\nConst MIMEBOUNDARY = &quot;XXXXMESSAGEBOUNDARYXXXX&quot;</p><p>'********* GenMIMEHeaders ************\nfunction GenMIMEHeaders(byval replyto, byval from, byval mto, byval subject)\nreplyto = &quot;&lt;&quot;& replyto &&quot;&gt;&quot;\nfrom = &quot;&lt;&quot;& from &&quot;&gt;&quot;\nsendto = split(mto,&quot;,&quot;)\nfor each addr in sendto\n	tolist = &quot;&lt;&quot;& addr &&quot;&gt;,&quot; & tolist\nNext\ntolist = Left(tolist,len(tolist)-1) ' take off the last comma\nheaders = &quot;Return-Path:&quot;&replyto & vbNewLine\nheaders = headers & &quot;Date: &quot; & GenMIMEDate(Now,&quot;-0600&quot;) & vbNewLine\nheaders = headers & &quot;To:&quot;& tolist & vbNewLine\nheaders = headers & &quot;From:&quot;& from & vbNewLine\nheaders = headers & &quot;Subject: &quot;& subject & vbNewLine\nheaders = headers & &quot;MIME-Version: 1.0&quot; & vbNewLine\nheaders = headers & &quot;Content-Type: multipart/mixed;\nboundary=&quot;&quot;&quot;&MIMEBOUNDARY&&quot;&quot;&quot;&quot;\nGenMIMEHeaders = headers & vbNewLine & vbNewLine\nend function</p><p>'********* GenMIMEEmail ************\nfunction GenMIMEEmail(byval from, byval mto, byval subject, byval body,byval fileattach)\nbodyMIME = &quot;Content-Type: text/plain; charset=&quot;&quot;US-ASCII&quot;&quot;&quot; & vbNewLine\nbodyMIME = bodyMIME & &quot;Content-transfer-encoding: 7bit&quot; & vbNewLine & vbNewLine\nfullmail = GenMIMEHeaders(from,from,mto,subject) & &quot;--&quot; & MIMEBOUNDARY & vbNewLine</p><p>' --add the body--\nfullmail = fullmail & bodyMIME & body & vbNewLine\nfullmail = fullmail & &quot;--&quot; & MIMEBOUNDARY</p><p>' Do we need to attach a file?\nif isEmpty(fileattach) or fileattach=&quot;&quot; then ' Nope, no file, close the\nseparator\n	GenMIMEEMail = fullmail & &quot;--&quot; & vbNewLine\nelse\n' there's an attachment\n	attach = StripPath(fileattach)\n	attachMIME = &quot;Content-Type: text/plain; name=&quot;&quot;&quot;& attach &&quot;&quot;&quot;&quot; & vbNewLine\n	attachMIME = attachMIME & &quot;Content-Transfer-Encoding: quoted-printable&quot; & vbNewLine\n	attachMIME = attachMIME & &quot;Content-disposition: attachment; filename=&quot;&quot;&quot;&attach&&quot;&quot;&quot;&quot;\n	attachMIME = attachMIME & vbNewLine & vbNewLine</p><p>	fullmail = fullmail & vbNewLine & &quot;--&quot; & MIMEBOUNDARY & vbNewLine & attachMIME\n	fullmail = fullmail & ReadAttachment(fileattach) & vbNewLine\n	GenMIMEEMail = fullmail & &quot;--&quot; & MIMEBOUNDARY & &quot;--&quot; & vbNewLine\nend if\nend function\n%&gt;\n</pre>\n<p>So the finished function calls to get the job done look like this:</p>\n<pre>\n&lt;%\n' in VB and VBScript, we can use the _ to extend to the next line\nemail = GenMIMEEmail(&quot;sgd@ti3.com&quot;, _\n			&quot;sgd@fastlane.net&quot;, _\n			&quot;New Log&quot;, _\n			&quot;Here is your log&quot;, _\n			&quot;D:\logfiles\newestlog.txt&quot;)</p><p>' without an attachment:\nemail = GenMIMEEmail(&quot;sgd@ti3.com&quot;, _\n			&quot;sgd@fastlane.net&quot;, _\n			&quot;New Log&quot;, _\n			&quot;Here is your log&quot;, _\n			&quot;&quot;)  ' Note we've allowed Empty and &quot;&quot; to signify no file to attach</p><p>writeEmail email,GenMIMEName\n%&gt;\n</pre>\n<p>To note, the reason I use constructs like</p>\n<pre>\n&lt;%\nheaders = headers & &quot;To:&quot;& tolist & vbNewLine\nheaders = headers & &quot;From:&quot;& from & vbNewLine\nheaders = headers & &quot;Subject: &quot;& subject & vbNewLine\n%&gt;</pre>\n<p>\n is for readability\n(sorta)&#151; it allows me to explain a portion of logic without having to look\nfor code hidden inside a long line. In production, you do want to reduce the\nredundancy as much as you can, and place that stuff on one line. Or keep\nthem separated out, whichever you prefer. It is a minor performance hit to\nspread it out like this, but we're not concentrating on that today =)\n</p>\n<p>So that's that. We're sending emails, and even attachments if we're feeling\nsaucy.\n</p></p><p><p>\n-------<br>\nSidebar<br>\nYou've read about n-tier applications and separating "business logic" so it\ncan be re-used, right? This little project here *screams* to be done in a\nCOM object, where it is 1) compiled, and runs faster and 2) an object\navailable for use across your system, even for non web apps. Keep that in\nmind as you write lengthy functions and 'classes' in your ASP files.<br>\n-------<br>\n</P>