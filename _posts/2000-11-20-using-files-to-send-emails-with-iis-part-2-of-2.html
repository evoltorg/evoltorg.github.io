---
layout: post
permalink: Using_Files_to_Send_Emails_with_IIS_part_2_of_2
ratings: 6
avgrate: 4.3333
category: Code
user: sgd
real_name: "Scott Dexter"
user_biog: ""
user_since: 26 Apr 1999
avatar: "/images/pictures/picture-35.gif"
article_count: 10
excerpt: "(finally!)</p>In the first installment we saw how to create emails and drop them off in the file system instead of talking directly to the email server. In this piece, we build on the code and add the a"
---
<p>(finally!)<br></p>In the <a href="http://www.evolt.org/article/Using_files_to_send_emails_with_IIS_part_1_of_2/17/3419/index.html">first installment</a> we saw how to create emails and drop them off in the file system instead of talking directly to the email server. In this piece, we build on the code and add the ability to send text attachments.</p></p><h2>The Evidence</h2></p><p>First, let's see what an email file with an attachment looks like as it sits</p>quietly, waiting for the SMTP server to come by and pick it up:</p></p><pre></p>Return-Path:&lt;sgd@thinksafely.com&gt;</p>Date: Wed, Sep 27 2000 12:17 -0600</p>To: &lt;sgd@ti3.com&gt;</p>From: &lt;sgd@thinksafely.com&gt;</p>Subject: test -- attachment</p>MIME-Version: 1.0</p>Content-Type: multipart/mixed; boundary=&quot;XXXXMESSAGEBOUNDARYXXXX&quot;</p><p>--XXXXMESSAGEBOUNDARYXXXX</p>Content-Type: text/plain; charset=&quot;US-ASCII&quot;</p>Content-transfer-encoding: 7bit</p><p>this is an attachment test</p>--XXXXMESSAGEBOUNDARYXXXX</p>--XXXXMESSAGEBOUNDARYXXXX</p>Content-Type: text/plain; name=&quot;reghelp.htm&quot;</p>Content-Transfer-Encoding: quoted-printable</p>Content-disposition: attachment; filename=&quot;reghelp.htm&quot;</p><p>&lt;html&gt;</p>&lt;head&gt;</p>&lt;title&gt;Simple page&lt;/title&gt;</p>&lt;/head&gt;</p>&lt;body&gt;blow me&lt;/body&gt;</p>&lt;/html&gt;</p>--XXXXMESSAGEBOUNDARYXXXX--</p></pre></p><h2>Reconstructing the Crime</h2></p><p></p>The first thing to notice is in order to make an attachment, we have to</p>change the MIME type so the email program on the receiving end knows to</p>parse it out and separate the attachment from the email body. The MIME type</p>is named "multipart/mixed" --a generic term that says, "Hey I've got</p>multiple pieces and each piece may have its own MIME type. Cool. But how do</p>we separate the pieces? Like so:</p></p><pre></p>&lt;%</p>Const MIMEBOUNDARY = &quot;XXXXMESSAGEBOUNDARYXXXX&quot;</p>mimeheader = &quot;Content-Type: multipart/mixed; boundary=&quot;&quot;&quot; & MIMEBOUNDARY &</p>&quot;&quot;&quot;&quot;</p>%&gt;</p></pre></p><p>The separator is up to you. <b>Make it lengthy, and convoluted</b>. What</p>you don't want is a separator string that may actually be found elsewhere in</p>the file. Next, we get to piece up the contents into email body and</p>attachment. Looking at the format above, its pretty straightforward:</p><ol></p><li> parts are encapsulated in "--" + separator boundaries. The last separator</p>in the file has trailing "--" to signify it's the last part and the EOF is</p>coming up</li></p><li> No line breaks between parts. Having anything --including line breaks--</p>between parts will generate an additional attachment when the client reads</p>it, and it will contain anything you put between separators (including just</p>line breaks)</li></p><li> redefine the MIME type of each part</li></p></ol></p><p>For the body of the email (from what I understand the body is always the</p>first part in a multipart message), we use the MIME type from last time:</p></p><pre></p>&lt;%</p>bodyMIME = &quot;Content-Type: text/plain; charset=&quot;&quot;US-ASCII&quot;&quot;&quot; & vbNewLine</p>bodyMIME = bodyMIME & &quot;Content-transfer-encoding: 7bit&quot; & vbNewLine &vbNewLine</p>%&gt;</p></pre></p><p>For the attachment, there are options. We can attach anything, from a jpeg</p>file to an Access database. Since we're limiting this to attaching text</p>files (for demonstration), let's worry about just the minimum requirements:</p></p><pre></p>&lt;%</p>attachMIME = &quot;Content-Type: text/plain; name=&quot;&quot;reghelp.htm&quot;&quot;&quot; & vbNewLine</p>attachMIME = attachMIME & &quot;Content-Transfer-Encoding: quoted-printable&quot; &vbNewLine</p>attachMIME = attachMIME & &quot;Content-disposition: attachment;filename=&quot;&quot;reghelp.htm&quot;&quot;&quot;</p>attachMIME = attachMIME & vbNewLine & vbNewLine</p>%&gt;</p></pre></p><p>In the first line I added the name attribute to identify the local filename</p>(as it was named when the email was created). The transfer encoding is set</p>to "quoted-printable" in order to pass the email from server to server to</p>your email reader without changing the data. The difference between 7-bit</p>and quoted printable is that 7-bit encoding is really NO encoding, and it is</p>understood that the content is already in emailable format (lines 76</p>characters or less of US-ASCII data). Quoted printable is a way to keep</p>things intact. The last line is the magic one. We tell the email reader that</p>this is an attachment, and on top of that, we tell the email reader what to</p>name it. The cool thing here is that the name attribute in the first line</p><b>does not have to equal the filename attribute</b>. Well, <i>I</i> found this a cool</p>thing. But I send out attachments that have to have a date appended to the</p>filename =)</p></p><p><p>So after we have our MIME schtuff in order, we have to actually attach</p>something, right? Let's slurp in a file from the file system, returning</p>Empty if it doesn't exist or encounter any errors (like the path not being</p>found):</p></p><pre></p>&lt;%</p>Function ReadAttachment(byval filename)</p>On Error Resume Next</p>Dim ForAppending,fs,a,logstr</p>' slurp in an attachment</p>ForReading = 1</p>Set fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)</p>Set a = fs.OpenTextFile(filename, ForReading)</p>' first determine if it exists</p>if a.AtEndOfStream then</p>	slurped = Empty</p>else</p>	slurped = a.ReadAll</p>end if</p>a.Close</p>Set a = Nothing</p>Set fs = Nothing</p>ReadAttachment = slurped</p>End Function%&gt;</p></pre></p><p></p>The caveat here is that <b>you have to know the FULL path to the file</b>,</p>otherwise you'll get an empty attachment. The other side of that coin is we</p>don't want the full path name in with the file name. I don't want the</p>recipient to know my directory structure. So to that end:</p></p><pre></p>&lt;%</p>Function StripPath(ByVal strFilename)</p>' grab the filename from the full path,</p>'basically everything after the last \</p>patharray = Split(strFilename, &quot;\&quot;)</p>tmpname = patharray(UBound(patharray))</p>If InStr(tmpname, &quot;&quot;&quot;&quot;) &lt;&gt; 0 Then ' take out double quotes</p>    tmpname = Replace(tmpname, &quot;&quot;&quot;&quot;, &quot;&quot;)</p>End If</p>StripPath = tmpname</p>End Function</p>%&gt;</p></pre></p><p>Now that we know what to change, and we've got what we need to attach a</p>file, lets rip open the code from last time and add the changes. Let's make</p>our boundary string a constant and tweak functions <code>GenMIMEHeaders()</code> and</p><code>GenMIMEEmail()</code>:</p></p><pre></p>&lt;%</p>Const MIMEBOUNDARY = &quot;XXXXMESSAGEBOUNDARYXXXX&quot;</p><p>'********* GenMIMEHeaders ************</p>function GenMIMEHeaders(byval replyto, byval from, byval mto, byval subject)</p>replyto = &quot;&lt;&quot;& replyto &&quot;&gt;&quot;</p>from = &quot;&lt;&quot;& from &&quot;&gt;&quot;</p>sendto = split(mto,&quot;,&quot;)</p>for each addr in sendto</p>	tolist = &quot;&lt;&quot;& addr &&quot;&gt;,&quot; & tolist</p>Next</p>tolist = Left(tolist,len(tolist)-1) ' take off the last comma</p>headers = &quot;Return-Path:&quot;&replyto & vbNewLine</p>headers = headers & &quot;Date: &quot; & GenMIMEDate(Now,&quot;-0600&quot;) & vbNewLine</p>headers = headers & &quot;To:&quot;& tolist & vbNewLine</p>headers = headers & &quot;From:&quot;& from & vbNewLine</p>headers = headers & &quot;Subject: &quot;& subject & vbNewLine</p>headers = headers & &quot;MIME-Version: 1.0&quot; & vbNewLine</p>headers = headers & &quot;Content-Type: multipart/mixed;</p>boundary=&quot;&quot;&quot;&MIMEBOUNDARY&&quot;&quot;&quot;&quot;</p>GenMIMEHeaders = headers & vbNewLine & vbNewLine</p>end function</p><p>'********* GenMIMEEmail ************</p>function GenMIMEEmail(byval from, byval mto, byval subject, byval body,byval fileattach)</p>bodyMIME = &quot;Content-Type: text/plain; charset=&quot;&quot;US-ASCII&quot;&quot;&quot; & vbNewLine</p>bodyMIME = bodyMIME & &quot;Content-transfer-encoding: 7bit&quot; & vbNewLine & vbNewLine</p>fullmail = GenMIMEHeaders(from,from,mto,subject) & &quot;--&quot; & MIMEBOUNDARY & vbNewLine</p><p>' --add the body--</p>fullmail = fullmail & bodyMIME & body & vbNewLine</p>fullmail = fullmail & &quot;--&quot; & MIMEBOUNDARY</p><p>' Do we need to attach a file?</p>if isEmpty(fileattach) or fileattach=&quot;&quot; then ' Nope, no file, close the</p>separator</p>	GenMIMEEMail = fullmail & &quot;--&quot; & vbNewLine</p>else</p>' there's an attachment</p>	attach = StripPath(fileattach)</p>	attachMIME = &quot;Content-Type: text/plain; name=&quot;&quot;&quot;& attach &&quot;&quot;&quot;&quot; & vbNewLine</p>	attachMIME = attachMIME & &quot;Content-Transfer-Encoding: quoted-printable&quot; & vbNewLine</p>	attachMIME = attachMIME & &quot;Content-disposition: attachment; filename=&quot;&quot;&quot;&attach&&quot;&quot;&quot;&quot;</p>	attachMIME = attachMIME & vbNewLine & vbNewLine</p><p>	fullmail = fullmail & vbNewLine & &quot;--&quot; & MIMEBOUNDARY & vbNewLine & attachMIME</p>	fullmail = fullmail & ReadAttachment(fileattach) & vbNewLine</p>	GenMIMEEMail = fullmail & &quot;--&quot; & MIMEBOUNDARY & &quot;--&quot; & vbNewLine</p>end if</p>end function</p>%&gt;</p></pre></p><p>So the finished function calls to get the job done look like this:</p></p><pre></p>&lt;%</p>' in VB and VBScript, we can use the _ to extend to the next line</p>email = GenMIMEEmail(&quot;sgd@ti3.com&quot;, _</p>			&quot;sgd@fastlane.net&quot;, _</p>			&quot;New Log&quot;, _</p>			&quot;Here is your log&quot;, _</p>			&quot;D:\logfiles</p>ewestlog.txt&quot;)</p><p>' without an attachment:</p>email = GenMIMEEmail(&quot;sgd@ti3.com&quot;, _</p>			&quot;sgd@fastlane.net&quot;, _</p>			&quot;New Log&quot;, _</p>			&quot;Here is your log&quot;, _</p>			&quot;&quot;)  ' Note we've allowed Empty and &quot;&quot; to signify no file to attach</p><p>writeEmail email,GenMIMEName</p>%&gt;</p></pre></p><p>To note, the reason I use constructs like</p></p><pre></p>&lt;%</p>headers = headers & &quot;To:&quot;& tolist & vbNewLine</p>headers = headers & &quot;From:&quot;& from & vbNewLine</p>headers = headers & &quot;Subject: &quot;& subject & vbNewLine</p>%&gt;</pre></p><p></p> is for readability</p>(sorta)&#151; it allows me to explain a portion of logic without having to look</p>for code hidden inside a long line. In production, you do want to reduce the</p>redundancy as much as you can, and place that stuff on one line. Or keep</p>them separated out, whichever you prefer. It is a minor performance hit to</p>spread it out like this, but we're not concentrating on that today =)</p></p></p><p>So that's that. We're sending emails, and even attachments if we're feeling</p>saucy.</p></p></p><p><p></p>-------<br></p>Sidebar<br></p>You've read about n-tier applications and separating "business logic" so it</p>can be re-used, right? This little project here *screams* to be done in a</p>COM object, where it is 1) compiled, and runs faster and 2) an object</p>available for use across your system, even for non web apps. Keep that in</p>mind as you write lengthy functions and 'classes' in your ASP files.<br></p>-------<br></p></P>