---
layout: post
permalink: node/55650
ratings: 4
avgrate: 4.2500
rating: 4.05
categories: [Code]
user: gvtulder
real_name: "Gijs van Tulder"
user_biog: "<p>
<a href=\"http://vantulder.net/\" rel=\"nofollow\">Gijs van Tulder</a> is a Dutch student. He likes to play with all things web related and fancies himself as a part-time amateur web developer.
</p>"
user_since: 05 Feb 2002
avatar: /images/pictures/picture-20899.jpg
article_count: 7
excerpt: "In this article, we will write a script to connect ImageMagick to PHP. You can</p>then generate thumbnails and other versions of your images on-the-fly, by just</p>editing the url."
---
<h2>What is ImageMagick?</h2></p><p></p><a href="http://www.imagemagick.com/" target="_new"</p>title="Download ImageMagick (Link opens in a new window)">ImageMagick</a> is</p>a powerful set of image manipulation utilities. It can read, write and</p>manipulate images in many image formats. It can resize, rotate, sharpen,</p>color reduce or add any other special effect to your images. And, best of all,</p>ImageMagick is directly available from the command line. In this article, we will</p>write a script to make it available from the query string. You can then use</p>it, for example, to automatically generate thumbnails of your images.</p></p></p><p><h2>What our script will do</h2></p><p></p>We will write a script that we can copy-paste in a directory with images and</p>that enables us to use ImageMagick's <a</p>href="http://www.imagemagick.com/www/convert.html" target="_new"</p>title="Read more about convert (Link opens in a new window)">convert</a></p>utility on each of the images in that directory. The script will enable us to</p>give <code>convert</code> commands by changing the query string.</p></p></p><p></p>Maybe a simple example will better explain this idea. You've got an image:</p><code>http://wwww.example.com/img/image.jpg</code>. You copy the</p>ImageMagick script <code>magick.php</code> to the same directory. The image is</p>now also available as</p><code>http://www.example.com/img/magick.php/image.jpg</code>. So far,</p>your image hasn't changed. Now, imagine you want a thumbnail of the image</p>with a width of exactly 200 pixels. You can get that image by requesting the</p>url:</p><code>http://www.example.com/img/magick.php/image.jpg?resize(200)</code>. </p></p></p><p></p>On receiving a request, the script will:</p></p></p><ol></p> <li>Parse the query string;</li></p> <li>Convert the query string to an ImageMagick command string;</li></p> <li>Run ImageMagick on the image;</li></p> <li>Send the modified image to the browser.</li></p></ol></p><p></p>As you see, the script will run ImageMagick for every request. This isn't</p>very efficient. As you will probably use just a few commands (e.g.</p>thumbnail and original image) in your html files, caching the output will</p>speed up the system. We will add a point 5 to the list. The output of</p>ImageMagick should be cached. The script should send the cached image if it</p>exists, so ImageMagick won't be generating the same image over and over</p>again. </p></p></p><p></p><h2>Commands</h2></p><p></p>You can use the <a</p>href="http://www.imagemagick.com/www/ImageMagick.html#opti" target="_new"</p>title="A list of all ImageMagick commands (Link opens in a new window"></p>standard commands/options</a> of ImageMagick's convert utility. The</p>command is followed by the command's parameters. These parameters are</p>enclosed in brackets. Multiple commands are separated by a plus sign.  </p></p></p><p></p>ImageMagick uses &lt; and &gt; in some parameters. You can't use these in</p>html-documents. Instead of &lt; and &gt;, you may use { and } in your query</p>string. The scripts then converts { to &lt; and } to &gt;. </p></p></p><p></p>Here are a few example convert commands and their query equivalent.</p></p></p><table cellspacing="0" class="data"></p> <tr></p>  <th>Command line</th></p>  <th>Query string</th></p> </tr></p> <tr></p>  <td><code>-resize &quot;100x150&quot;</code></td></p>  <td><code>?resize(100x150)</code></td></p> </tr></p> <tr></p>  <td><code>-resize &quot;800x600&gt;&quot; -roll &quot;90&quot;</code></td> </p>  <td><code>?resize(800x600})+roll(90)</code></td></p> </tr></p> <tr></p>  <td><code>-flip -resize &quot;800x600&gt;&quot; -flop</code></td> </p>  <td><code>?flip+resize(800x600})+flop</code></td></p> </tr></p></table></p><p><h2>Extra commands</h2></p><p></p>The long list of ImageMagick commands didn't contain some things I wanted to</p>do. I added three 'extra' commands to the script to do this.</p></p></p><p><h3>part</h3></p><p></p>The first of these commands is</p><strong><code>part(<i>width</i>x<i>height</i>)</code></strong>. With</p>ImageMagick's <code>crop</code> command, it is possible to get a part of the</p>image. Unfortunately, this command only accepts absolute parameters. It can</p>crop <i>w</i> by <i>h</i> pixels, starting <i>x</i> pixels from the left and</p><i>y</i> pixels from the top of the image. But what if I want to get 100x100</p>pixels from the center of the image? That's impossible if I don't know the</p>size of the image.</p></p></p><p></p>Enter the <code>part</code> command. It resizes the image to match either</p>the preferred width or the preferred height. Then it crops the image to get</p>the center part of that resized image. And that's what I wanted to do.</p></p></p><p><h3>colorizehex</h3></p><p></p>ImageMagick's <code>colorize</code> command accepts only decimal RGB</p>numbers, on a 0 to 100 scale. To colorize with red gives <code>colorize</p>100/0/0</code>. This isn't ideal for web use, since html uses hex codes to</p>identify colors. The <strong><code>colorizehex(<i>hex</i>)</code></strong></p>command does accept hex colors. It converts them to the ImageMagick</p>notation. Example: a red colorize is done with</p><code>colorizehex(FF0000)</code>.</p></p></p><p><h3>type</h3></p><p></p>The <strong><code>type(<i>type</i>)</code></strong> is available in</p>ImageMagick. It's just not a part of the commands, but is appended to the</p>name of the output file (e.g. <code>jpg:output.jpg</code>). I wanted to</p>include it in the query string, so I made it a command. You can now convert</p>the image to jpeg by using <code>type(jpg)</code> in your query. </p></p> </p><p><h2>Before we start</h2></p><p></p>There are just two minor points left before we can start coding.</p></p></p><p><h3>Do you have ImageMagick?</h3></p><p></p>ImageMagick should be installed on your system before you can use it in your</p>scripts. This means you will either have to <a</p>href="http://www.imagemagick.com/" target="_new"</p>title="Download ImageMagick (Link opens in a new window)">install</a></p>it yourself, or have your server admin do it for you.</p></p></p><p></p>If your server is running PHP in <a</p>href="http://www.php.net/manual/en/features.safe-mode.php" target="_new"</p>title="Read more about safe mode (Links opens in a new window)">safe</p>mode</a>, which it is likely to be if you're using a (free) shared host,</p>your scripts don't have the right to execute shell commands. As this script</p>runs ImageMagick as a shell command, you won't be able to use it. You could</p>a. ask your hosting provider to disable safe mode or b. use the <a</p>href="http://www.evolt.org/article/Automated_Creation_of_Thumbnails_With_PHP/20/24498/index.html"</p>title="Automated Creation of Thumbnails With PHP">GD library</a> to generate</p>your images. ImageMagick is far more powerful than the GD library, but you</p>can use the latter even in safe mode.</p></p></p><p><h3>Why write your own script?</h3></p><p></p>Directly running convert isn't the only way to use ImageMagick in your scripts.</p>The <a href="http://pear.php.net/package-info.php?pacid=76" target="_new"</p>title="Imagick, part of PEAR (Link opens in a new window)">Imagick</a></p>module from the PEAR library,</p><a href="http://www.imagemagick.com/www/perl.html" target="_new"</p>title="PerlMagick, for Perl (Link opens in a new window)">PerlMagick</a>,</p>a Perl interface to ImageMagick, can do this too. Then why bother and write</p>your own script? Because it gives you a far more flexible system. You just</p>enter your commands as the query string, and the script just sends them to</p>ImageMagick. The PEAR module, for instance, has a special PHP function for</p>each ImageMagick command. The script would have to translate the commands to</p>the corresponding functions, for which it would need an array with all</p>possible commands and functions. The direct method, withouth PEAR module, is</p>therefore faster to write. </p></p></p><p><h2>The script</h2></p><p></p>And, finally, here's the script that makes it all possible. If you copy all</p>parts, you'll end up with one script. Place it in your image directory, and</p>it's ready for use.</p></p></p><p><h3>Configuration</h3></p><p></p>You can specify where your images are and where you want the script to cache</p>the processed images. It defaults to the current directory, which is probably</p>where you want it. If the <code>convert</code> utility isn't available in the</p>PATH environment variable of your web server, you'll need to specify the full</p>path.</p></p></p><pre></p>&lt;?php</p>//  location of source images (no trailing /)</p>$image_path = '.';</p><p>//  location of cached images (no trailing /)</p>$cache_path = '.';</p><p>//  location of imagemagick's convert utility</p>$convert_path = 'convert';</p></pre></p><p><h3>Check input</h3></p><p></p>The path and file name of the requested image is available as</p><code>$_SERVER['PATH_INFO']</code>. We need to check that such information is</p>given, and that the file exists.</p></p></p><pre></p>// first, check if an image location is given</p>if (!isset($_SERVER['PATH_INFO'])) {</p>    die('ERROR: No image specified.');</p>}</p>$image = $image_path.$_SERVER['PATH_INFO'];</p><p>// next, check if the file exists</p>if (!file_exists($image)) {</p>    die('ERROR: That image does not exist.');</p>}</p></pre></p><p><h3>Parse commands</h3></p><p></p>We need a regular expression to parse the query string and extract commands</p>and parameters.</p></p></p><pre></p>// extract the commands from the query string</p>// eg.: ?resize(....)+flip+blur(...)</p>preg_match_all('/\+*(([a-z]+)(\(([^\)]*)\))?)\+*/',</p>               $_SERVER['QUERY_STRING'],</p>               $matches, PREG_SET_ORDER);</p></pre></p><p></p>We now have an array <code>$matches</code>. Each element in that array is</p>another array, with in the third element (position 2) the command name and</p>on position 4 the parameters.</p></p></p><p></p>The cache file name will contain the name of the original file. We then add</p>the commands and parameters to it, so we get an unique name for each version</p>of the image.</p></p></p><pre></p>// concatenate commands for use in cache file name</p>$cache = $_SERVER['PATH_INFO'];</p>foreach ($matches as $match) {</p>    $cache .= '%'.$match[2].':'.$match[4];</p>}</p>$cache = str_replace('/','_',$cache);</p>$cache = $cache_path.'/'.$cache;</p>$cache = escapeshellcmd($cache);</p></pre></p><p><h3>Run convert</h3></p><p></p>Now that we have the cache file name, we can look if we already have a cached</p>version of the requested image. If we do, we can just send that to the</p>browser. If we don't, we will ask <code>convert</code> to create it.</p></p></p><p></p>We will add each command to the string <code>$commands</code>. We will send</p>that string to <code>convert</code> to generate the image.</p></p></p><pre></p>if (!file_exists($cache)) {</p>    // there is no cached image yet, so we'll need to create it first</p><p>    // convert query string to an imagemagick command string</p>    $commands = '';</p>    foreach ($matches as $match) {</p>        // $match[2] is the command name</p>        // $match[4] the parameter</p>    </p>        // check input</p>        if (!preg_match('/^[a-z]+$/',$match[2])) {</p>            die('ERROR: Invalid command.');</p>        }</p>        if (!preg_match('/^[a-z0-9\/{}+-<>!@%]+$/',$match[4])) {</p>            die('ERROR: Invalid parameter.');</p>        }</p>    </p>        // replace } with &gt;, { with &lt;</p>        // > and < could give problems when using html</p>        $match[4] = str_replace('}','&gt;',$match[4]);</p>        $match[4] = str_replace('{','&lt;',$match[4]);</p></pre></p><p></p>After we've checked the input and converted { to &lt; and } to &gt;, we will</p>add this command to the <code>$convert</code> string. But, since we used our</p>own, special commands, we will have to check if this command is one of them.</p>If it is, we will have to do a bit more work.</p></p></p><p></p>The <code>colorizehex</code> is quite simple. We will convert hex to decimal,</p>and then convert the 0-255 scale to ImageMagick's 0-100.</p></p></p><pre></p>        // check for special, scripted commands</p>        switch ($match[2]) {</p>            case 'colorizehex':</p>                // imagemagick's colorize, but with hex-rgb colors</p>                // convert to decimal rgb</p>                $r = round((255 - hexdec(substr($match[4], 0, 2))) / 2.55);</p>                $g = round((255 - hexdec(substr($match[4], 2, 2))) / 2.55);</p>                $b = round((255 - hexdec(substr($match[4], 4, 2))) / 2.55);</p>    </p>                // add command to list</p>                $commands .= ' -colorize &quot;'.&quot;$r/$g/$b&quot;.'&quot;';</p>                break;</p></pre></p><p><p></p>The <code>part</code> command requires more work. We first get the size of the</p>source image using the <code>getimagesize()</code> function. After that we</p>let ImageMagick resize the image to match either the new width or the new</p>height. We want one of the image's dimensions to be equal to the new size, and</p>the other one to exceed that size. We can then crop the image to the requested</p>size.</p></p></p><pre></p>            case 'part':</p>                // crops the image to the requested size</p>                if (!preg_match('/^[0-9]+x[0-9]+$/',$match[4])) {</p>                    die('ERROR: Invalid parameter.');</p>                }</p><p>                list($width, $height) = explode('x', $match[4]);</p>    </p>                // get size of the original</p>                $imginfo = getimagesize($image);</p>                $orig_w = $imginfo[0];</p>                $orig_h = $imginfo[1];</p>    </p>                // resize image to match either the new width</p>                // or the new height</p>    </p>                // if original width / original height is greater</p>                // than new width / new height</p>                if ($orig_w/$orig_h &gt; $width/$height) {</p>                    // then resize to the new height...</p>                    $commands .= ' -resize &quot;x'.$height.'&quot;';</p>    </p>                    // ... and get the middle part of the new image</p>                    // what is the resized width?</p>                    $resized_w = ($height/$orig_h) * $orig_w;</p>    </p>                    // crop</p>                    $commands .= ' -crop &quot;'.$width.'x'.$height.</p>                                 '+'.round(($resized_w - $width)/2).'+0&quot;';</p>                } else {</p>                    // or else resize to the new width</p>                    $commands .= ' -resize &quot;'.$width.'&quot;';</p>    </p>                    // ... and get the middle part of the new image</p>                    // what is the resized height?</p>                    $resized_h = ($width/$orig_w) * $orig_h;</p>    </p>                    // crop</p>                    $commands .= ' -crop &quot;'.$width.'x'.$height.</p>                                 '+0+'.round(($resized_h - $height)/2).'&quot;';</p>                }</p>                break;</p></pre></p><p><p></p>The <code>type</code> command is really simple. We can just save the type name</p>for now.</p></p></p><pre></p>            case 'type':</p>                // convert the image to this file type</p>                if (!preg_match('/^[a-z]+$/',$match[4])) {</p>                    die('ERROR: Invalid parameter.');</p>                }</p>                $new_type = $match[4];</p>                break;</p></pre></p><p><p></p>If this command isn't special, we can simply add the command and parameters to</p>the command string.</p></p></p><pre></p>            default:</p>                // nothing special, just add the command</p>                if ($match[4]=='') {</p>                    // no parameter given, eg: flip</p>                    $commands .= ' -'.$match[2].'';</p>                } else {</p>                    $commands .= ' -'.$match[2].' "'.$match[4].'"';</p>                }</p>        }</p>    }</p></pre></p><p><p></p>After we've run through the array we've got a list of commands in</p><code>$commands</code>. We can now run <code>convert</code>.</p><code>convert</code> needs the commands, the location of the source image and</p>the location of the output image to work. If a new file type is specified, we</p>add that type and a colon to the output file name.</p></p></p><pre></p>    // create the convert-command</p>    $convert = $convert_path.' '.$commands.' "'.$image.'" ';</p>    if (isset($new_type)) {</p>        // send file type-command to imagemagick</p>        $convert .= $new_type.':';</p>    }</p>    $convert .= '"'.$cache.'"';</p><p>    // execute imagemagick's convert, save output as $cache</p>    exec($convert);</p>}</p></pre></p><p><h3>Output</h3></p><p></p>The <code>$cache</code> variable should now point to the file containing the</p>requested image. It was already cached or it was generated by</p><code>convert</code>. If the file exists, we can retrieve some information</p>about that image to put in the http headers.</p></p></p><pre></p>// there should be a file named $cache now</p>if (!file_exists($cache)) {</p>	die('ERROR: Image conversion failed.');</p>}</p><p>// get image data for use in http-headers</p>$imginfo = getimagesize($cache);</p>$content_length = filesize($cache);</p>$last_modified = gmdate('D, d M Y H:i:s',filemtime($cache)).' GMT';</p><p>// array of getimagesize() mime types</p>$getimagesize_mime = array(1=>'image/gif',2=>'image/jpeg',3=>'image/png',</p>                           4=>'application/x-shockwave-flash',5=>'image/psd',</p>                           6=>'image/bmp',7=>'image/tiff',8=>'image/tiff',</p>                           9=>'image/jpeg',</p>                           13=>'application/x-shockwave-flash',</p>                           14=>'image/iff');</p></pre></p><p><p></p>We can now check if the browser sent us a If-Modified-Since header. This is</p>used to update the browser cache. If the If-Modified-Since date of the browser</p>is equal to the date the image was last modified, we don't have to send the</p>image again. The cache of the browser still has an updated version.</p></p></p><pre></p>// did the browser send an if-modified-since request?</p>if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {</p>	// parse header</p>	$if_modified_since = preg_replace('/;.*$/', '', $_SERVER['HTTP_IF_MODIFIED_SINCE']);</p><p>	if ($if_modified_since == $last_modified) {</p>		// the browser's cache is still up to date</p>		header("HTTP/1.0 304 Not Modified");</p>		header("Cache-Control: max-age=86400, must-revalidate");</p>		exit;</p>	}</p>}</p></pre></p><p><p></p>The browser does really want a (new) version of the image. We send some headers</p>and then the image.</p></p></p><p></p>The <code>Content-Type</code> header is a bit special. We have to send a MIME</p>content type, but the PHP <code>getimagesize()</code> command only gives us</p>the number of the image type. With the <code>$getimagesize_mime</code> array</p>we can find the MIME type of that number. In case there is no number we use</p>the <code>application/octet-stream</code> type. I haven't tested that, but</p>it's probably better than <code>text/html</code>. (Note: Starting with</p>PHP 4.3, <code>getimagesize()</code> does return a MIME type. I didn't use it</p>to make the script compatible with older versions.)</p></p></p><pre></p>// send other headers</p>header('Cache-Control: max-age=86400, must-revalidate');</p>header('Content-Length: '.$content_length);</p>header('Last-Modified: '.$last_modified);</p>if (isset($getimagesize_mime[$imginfo[2]])) {</p>	header('Content-Type: '.$getimagesize_mime[$imginfo[2]]);</p>} else {</p>	// send generic header</p>	header('Content-Type: application/octet-stream');</p>}</p><p>// and finally, send the image</p>readfile($cache);</p><p>?&gt;</p></pre></p><p><h2>Concluding</h2></p><p></p>If you copied the parts of the script and saved it in your image directory,</p>it's ready for use. Just enter the url to the script, a slash, then the name</p>of your image and a query string. You should now get the image, modified to</p>suit your needs.</p></p></p><p></p>For those of you who don't like to copy-paste: you can download the <a</p>href="http://gvtulder.f2o.org/evolt/magick/magick.php.txt" target="_new"</p>title="Download the full script (Link opens in a new window)">full script</a>.</p></p></p><p><h3>Tip</h3></p><p></p>Maybe you don't like the ugly <code>.php</code> part in</p>your url (I don't). You can edit your Apache's configuration file, or</p>place a .htaccess file in your images directory and add the line:</p></p></p><pre></p>DefaultType application/x-httpd-php</p></pre></p><p></p>You can then rename the script to something without <code>.php</code> (ie. just</p><code>magick</code>). The url is now much nicer.</p></p>