---
layout: post
permalink: node/2986
ratings: 11
avgrate: 4.5455
rating: 4.34
categories: [Code]
user: tcm614ce
real_name: "Adam Patrick"
user_biog: ""
user_since: 02 Mar 2000
avatar: 
article_count: 1
excerpt: "Introduction</p>Query speed is a perpetual challenge for anyone using a SQL database. Many </p>  newer Oracle Users are unaware of the issues involved with designing a good </p>  query and those who have be"
---
<h2>Introduction</h2></p><P>Query speed is a perpetual challenge for anyone using a SQL database. Many </p>  newer Oracle Users are unaware of the issues involved with designing a good </p>  query and those who have been at the game for some time want to make sure they </p>  are not needlessly burdening the database server. If you use Oracle, Explain </p>  Plan is a great way to tune your queries. As a bonus for using Explain Plan, </p>  you will learn more about how the DBMS works &quot;behind the scenes&quot;, </p>  enabling you to write efficient queries the first time around</P></p><h2>Using Explain Plan</h2></p><P>What does Explain Plan do? Explain Plan executes your query and records the </p>  &quot;plan&quot; that Oracle devises to execute your query. By examining this </p>  plan, you can find out if Oracle is picking the right indexes and joining your </p>  tables in the most efficient manner. There are a few different ways to utilize </p>  Explain Plan. I will focus on using it through SQL*Plus since most Oracle programmers </p>  will have access to SQL*Plus.</P></p><P>The first thing you will need to do is make sure you have a table called plan_table </p>  available in your schema. The following SQL will create it for you if you don't </p>  have it:</P></p><pre></p>CREATE TABLE plan_table</p> (</p>  statement_id               VARCHAR2(30),</p>  timestamp                  DATE,</p>  remarks                    VARCHAR2(80),</p>  operation                  VARCHAR2(30),</p>  options                    VARCHAR2(30),</p>  object_node                VARCHAR2(128),</p>  object_owner               VARCHAR2(30),</p>  object_name                VARCHAR2(30),</p>  object_instance            NUMBER,</p>  object_type                VARCHAR2(30),</p>  optimizer                  VARCHAR2(255),</p>  search_columns             NUMBER,</p>  id                         NUMBER,</p>  parent_id                  NUMBER,</p>  position                   NUMBER,</p>  other                      LONG</p> )</p> </p></pre></p><p>Next, you can run the following script to get a list of the steps that Oracle </p>  will perform in order to execute your query:</p></p><pre></p>set echo on</p><p>delete from plan_table</p> where statement_id = 'MINE';</p>commit;</p>COL operation   FORMAT A30</p>COL options     FORMAT A15</p>COL object_name FORMAT A20</p>EXPLAIN PLAN set statement_id = 'MINE' for</p>/* ------ Your SQL here ------*/</p>select *</p>  from scott.salgrade</p><p>/*----------------------------*/</p>/</p><p>set echo off</p><p>select operation, options, object_name</p>  from plan_table</p> where statement_id = 'MINE'</p>start with id = 0</p>connect by prior id=parent_id and prior statement_id = statement_id;</p>set echo on</p></pre></p><h2>Making Use of Indexes</h2></p><p>Making sure your query is using indexes to find rows faster is the most basic </p>  use of Explain Plan. We will examine this process first. When the aforementioned </p>  script is run with the query &quot;select * from scott.salgrade&quot;, this </p>  is the output we will see:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>TABLE ACCESS                   FULL            SALGRADE</p></pre></p><p>What this tells us is that in order to execute the SELECT STATEMENT, Oracle </p>  will access the table SALGRADE using a FULL table scan. In other words the DBMS </p>  will read every record in SALGRADE. You would expect this result for a query </p>  with no where clause. What if we want to look for the record for salary grade </p>  #1. We will limit our results using the GRADE column in SALGRADE and our query </p>  will look like this:</p></p><code>select *<br></p>  from scott.salgrade<br></p> where grade = 1<br></p></code></p><p>But our plan looks the same. Oracle still has to read every row in the table </p>  to find all rows with the grade = 1 because there is no index on that column. </p>  Since, GRADE should be the primary key of the SALGRADE table, we will create </p>  a primary key constraint on that column. After creating the primary key constraint </p>  (which creates a related unique index), and running the plan script again, our </p>  plan looks like this:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          UNIQUE SCAN     SALGRADE_PK</p></pre></p><p>This time Oracle ran a unique scan on the SALGRADE_PK index and then went directly </p>  to the row we wanted in the SALGRADE table using the ROWID. An index scan is </p>  much faster than a full table scan so the result of our query is sure to come </p>  back nearly instantaneously, even if our table has millions of rows.</p></p><p> What if we had simply created a non-unique index instead of a primary (unique) </p>  key? Our plan would have looked like this:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          RANGE SCAN      SALGRADE_IDX1</p></pre></p><p>This is a slightly slower path for Oracle to take. Notice that the OPTIONS </p>  column says RANGE SCAN instead of UNIQUE SCAN. This is because it has to scan </p>  for multiple records with the same value in the index in case there is more </p>  than one row. If this was the case, our query speed would depend on the uniqueness </p>  of our data. Assuming a fairly large table size, we can illustrate this dependance </p>  using two extreme cases. In the first extreme case, GRADE is totally unique </p>  (even though the index is non-unique). Because of this uniqueness, Oracle will </p>  be able to find the row it needs quite quickly and bring back the results. In </p>  the second extreme case, there are only a few different values for GRADE distributed </p>  among many rows. Because of this non-uniqueness, Oracle will have to scan through </p>  many values in the index to find the ones it wants, finalizing the results some </p>  time later.</p></p><p>Most of the time, when you write your queries, the data model will have already </p>  been built to match the purpose of the application. To maximize your application's </p>  speed, use criteria that will allow Oracle to use the fastest (most unique) </p>  indexes on a given table.</p></p><h2>Joining Tables Efficiently</h2></p><p>Sometimes we use slower (less unique) indexes in small to medium sized tables </p>  and don't notice that our application is slower than it should be. However, </p>  when joining tables, you will notice a difference if you are not using the optimal </p>  query plan. The key to making joins faster is making your query select from </p>  the table that will return the least number of records first and then use the </p>  information gained from the first table to make subsequent searches more unique. </p>  The following query retrieves the employee and salary records for employee #1:</p></p><code></p>select *<br></p>  from emp e, salgrade s<br></p> where empid   = 1<br></p>   and s.grade = e.grade<br></p></code></p><p>Given a unique index on EMPID in the EMP table and on GRADE in the SALGRADE </p>  table, Oracle's plan will look like this:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>NESTED LOOPS</p>TABLE ACCESS                   BY INDEX ROWID  EMP</p>INDEX                          UNIQUE SCAN     EMP_PK</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          UNIQUE SCAN     SALGRADE_PK</p></pre></p><p>The NESTED LOOPS operation indicates that Oracle will look for rows in GRADE </p>  for each row in EMP that it finds. We have an efficient query because Oracle </p>  is searching for our EMPID = 1 first and then looking for 1's GRADE. If Oracle </p>  had looked in SALGRADE first, it would have had to read all rows in that table </p>  because it wouldn't know what the GRADE of EMPID = 1 was. In this case, it would </p>  be hard to write an inefficient query because we are searching on criteria that </p>  are by definition unique (and fast). What if we had to search on fields with </p>  a low level of uniqueness? Examine the following query, which searches for employees </p>  with low salaries (LOSAL) between 10000 and 30000:</p></p><code>select *</p>  from emp e, salgrade s</p> where s.grade = e.grade</p>   and s.losal between 10000 and 30000</code></p><p>We will get this plan from Oracle:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>NESTED LOOPS</p>TABLE ACCESS                   FULL            EMP</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          UNIQUE SCAN     SALGRADE_PK</p></pre></p><p>Under the circumstances, this is the best we could have done. Oracle scans </p>  the employee table (all of it) because it can narrow that table the most using </p>  the given criteria. Hypothetically, there are a couple of ways to speed up this </p>  query. One way is to use some criteria on the EMP table that is indexed. if </p>  we assume a non-unique index on EMP.NAME (EMP_IDX2), and have some sort of criteria </p>  we can use for NAME, we could narrow our results from EMP more quickly. Let's </p>  get the employee and salary records for all employees whose names start with </p>  'SM' and whose low salaries are between 10000 and 30000, like so:</p></p><code>select *<br></p>  from emp e, salgrade s<br></p> where e.name like 'SM%'</p>   and s.grade = e.grade<br></p>   and s.losal between 10000 and 30000<br></p></code></p><p>We will get this plan from Oracle: <br></p></p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>NESTED LOOPS</p>TABLE ACCESS                   BY INDEX ROWID  EMP</p>INDEX                          RANGE SCAN      EMP_IDX2</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          UNIQUE SCAN     SALGRADE_PK</p></pre></p><p>The criteria on NAME could narrow our search fairly quickly. The actual speed </p>  will depend on the uniqueness of the NAME column. If all of our employees are </p>  named SMITH and SMYTHE and SMALL, the criteria will not help much. Given an </p>  even distribution of names, the criteria will help a lot.</p></p><p>What if we didn't have the option to narrow down the result set by NAME? We </p>  might want to consider creating an index on the SALGRADE.LOSAL and another index </p>  on EMP.GRADE if this query is used often. Given a non-unique index on SALGRADE.LOSAL, </p>  a non-unique index on EMP.GRADE and this query:<br></p></p></p><code>select *<br></p>  from emp e, salgrade s<br></p> where s.grade = e.grade<br></p>   and s.losal between 10000 and 30000<br> </p></code></p><p>Oracle will produce this plan:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>NESTED LOOPS</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          RANGE SCAN      SALGRADE_IDX2</p>TABLE ACCESS                   BY INDEX ROWID  EMP</p>INDEX                          RANGE SCAN      EMP_IDX3</p></pre></p><p>Oracle now will search for the appropriate salary grades first and then all </p>  employees with that grade.</p></p><h2>Using the fastest indexes in a Join</h2></p><p>Up until now, we have been striving to use any avaliable index. More complicated </p>  issues arise when trying to decide which of two or three indexes is faster. </p>  In the case that are looking for names starting with 'SM' and low salaries between </p>  10000 and 30000 and all the indexes given up to this point, we will probably </p>  have to tell Oracle which table to search first, in order to get results as </p>  quickly as possible. We can do that by changing the order of the tables in the </p>  from clause. This query:</p></p><code>select *<br></p>  from emp e, salgrade s<br></p> where e.name like 'SM%'<br></p>   and s.grade = e.grade<br></p>   and s.losal between 10000 and 30000<br></p></code></p><p>Will produce this plan:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>NESTED LOOPS</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          RANGE SCAN      SALGRADE_IDX2</p>TABLE ACCESS                   BY INDEX ROWID  EMP</p>INDEX                          RANGE SCAN      EMP_IDX3</p></pre></p><p>The plan indicates that Oracle looks at SALGRADE.LOSAL first and EMP.NAME second. </p>  The choice is made because SALGRADE comes last in the from clause. If Oracle </p>  can't decide which table is better to go with first, it will read the from clause </p>  from right to left. This is great if SALGRADE.LOSAL is more unique than EMP.NAME. </p>  However, what if searching for EMP.NAME starting with 'SM' will return fewer </p>  rows than searching for SALGRADE.LOSALs between 10000 and 30000? Simply switch </p>  the tables in the from clause to produce the opposite result:</p></p><code></p> select *</p>   from salgrade s, emp e</p>  where e.name like 'SM%'</p>    and s.grade = e.grade</p>    and s.losal between 10000 and 30000</code></p><p>This query produces this plan:</p></p><pre></p>OPERATION                      OPTIONS         OBJECT_NAME</p>------------------------------ --------------- --------------------</p>SELECT STATEMENT</p>NESTED LOOPS</p>TABLE ACCESS                   BY INDEX ROWID  EMP</p>INDEX                          RANGE SCAN      EMP_IDX2</p>TABLE ACCESS                   BY INDEX ROWID  SALGRADE</p>INDEX                          UNIQUE SCAN     SALGRADE_PK</p></pre></p><p>EMP.NAME is queried first because we instructed Oracle to do so.</p></p><h2>Utilizing Multiple Column Indexes</h2></p><p>Multiple-column indexes will eventually make their way into your database applications. </p>  In order to use the index, we have to search on the first column before searching </p>  on the second column in the index and the criteria for the second column will </p>  not help us if our criteria for the first column are not very unique. Also keep </p>  in mind that in order to get a fully unique search on a unique multi-column </p>  index, we have to limit all columns in the index. </p></p><h2>Conclusion</h2></p><p>Remember that by utilizing Explain Plan you can explore the differences that </p>  subtle changes in your query make in the way Oracle executes your query. In </p>  a short time you will be writing very fast queries. </p></p></p><p></p>By <a href="mailto:apatrick@oracular.com">Adam Patrick</a></p>