---
layout: post
permalink: node/3419
---
<p>Don't use CDONTS (even the acronym is a good reminder). Don't use ASPMail.\nDon't worry about talking to the email server directly. Do it the fast\nsmooth &#151;asynchronous&#151; way: drop a file off and let the SMTP server handle\nit.</p>\n<h2>Why?</h2>\n<ol>\n<li>Performance &#151; Writing to a file may be faster (depending on the run-time\nenvironment) than talking to a mail server, especially when you may not be\nable to control the availability/response time of the mail server. On top of\nthat, if the attachment is large, your page has to sit and wait for the mail\nserver to slurp in all the data. Its not much slower than our\nreading-and-rewriting, but something to consider. --Add in multiple\nrecipients and you see where this can get out of hand and we should just\ntreat this as...</li>\n<li>Asynchronous &#151; Let's say we have to send out 2 emails. Using CDONTS or a\nthird party component like ASPMail will be fine. Let's say we have to send\nout 2,000. 200,000. 2,000,000? &#151;Having a process (in our examples an ASP\npage) connected to a mail server that long (1) isn't efficient, and (2) most\nlikely won't run to completion in one session because email servers have\nlimits to the number of messages they'll accept from one connection at one\ntime (spam discouraging, and while you're connected noone else can). Using\nthis method, we can write 10,000 emails to disk and let the mail server get\nto them when it can.  We're no longer bound to the SMTP server's performance\nand in my mind that makes it...</li>\n<li>Scalable &#151; If you handle <i>large</i> amounts of outgoing email, you can\n(relatively) easily migrate from the local disk to a shared storage solution\nor something of the sort to handle the file I/O. Keeping things in a uniform\nparadigm (dealing with files) as when working with rejected emails and (if\nyou dare) incoming email in addition to just sending them is a plus to me.\nIts easier to administer. And, if you need to handle multiple MIME types, or\nsend binary files...</li>\n<li>You can ditch the home-spun code but keep the process. Mabry has an\nActiveX COM object that will handle all your MIME email generation needs,\nincluding writing the output to file (<a href="http://www.mabry.com/mailx.htm" target="foo">http://www.mabry.com/mailx.htm</a>).</li>\n</ol>\n<h2>Why not?</h2>\n<ol>\n<li>Scalability is a concern, but not a show stopper. Say you've got 4 web\nservers, and one email server. You're left with using UNC names and drive\nshares for the 4 web servers to write to the email server's Pickup\ndirectory, and that introduces permissions headaches, enough to warrant\nconverting the code into an ActiveX DLL so it can be loaded in MTS where you\ncan specify the identity under which it executes, and this can also lead to problems with...</li>\n<li>Maintainability. &#151;Got a new MIME type you wanna send? Open the code.\nWanna send a binary file? open the code (our code here does text\nattachments). We are kinda re-inventing the wheel here, which is to be\nexpected when you work on something that others are too. With some spare\ncash (probably amounting to less than the amount of billable time you spend\nwriting this), you can grab ActiveX objects to handle the dirty work for you\n(<a href="http://www.mabry.com/mailx.htm" target="foo">http://www.mabry.com/mailx.htm</a>).</li>\n</ol>\n<p>That being said, we use this process to handle our emails. Its robust, dern fast, and we send a <i>ton</i>\nof emails this way.</p>\n<h2>The recipe</h2>\nHere's what you need to cook this up:\n<ul><li>IIS 4</li>\n<li>IIS' SMTP Server installed on the same server</li>\n<li>ASP and VBScript (Part 3 could be putting this stuff into a component (dll), ask me)</li>\n<li>a little MIME knowledge</li></ul>\n<p>Working backwards, let's start with a little MIME, shall we?<br>\n&lt;insert image of midget in white face-paint trying to get out of an\ninvisible box&gt;</p>\n<p>MIME (Multi-purpose Internet Mail Extensions) is an extension of SMTP\n(Simple Mail Transfer Protocol), that allows some description of the data to\ncue the recipient into using the right application to view the contents. You\nmay have already dealt with MIME types and not even know it. "text/html"\nanyone? how about "text/css" ? --Those are MIME types, and tell the\nrecipient (your browser) how to handle the data.</p>\n<p>What does knowing MIME do for us? Well, in order to just drop a file off and\ngo, and expect IIS' SMTP server to send it out, we have to write the file in\nraw MIME format. It's not that tough, but ya gots to know what goes where.\n&#151;We get to generate our own email headers. On top of that, if we want to\nsend attachments, we have to play with MIME and know the right way to\npackage it.</p>\n<p>Email process overview:</p>\n<ol>\n<li>we gotta generate a unique filename</li>\n<li>enumerate through our headers and write it to file (with the filename\nabove)</li>\n<li>we move that file to the SMTP Pickup directory, where the SMTP Server\nnabs it</li></ol>\n<h2>Creating a unique filename</h2>\n<p>&nbsp;&nbsp;&nbsp;Because we may have multiple people firing this off, we need to\nensure we don't step on anyone else:</p>\n<pre>\n&lt;%\nFunction GenMIMEName()\n   Randomize   ' Initialize random-number generator.\n   RandomNbr = Int((1000000 * Rnd) + 0)\n   RandomNbr = Right(&quot;0000000&quot; + RandomNbr, 6)\n   GenMIMEName = Request.ServerVariables(&quot;REMOTE_ADDR&quot;) & &quot;_&quot; & RandomNbr & &quot;.email&quot;\nEnd Function\n%&gt;\n</pre>\n<h2>Enumerate through file</h2>\n<p>We need to have some specific headers and such, here's what a MIME email\nlooks like before its sent out:</p>\n<pre>\nReturn-Path:&lt;support@ti3.com&gt;\nDate: Mon, Aug 28 2000 17:41 -0600\nTo: &lt;sgd@ti3.com&gt;\nFrom: &lt;support@ti3.com&gt;\nSubject: [Friday Freebie] Look, ma no CDONTS!\nMIME-Version: 1.0\nContent-Type: text/plain; charset=&quot;US-ASCII&quot;\nContent-transfer-encoding: 7bit</p><p>This is the body of the email. I'm the company liability!\n</pre>\n<p>&#151; So this is pretty straightforward then, right? We gotta worry about a\ncouple things: creating the date in the right format, and making sure we\nhave at least one blank line after the headers to indicate the start of the\nbody. To create the date, we need to spit it out in "ddd, dd mmm yyyy hh:nn\ngggg" &#151;try this:</p>\n<pre>\n<%\nfunction GenMIMEDate(byval mydate, byval gggg)\n         ' mydate is already a date type, no error checking here!\n         ' gggg is expected to already be in offset from GMT format, i.e. "-0600"\n         ' we need to return ddd, dd mmm yyyy hh:nn gggg\n         ddd = weekdayname(weekday(mydate),True)\n         mmm = monthname(month(mydate),True)\n         ' make sure we have a leading zero on single digit dates\n         dd = zeropad(day(mydate),2)\n         yyyy = year(mydate)\n         hh = hour(mydate)\n         nn = minute(mydate)\n         GenMIMEDate = ddd &", "& dd &" "& mmm &" "& yyyy &" "& hh &":"& nn &" "& gggg\nend function</p><p>\nFunction zeropad(byval val, byval ceiling)\nif len(val)<ceiling then ' pad with zeros to make ceiling chars long\n	for i=1 to ceiling-Len(val)\n		val = "0"&val\n	Next\nend if\nzeropad = val\nEnd Function\n%>\n</pre>\n<p>&#151; I played with dummy proofing the offset, but for now let's just assume\nthat we already now it, as its not the point of this tip ;)</p>\n<p>So here's what I have to generate our headers and email:</p>\n<pre>\n&lt;%\nfunction GenMIMEHeaders(byval replyto, byval from, byval mto, byval subject)\nreplyto = &quot;&lt;&quot;& replyto &&quot;&gt;&quot;\nfrom = &quot;&lt;&quot;& from &&quot;&gt;&quot;\nsendto = split(mto,&quot;,&quot;)\nfor each addr in sendto\n&nbsp;&nbsp;&nbsp;tolist = &quot;&lt;&quot;& addr &&quot;&gt;,&quot; & tolist\nNext\ntolist = Left(tolist,len(tolist)-1) ' take off the last comma\nheaders = &quot;Return-Path:&quot;&replyto & vbNewLine\nheaders = headers & &quot;Date: &quot; & GenMIMEDate(Now,&quot;-0600&quot;) & vbNewLine\nheaders = headers & &quot;To:&quot;& tolist & vbNewLine\nheaders = headers & &quot;From:&quot;& from & vbNewLine\nheaders = headers & &quot;Subject: &quot;& subject & vbNewLine\nheaders = headers & &quot;MIME-Version: 1.0&quot; & vbNewLine\nheaders = headers & &quot;Content-Type: text/plain; charset=&quot;&quot;US-ASCII&quot;&quot;&quot; &\nvbNewLine\nGenMIMEHeaders = headers & &quot;Content-transfer-encoding: 7bit&quot; & vbNewLine &\nvbNewLine\nend function</p><p>function GenMIMEEmail(byval from, byval mto, byval subject, byval body)\nGenMIMEEmail = GenMIMEHeaders(from,from,mto,subject) & body\nend function\n%&gt;</pre>\n<p>&#151;Notice we're able to take in a comma delimited list of <code>To:</code> addresses. That\nway we can send to multiple people at once (from the department of\nredundancy department)</p>\n<p>Also notice I've separated creating the headers with attaching the body.\nThis on purpose, because in the next part we're gonna\nexpand to include attachments.</p>\n<h2>File handling</h2>\n<p>Now we gotta write it to a file, in a temporary spot. This is because if we\ncreate the file in IIS's SMTP Server Pickup directory, it will try to slurp\nit up before we're done, and that's Bad. Oh yeah, where the hell is this\nPickup directory? &#151;<code>\InetPub\MailRoot\Pickup</code> (using the default install name\nfor the Inet root). Create a directory for the temp spot; we use\n<code>D:\InetPub\MailRoot\Pickup\TempMail</code>.</p>\n<p>Let's write it to file, shall we?</p>\n<pre>\n&lt;%\nSub WriteEmail(byval email, byval filename)\nDim ForAppending,fs,a,logstr\n' drop the email to a file\nForAppending = 8\nfilename = &quot;D:\InetPub\Mailroot\Pickup\tempmail\&quot; & filename\nSet fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet a = fs.OpenTextFile(filename, ForAppending, True)\na.Write(email)\na.Close\nSet a = Nothing\nSet fs = Nothing\nEnd Sub\n%&gt;</pre>\n<h2>Move the temp file into the Pickup directory</h2>\n<p>Well, so far we gots the email being generated with all the MIME we need\n(for now), and we're writing it to the file system with no probs. Now we\ngotta move it to the Pickup directory to actually get it sent. I'll reopen\nthe WriteEmail subroutine and tweak a few things to get it done:</p>\n<pre>\n&lt;%\nSub WriteEmail(byval email, byval filename)\nDim ForAppending,fs,a,logstr\n' drop the email to a file\ntempdir =&quot;tempmail\&quot;\npickupdir = &quot;D:\InetPub\Mailroot\Pickup\&quot;\nForAppending = 8\ntempfilename = pickupdir & tempdir & filename\nSet fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet a = fs.OpenTextFile(tempfilename, ForAppending, True)\na.Write(email)\na.Close\nSet a = Nothing\nfs.MoveFile tempfilename, pickupdir & filename\nSet fs = Nothing\nEnd Sub\n%&gt;\n</pre>\n<p>Phew.</p>\n<p>Now, let's see the function calls in action:</p>\n<pre>\n&lt;%\n' use _ to use multiple lines in VBScript\nemail = genMIMEEmail(&quot;support@ti3.com&quot;, _ \n                     &quot;sgd@ti3.com&quot;, _ \n                     &quot;[Friday Freebie] Look, ma no CDONTS!&quot;, _ \n                     &quot;This is the body of the email. I'm the company liability!&quot;)\nWriteEmail email,GenMIMEName\n%&gt;</pre>\n<p>Gee, that was simple, wasn't it? In the next installment, we'll add in attachments.</p>\n<p>