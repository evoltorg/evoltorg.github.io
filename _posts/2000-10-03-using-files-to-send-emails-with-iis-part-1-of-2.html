---
layout: post
permalink: node/3419
ratings: 12
avgrate: 4.3333
user: sgd
real_name: "Scott Dexter"
user_since: 26 Apr 1999
avatar: "/images/pictures/picture-35.gif"
article_count: 10
excerpt: "Don't use CDONTS (even the acronym is a good reminder). Don't use ASPMail.</p>Don't worry about talking to the email server directly. Do it the fast</p>smooth &#151;asynchronous&#151; way: drop a file"
---
<p>Don't use CDONTS (even the acronym is a good reminder). Don't use ASPMail.</p>Don't worry about talking to the email server directly. Do it the fast</p>smooth &#151;asynchronous&#151; way: drop a file off and let the SMTP server handle</p>it.</p></p><h2>Why?</h2></p><ol></p><li>Performance &#151; Writing to a file may be faster (depending on the run-time</p>environment) than talking to a mail server, especially when you may not be</p>able to control the availability/response time of the mail server. On top of</p>that, if the attachment is large, your page has to sit and wait for the mail</p>server to slurp in all the data. Its not much slower than our</p>reading-and-rewriting, but something to consider. --Add in multiple</p>recipients and you see where this can get out of hand and we should just</p>treat this as...</li></p><li>Asynchronous &#151; Let's say we have to send out 2 emails. Using CDONTS or a</p>third party component like ASPMail will be fine. Let's say we have to send</p>out 2,000. 200,000. 2,000,000? &#151;Having a process (in our examples an ASP</p>page) connected to a mail server that long (1) isn't efficient, and (2) most</p>likely won't run to completion in one session because email servers have</p>limits to the number of messages they'll accept from one connection at one</p>time (spam discouraging, and while you're connected noone else can). Using</p>this method, we can write 10,000 emails to disk and let the mail server get</p>to them when it can.  We're no longer bound to the SMTP server's performance</p>and in my mind that makes it...</li></p><li>Scalable &#151; If you handle <i>large</i> amounts of outgoing email, you can</p>(relatively) easily migrate from the local disk to a shared storage solution</p>or something of the sort to handle the file I/O. Keeping things in a uniform</p>paradigm (dealing with files) as when working with rejected emails and (if</p>you dare) incoming email in addition to just sending them is a plus to me.</p>Its easier to administer. And, if you need to handle multiple MIME types, or</p>send binary files...</li></p><li>You can ditch the home-spun code but keep the process. Mabry has an</p>ActiveX COM object that will handle all your MIME email generation needs,</p>including writing the output to file (<a href="http://www.mabry.com/mailx.htm" target="foo">http://www.mabry.com/mailx.htm</a>).</li></p></ol></p><h2>Why not?</h2></p><ol></p><li>Scalability is a concern, but not a show stopper. Say you've got 4 web</p>servers, and one email server. You're left with using UNC names and drive</p>shares for the 4 web servers to write to the email server's Pickup</p>directory, and that introduces permissions headaches, enough to warrant</p>converting the code into an ActiveX DLL so it can be loaded in MTS where you</p>can specify the identity under which it executes, and this can also lead to problems with...</li></p><li>Maintainability. &#151;Got a new MIME type you wanna send? Open the code.</p>Wanna send a binary file? open the code (our code here does text</p>attachments). We are kinda re-inventing the wheel here, which is to be</p>expected when you work on something that others are too. With some spare</p>cash (probably amounting to less than the amount of billable time you spend</p>writing this), you can grab ActiveX objects to handle the dirty work for you</p>(<a href="http://www.mabry.com/mailx.htm" target="foo">http://www.mabry.com/mailx.htm</a>).</li></p></ol></p><p>That being said, we use this process to handle our emails. Its robust, dern fast, and we send a <i>ton</i></p>of emails this way.</p></p><h2>The recipe</h2></p>Here's what you need to cook this up:</p><ul><li>IIS 4</li></p><li>IIS' SMTP Server installed on the same server</li></p><li>ASP and VBScript (Part 3 could be putting this stuff into a component (dll), ask me)</li></p><li>a little MIME knowledge</li></ul></p><p>Working backwards, let's start with a little MIME, shall we?<br></p>&lt;insert image of midget in white face-paint trying to get out of an</p>invisible box&gt;</p></p><p>MIME (Multi-purpose Internet Mail Extensions) is an extension of SMTP</p>(Simple Mail Transfer Protocol), that allows some description of the data to</p>cue the recipient into using the right application to view the contents. You</p>may have already dealt with MIME types and not even know it. "text/html"</p>anyone? how about "text/css" ? --Those are MIME types, and tell the</p>recipient (your browser) how to handle the data.</p></p><p>What does knowing MIME do for us? Well, in order to just drop a file off and</p>go, and expect IIS' SMTP server to send it out, we have to write the file in</p>raw MIME format. It's not that tough, but ya gots to know what goes where.</p>&#151;We get to generate our own email headers. On top of that, if we want to</p>send attachments, we have to play with MIME and know the right way to</p>package it.</p></p><p>Email process overview:</p></p><ol></p><li>we gotta generate a unique filename</li></p><li>enumerate through our headers and write it to file (with the filename</p>above)</li></p><li>we move that file to the SMTP Pickup directory, where the SMTP Server</p>nabs it</li></ol></p><h2>Creating a unique filename</h2></p><p>&nbsp;&nbsp;&nbsp;Because we may have multiple people firing this off, we need to</p>ensure we don't step on anyone else:</p></p><pre></p>&lt;%</p>Function GenMIMEName()</p>   Randomize   ' Initialize random-number generator.</p>   RandomNbr = Int((1000000 * Rnd) + 0)</p>   RandomNbr = Right(&quot;0000000&quot; + RandomNbr, 6)</p>   GenMIMEName = Request.ServerVariables(&quot;REMOTE_ADDR&quot;) & &quot;_&quot; & RandomNbr & &quot;.email&quot;</p>End Function</p>%&gt;</p></pre></p><h2>Enumerate through file</h2></p><p>We need to have some specific headers and such, here's what a MIME email</p>looks like before its sent out:</p></p><pre></p>Return-Path:&lt;support@ti3.com&gt;</p>Date: Mon, Aug 28 2000 17:41 -0600</p>To: &lt;sgd@ti3.com&gt;</p>From: &lt;support@ti3.com&gt;</p>Subject: [Friday Freebie] Look, ma no CDONTS!</p>MIME-Version: 1.0</p>Content-Type: text/plain; charset=&quot;US-ASCII&quot;</p>Content-transfer-encoding: 7bit</p><p>This is the body of the email. I'm the company liability!</p></pre></p><p>&#151; So this is pretty straightforward then, right? We gotta worry about a</p>couple things: creating the date in the right format, and making sure we</p>have at least one blank line after the headers to indicate the start of the</p>body. To create the date, we need to spit it out in "ddd, dd mmm yyyy hh:nn</p>gggg" &#151;try this:</p></p><pre></p><%</p>function GenMIMEDate(byval mydate, byval gggg)</p>         ' mydate is already a date type, no error checking here!</p>         ' gggg is expected to already be in offset from GMT format, i.e. "-0600"</p>         ' we need to return ddd, dd mmm yyyy hh:nn gggg</p>         ddd = weekdayname(weekday(mydate),True)</p>         mmm = monthname(month(mydate),True)</p>         ' make sure we have a leading zero on single digit dates</p>         dd = zeropad(day(mydate),2)</p>         yyyy = year(mydate)</p>         hh = hour(mydate)</p>         nn = minute(mydate)</p>         GenMIMEDate = ddd &", "& dd &" "& mmm &" "& yyyy &" "& hh &":"& nn &" "& gggg</p>end function</p><p></p>Function zeropad(byval val, byval ceiling)</p>if len(val)<ceiling then ' pad with zeros to make ceiling chars long</p>	for i=1 to ceiling-Len(val)</p>		val = "0"&val</p>	Next</p>end if</p>zeropad = val</p>End Function</p>%></p></pre></p><p>&#151; I played with dummy proofing the offset, but for now let's just assume</p>that we already now it, as its not the point of this tip ;)</p></p><p>So here's what I have to generate our headers and email:</p></p><pre></p>&lt;%</p>function GenMIMEHeaders(byval replyto, byval from, byval mto, byval subject)</p>replyto = &quot;&lt;&quot;& replyto &&quot;&gt;&quot;</p>from = &quot;&lt;&quot;& from &&quot;&gt;&quot;</p>sendto = split(mto,&quot;,&quot;)</p>for each addr in sendto</p>&nbsp;&nbsp;&nbsp;tolist = &quot;&lt;&quot;& addr &&quot;&gt;,&quot; & tolist</p>Next</p>tolist = Left(tolist,len(tolist)-1) ' take off the last comma</p>headers = &quot;Return-Path:&quot;&replyto & vbNewLine</p>headers = headers & &quot;Date: &quot; & GenMIMEDate(Now,&quot;-0600&quot;) & vbNewLine</p>headers = headers & &quot;To:&quot;& tolist & vbNewLine</p>headers = headers & &quot;From:&quot;& from & vbNewLine</p>headers = headers & &quot;Subject: &quot;& subject & vbNewLine</p>headers = headers & &quot;MIME-Version: 1.0&quot; & vbNewLine</p>headers = headers & &quot;Content-Type: text/plain; charset=&quot;&quot;US-ASCII&quot;&quot;&quot; &</p>vbNewLine</p>GenMIMEHeaders = headers & &quot;Content-transfer-encoding: 7bit&quot; & vbNewLine &</p>vbNewLine</p>end function</p><p>function GenMIMEEmail(byval from, byval mto, byval subject, byval body)</p>GenMIMEEmail = GenMIMEHeaders(from,from,mto,subject) & body</p>end function</p>%&gt;</pre></p><p>&#151;Notice we're able to take in a comma delimited list of <code>To:</code> addresses. That</p>way we can send to multiple people at once (from the department of</p>redundancy department)</p></p><p>Also notice I've separated creating the headers with attaching the body.</p>This on purpose, because in the next part we're gonna</p>expand to include attachments.</p></p><h2>File handling</h2></p><p>Now we gotta write it to a file, in a temporary spot. This is because if we</p>create the file in IIS's SMTP Server Pickup directory, it will try to slurp</p>it up before we're done, and that's Bad. Oh yeah, where the hell is this</p>Pickup directory? &#151;<code>\InetPub\MailRoot\Pickup</code> (using the default install name</p>for the Inet root). Create a directory for the temp spot; we use</p><code>D:\InetPub\MailRoot\Pickup\TempMail</code>.</p></p><p>Let's write it to file, shall we?</p></p><pre></p>&lt;%</p>Sub WriteEmail(byval email, byval filename)</p>Dim ForAppending,fs,a,logstr</p>' drop the email to a file</p>ForAppending = 8</p>filename = &quot;D:\InetPub\Mailroot\Pickup\tempmail\&quot; & filename</p>Set fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)</p>Set a = fs.OpenTextFile(filename, ForAppending, True)</p>a.Write(email)</p>a.Close</p>Set a = Nothing</p>Set fs = Nothing</p>End Sub</p>%&gt;</pre></p><h2>Move the temp file into the Pickup directory</h2></p><p>Well, so far we gots the email being generated with all the MIME we need</p>(for now), and we're writing it to the file system with no probs. Now we</p>gotta move it to the Pickup directory to actually get it sent. I'll reopen</p>the WriteEmail subroutine and tweak a few things to get it done:</p></p><pre></p>&lt;%</p>Sub WriteEmail(byval email, byval filename)</p>Dim ForAppending,fs,a,logstr</p>' drop the email to a file</p>tempdir =&quot;tempmail\&quot;</p>pickupdir = &quot;D:\InetPub\Mailroot\Pickup\&quot;</p>ForAppending = 8</p>tempfilename = pickupdir & tempdir & filename</p>Set fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)</p>Set a = fs.OpenTextFile(tempfilename, ForAppending, True)</p>a.Write(email)</p>a.Close</p>Set a = Nothing</p>fs.MoveFile tempfilename, pickupdir & filename</p>Set fs = Nothing</p>End Sub</p>%&gt;</p></pre></p><p>Phew.</p></p><p>Now, let's see the function calls in action:</p></p><pre></p>&lt;%</p>' use _ to use multiple lines in VBScript</p>email = genMIMEEmail(&quot;support@ti3.com&quot;, _ </p>                     &quot;sgd@ti3.com&quot;, _ </p>                     &quot;[Friday Freebie] Look, ma no CDONTS!&quot;, _ </p>                     &quot;This is the body of the email. I'm the company liability!&quot;)</p>WriteEmail email,GenMIMEName</p>%&gt;</pre></p><p>Gee, that was simple, wasn't it? In the next installment, we'll add in attachments.</p></p><p>