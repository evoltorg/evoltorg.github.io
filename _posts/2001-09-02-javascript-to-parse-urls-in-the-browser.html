---
layout: post
permalink: node/14435
ratings: 2
avgrate: 3.0000
category: Code
user: ironclad
real_name: "Eric Scheid"
user_since: 18 Nov 2000
avatar: ""
article_count: 1
excerpt: "A cgi on the server returns a modified URL to the browser, and this javascript details how to parse the returned URL to take further action on errors."
---
<H2>the context</H2></p><P>I have on my server a basic form to email cgi which I'm slowly enhancing over time. The most recent feature was a way of specifiying <EM>required</EM> fields. If any of those fields are empty then the cgi redirects to a URL specified in the form to display an error message. This way the designer can make the error message fit in with the rest of their site's design.</P></p><p><P>Unfortunately, a part of good design is to give clear error messages, and thus the error message should only mention which fields were actually missing values, and not mention the fields which were not missing values.</P></p><p><H2>the problem</H2></p><DL></p>	<DT>non-technical designers</p>		<DD>the intended users for this technique will be amateur web builders. people that get all confused over javascripting anything. I needed a solution they could cut and paste easily, cookbook fashion.</p>	<DT>non-local redirections</p>		<DD>given that the intended users for this technique are a bit clueless, there was no way I was going to let them run scripts on my server, no siree. Some of them also wanted the response page to be somewhere else, like on another domain, and that domain may well not be served by my server. Thus, a cgi solution on my server would be moot in any case.</p></DL></p><p><H2>the challenge</H2></p><P>How to communicate values or parameters from the server to another page in a manner which didn't assume server-side processing beyond my control. That is, how to pass values back from the cgi in a form which something else could then do whatever they want with (including ignore).</P></p><p><H2>the solution</H2></p><P>Well, I thought, what if the redirection included the names of the missing fields in the URL itself, in the form of a searcharg parameter? Then, they could use a javascript on their html page to extract the names and display them however they wanted. Heck, they could even supply the URL for another cgi for the required-missing URL redirection, and thus trigger follow-on processing elsewhere. </p></P></p><p><P>All it would take is for my cgi to tack the missing parameters onto the supplied redirection URL. Thus if the form specifies that the page <CODE>required-error.html</CODE> should be used, then the cgi would simply modify that to <CODE>required-error.html?missing=name,email,code</CODE>. The cgi would detect before-hand if the redirect URL already includes a "?" character (eg. <CODE>required-error.cgi?form=BR437</CODE>) and would then instead tack on the parameters with an ampersand (eg. <CODE>required-error.cgi?form=BR437&amp;missing=name,email,code</CODE>) </P></p><p><P>If the page which was redirected to doesn't know what to do with the search arg, then no harm would be done as most web servers would merrily ignore the superfluous search args, even for plain HTML files read straight from disk</P></p><p><P>All that remained to do was to write up some javascript for the designer to cut &amp; paste into their own page ...</P></p><p><H2>the code</H2></p><p><P>Here is the Javascript I came up with. It looks at the location.href, extracting the searchargs, looks for a searcharg as named in the function call, and returns an array.</P></p><p><PRE></p>function argItems (theArgName) {</p>	sArgs = location.search.slice(1).split('&');</p>    r = '';</p>    for (var i = 0; i &lt; sArgs.length; i++) {</p>        if (sArgs[i].slice(0,sArgs[i].indexof('=')) == theArgName) {</p>            r = sArgs[i].slice(sArgs[i].indexOf('=')+1);</p>            break;</p>        }</p>    }</p>    return (r.length &gt; 0 ? unescape(r).split(',') : '')</p>}</p></PRE></p><p><P>This can then be used to display an error message as required ... this example presents an unordered list:</P></p><p><PRE></p>&lt;SCRIPT language="JavaScript" type="text/javascript"&gt;</p>&lt;!--</p>    r = argItems('missing');</p>    if (r.length &gt; 0) {</p>		document.writeln('&lt;B&gt;These fields require a value:&lt;/B&gt;');</p>		document.writeln('&lt;UL&gt;');</p>	    for (var i = 0; i &lt; r.length; i++) {</p>	        document.writeln('&lt;LI&gt;'+r[i]+'&lt;/LI&gt;')</p>        }</p>		document.writeln('&lt;/UL&gt;');</p>    }</p>//--&gt;</p>&lt;/SCRIPT&gt;</p>&lt;NOSCRIPT&gt;</p>&lt;B&gt;These fields require a value:&lt;/B&gt;</p>&lt;UL&gt;</p>	&lt;LI&gt;this field</p>	&lt;LI&gt;that field</p>	&lt;LI&gt;list of all fields required</p>	&lt;LI&gt;even if they did have values</p>	&lt;LI&gt;just in case they don't have javascript</p>&lt;/UL&gt;</p>&lt;/NOSCRIPT&gt;</p></PRE></p><p><H2>tests</H2></p>I have set up a page on my server with the javascripts, so you can test this:</p><UL></p><LI><A href="http://www.ironclad.net.au/testing/javascripting.html?missing=foo,bar,qaz" target="_new">missing = foo bar qaz</A><BR></p><LI><A href="http://www.ironclad.net.au/testing/javascripting.html?arg1=1&missing=me,you,them" target="_new">arg1=1&missing=me,you,them</A><BR></p><LI><A href="http://www.ironclad.net.au/testing/javascripting.html?arg1=1&missing=me,you,them&arg3=3" target="_new">arg1=1&missing=me,you,them&arg3=3</A><BR></p><LI><A href="http://www.ironclad.net.au/testing/javascripting.html?missing=me,you,them,us&arg2=2" target="_new">missing=me,you,them,us&arg2=2</A><BR></p><LI><A href="http://www.ironclad.net.au/testing/javascripting.html?missing=&arg2=" target="_new">missing=&arg2=</A><BR></p><LI><A href="http://www.ironclad.net.au/testing/javascripting.html?foo=2" target="_new">foo = 2</A><BR></p></UL></p><p></p><H2>final comments</H2></p><P>The key concept underlying this technique is the role reversal of the server sending parameters to the browser via the URL. Everything after that is just code.</P></p><P>I'm no javascript guru, so I won't be embarrassed if you find any mistakes in the above code. In fact, I'd be thankful. Also, I've not tested this on many platforms, so it might well break elsewhere. Do let me know.</P>