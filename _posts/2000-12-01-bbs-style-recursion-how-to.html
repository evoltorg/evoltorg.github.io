---
layout: post
permalink: node/3962
ratings: 2
avgrate: 3.0000
category: Code
user: Ratface
real_name: "Steve Cook"
user_biog: "Everything you ever needed to know about me can be found at <a href=\"http://www.cookstour.org\" rel=\"nofollow\" target=\"_blank\">Cookstour.org</a>."
user_since: 29 Aug 1999
avatar: "/images/pictures/picture-300.gif"
article_count: 11
excerpt: "A moderately common programming task is to write a script to create an indented, hierarchical list. It\'s something that I\'ve had to do several times and each time I\'ve forgotten the basic technique"
---
<p></p>    A moderately common programming task is to write a script to </p>    create an indented, hierarchical list. It's something that I've </p>    had to do several times and each time I've forgotten the basic technique.</p>    Having spent too many hours recently puzzling the technique out again, </p>    I thought I would write an article about it to share the message and </p>    to ensure that I have a copy of my code somewhere where I can't delete </p>    it :-)</p></p></p><p></p>    Because I've been programming in PHP a lot lately, the code is PHP and the database </p>    is mySQL, but I'll try and explain the technique so that you can implement it in </p>    your language of choice.</p></p></p><p></p>    The first thing you need is some information in a database table. </p>    I'm using a table called Categories with the following fields:</p></p></p><table border="1" cellspacing="0"></p>    <tr></p>        <td >Field</td></p>        <td >Type</td></p>        <td >Null</td></p>        <td >Key</td></p>        <td >Default</td></p>        <td >Extra</td></p>        <td >Comment</td></p>    </tr></p>    <tr></p>        <td >CatID</td></p>        <td >bigint(21)</td></p>        <td >&nbsp;</td></p>        <td >PRI</td></p>        <td >0</td></p>        <td >auto_increment</td></p>        <td >- individual key</td></p>    </tr></p>    <tr></p>        <td >CatName</td></p>        <td >varchar(32)</td></p>        <td >&nbsp;</td></p>        <td >&nbsp;</td></p>        <td >&nbsp;</td></p>        <td >&nbsp;</td></p>        <td >- Text field containing my category name</td></p>    </tr></p>    <tr></p>        <td >CatParent</td></p>        <td >bigint(21)</td></p>        <td >YES</td></p>        <td >&nbsp;</td></p>        <td >NULL</td></p>        <td >&nbsp;</td></p>        <td >- contains the CatID of the parent record, or NULL for the top level</td></p>    </tr></p></table></p><p></p>    Here's an extract of information from the table:</p></p></p><table></p>    <tr></p>        <td >CatID</td>    <td >CatName</td>    <td >CatParent</td></p>    </tr></p>    <tr></p>        <td >1</td>    <td >Developer</td>    <td >NULL</td></p>    </tr></p>    <tr></p>        <td >7</td>    <td >Tools</td>    <td >1</td></p>    </tr></p>    <tr></p>        <td >8</td>    <td >Reference</td>    <td >1</td></p>    </tr></p>    <tr></p>        <td >9</td>    <td >Tutorials</td>    <td >8</td></p>    </tr></p>    <tr></p>        <td >10</td>    <td >Docs</td>    <td >8</td></p>    </tr></p>    <tr></p>        <td >11</td>    <td >Developers</td>    <td >1</td></p>    </tr></p>    <tr></p>        <td >12</td>    <td >Hardware</td>    <td >11</td></p>    </tr></p>    <tr></p>        <td >13</td>    <td >Software</td>    <td >11</td></p>    </tr></p></table></p>Which we want to end up looking like this:</p><dl></p> <dt>Developer</p>  	<dd>Tools</p>	<dd>Reference</p> 	<dl></p> 		<dd>Tutorials</p> 		<dd>Docs</p> 	</dl></p> 	<dd>Developers</p>	<dl></p> 		<dd>Hardware</p> 		<dd>Software</p> 		<dd>Services</p> 	</dl></p> </dl></p><p></p>    Many of the scripts I have seen around to do this use a set maximum number of levels. </p>    One can then use either SQL JOINS or a set number of tables, or an extra field for </p>    depth to make the scripting simpler. In my case I don't know how deep the recursion </p>    can go, so I need to write something that will handle any level of depth. The magic </p>    word here is &quot;recursion&quot;, which basically is a technique for writing short </p>    pieces of code which keep running themselves in a controlled loop until the task at </p>    hand is completed.</p></p></p><p></p>    I'll explain the script as it goes along using PHP comments.</p></p></p><code></p><small></p><pre></p>?php</p>/*</p>    BBS_style_recursion.php</p>    Steve Cook december 2000</p>    cookie@yoyo.org / sck@biljettpoolen.se</p>    Feel free to make use of this code - I</p>    would be interested in hearing of any improvements!</p><p>    The script starts by setting up some variables, and</p>    creating the database connection.</p>*/</p>$link = mysql_connect</p>    (&quot;localhost&quot;, &quot;username&quot;,</p>     &quot;password&quot;)</p>     or die</p>    (&quot;Could not connect&quot;);</p>mysql_select_db(&quot;wapwarp&quot;);</p>/*</p>    The SELECT statement orders the results</p>    so that the categories are placed in</p>    groups with the same parent.</p>*/</p>$result = mysql_query</p>   (&quot;SELECT * FROM Categories</p>    ORDER BY CatParent, CatID ASC;&quot;)</p>    or die</p>   (&quot;Invalid query&quot;);</p>$i = 0;</p>/*</p>    The results are placed in a 2d array. In an</p>    ASP script I would keep the results in a dynamic</p>    resultset and navigate through that, but in PHP</p>    we don't have the same result structure </p>    and so we need to use an array.</p>*/</p>while ($result_row = mysql_fetch_row($result)) {</p>    $result_array[$i] = $result_row;</p>    $i++;</p>}</p>// Here we get some information from the script</p>// that we use later to initialise our recursive</p>// functions.</p>//</p>// These are our startup variables for our</p>// recursive functions... you'll see!</p><p>$parentID = $result_array[0][0];</p>$arr_size = count($result_array);</p>$depth = 1;</p>$startSeed = 1;</p>// Just a tiddly little function to print </p>// indentations in front of the results</p>function depth($depth) {</p>    for ($i=1; $i&lt;= $depth; ++$i) {</p>        print &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;;</p>    }</p>}</p><p>?&gt;</p>&lt;html&gt;</p>&lt;head&gt;</p>&lt;title&gt;BBS Style recursion&lt;/title&gt;</p>&lt;/head&gt;</p>&lt;body&gt;</p>&lt;?php</p>/*</p>    Here's where the real meat of the program starts. </p>    It's actually the second of two functions that format</p>    our results. Because functions are defined before </p>    they are called in PHP it comes first in the script.</p>    You might want to read the description of find_child first!</p><p>    Okay, step-up is called by the find_child function </p>    when it cannot find any more children in a</p>    particular branch of categories.</p>*/</p>function step_up ($parentID, $startSeed, $depth) {</p>    global $result_array;</p>    global $arr_size;</p>    // The first thing we'll check is that $start_seed </p>    // hasn't gone off the end of our result_array.</p>    // If it has, we'll stop execution of this function.</p>    if ($startSeed &gt; $arr_size) {</p>        return;</p>    } else {</p>        // if the CatParent of the last category is </p>        // equal to the CatParent of the next category</p>        // then they are on the same level. We'll move </p>        // along to it and check to see if it has children</p>        // This was why we chose to order our results by </p>        // CatParent first in our SELECT statement.</p>        if ($result_array[$startSeed-1][2] == </p>           $result_array[$startSeed][2]) {</p>              $depth--;</p>              return find_child($result_array[$startSeed-1][2],</p>                    $startSeed, $depth);</p>            </p>        // Otherwise, if the last CatParent was NULL and </p>        // the current is 1, we stop processing</p>        // as we have covered all the top level </p>        // (again, we know this thanks to our SELECT </p>        // statement ordering)</p>        } else {</p>            if ($result_array[$startSeed-1][2] == &quot;&quot; &amp;&amp; </p>                $result_array[$startSeed][2] == 1) {</p>                return;</p>            }</p>            // If they were unequal, and we haven't reached </p>            // the end of the list, we need to </p>            // climb back to this category's parent and </p>            // restart this checking process. More recursion!</p>            for ($j = 0; $j &lt;= $arr_size; ++$j) {</p>                if ($result_array[$j][0] ==</p>                  $result_array[$startSeed-1][2]) {</p>                    $depth--;</p>                    return</p>                    step_up($result_array[$j+1][0], $j+1, $depth);</p>                }</p>            }</p>            // I've forgotten what this return does, but it's</p>            // probably something important!</p>            // Best leave it there :-)</p>            return;</p>        }</p>    </p>}</p>}</p><p>/*</p>    The find_child function is the part of our recursive</p>    process that steps down the category list.</p>    It is fed the CatID of the last category we got </p>    from our results. This is the potential &quot;parent&quot;</p>    of other categories, so I have called it $parentID. It is </p>    also fed a $startSeed, which is the position of the current</p>    result we are looking at in $result_array. There's also a </p>    $depth variable which is used for formatting purposes.</p>*/</p>function find_child ($parentID, $startSeed, $depth) {</p>    global $result_array;</p>    global $arr_size;</p>    // This for loop starts us where we left off in </p>    // $result_array and steps through the results.</p>    for ($k = $startSeed; $k &lt;= $arr_size; ++$k) {</p>        // If we find a result where the catParent is </p>        // equal to the CatID of our current result</p>        // then we've found a child.</p>        if ($result_array[$k][2] == $parentID) {</p>            // We can then do whatever we need to do</p>            // with our category.</p>            // In this case we'll print it out with some</p>            // depth formatting.</p>            depth($depth);    </p>            print ($result_array[$k][1] . &quot;&lt;br&gt;</p>&quot;);</p>            // then we need to reset our startup variables - our </p>            // current result could now be a parent itself.</p>            $parentID = $result_array[$k][0];</p>            $startSeed = ++$k;</p>            $depth++;</p>            // Finally we recall find_child with our new values</p>            // to see if this category contains sub-categories.</p>            // This is recursion at work!</p>            return find_child($parentID, $startSeed, $depth);</p>            </p>        } elseif ($result_array[$k][2] &gt; $parentID) {</p>            // Simply a little code to save some processing time.</p>            // We'll break out of the loop if we've gone</p>            // past the parent value</p>            break;    </p>        }</p>    }</p>    /*</p>    If we didn't find a child, then we've gone as far down </p>    this particular branch of categories as we can.</p>    We need to keep our startup variables the same and </p>    use our second function - step_up to either find</p>    further results on the same level, or to take us </p>    back up the category tree.</p>    */</p>    </p>    step_up ($parentID, $startSeed, $depth);</p>}</p>/*</p>    Okay, we've defined all our recursive functions, all </p>    we need to do now is print the first category</p>    which we got from the results right at the beginning </p>    and then kick the whole operation into action.</p>    With any luck, it should run all the way through </p>    the results, finding it's way down the lists of categories</p>    and climbing back up again to start down new branches </p>    until it reaches the end of the results list.</p>*/</p>print $result_array[0][1] . &quot;&lt;br&gt;</p>&quot;;</p>find_child($parentID, $startSeed, $depth);</p><p>?&gt;</p><p>&lt;/body&gt;</p>&lt;/html&gt;</p></pre></p></small></p></code>