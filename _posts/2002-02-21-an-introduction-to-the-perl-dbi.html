---
layout: post
permalink: node/21534
ratings: 6
avgrate: 4.0000
category: Code
user: gsampson
real_name: "Greg Sampson"
user_biog: ""
user_since: 02 Mar 2001
avatar: 
article_count: 1
excerpt: "Even though the Perl DBI has the ability to work well with the most complex development projects, it\'s easy enough to learn in time for your next Web administration crisis as well."
---
<h2>Introduction</h2></p><p><p><acronym title="Database Independent">DBI</acronym> is a Perl module that makes it possible to use Perl to access</p>many different types of databases though a single API that works</p>independently of the actual database being used. This means that the</p>programmer is able to use the DBI module (Database Independent) to</p>talk to a MySQL database, a DB2 database, an Oracle database, and many</p>others using the same DBI-specific variables and function</p>calls. Although there are also many functions built into the DBI for</p>specific database engines, the core functionality is always the</p>same. This functionality makes DBI a very powerful programming tool,</p>but after a brief introduction, you will notice that the DBI is also</p>very accessible and easy to understand; programmers require knowledge</p>of only a few key features to get started writing scripts to perform</p>any number of database tasks.</p></p><p><h2>How it All Works</h2></p><p><p>There are three tiers within every Perl DBI application. The first</p>layer is the Perl script itself, which uses the DBI Application</p>Program Interface (the objects, functions and variables predefined by</p>the DBI) to interact with the database. The middle layer is the DBI,</p>whose main responsibility is to pass those DBI-specific instructions</p>to the appropriate database driver. The third layer is the <acronym title="Database Dependent">DBD</acronym></p>(Database Dependent) layer, which is the driver for the specific</p>database engine you are using.</p></p><p><h2>Example: The Postcard Application</h2></p><p><p>Let's say I have a collection of postcards, and in order to keep</p>them organized, I have entered information about them into a MySQL</p>database. Then let's say that I want to show those postcards off to</p>visitors to my website. Because I have only CGI available on my web</p>server, I decide the best way to do that is through a CGI</p>application. I start out my application like this:</p></p><p><pre></p>#!/usr/bin/perl -w</p><p>use CGI("standard");</p>use DBI;</p></pre></p><p><p>This bit of code first specifies this as a Perl script. Then it makes</p>the Perl CGI module available (this module automates some HTML writing</p>and means less typing). The last line makes available the DBI module.</p></p><p><p>My next step is to define some variables for the database and</p>connect to it:</p></p><p><pre></p>my $datasource = "DBI:mysql:postcards:localhost";</p>my $user = "greg"</p>my $passwd = "greatpostcards";</p></pre></p><p><p>If you have ever written any sort of application that has a</p>database interface, this information should look familiar to</p>you. However, note that the syntax of the <code>$datasource</code></p>variable is a bit unique. The pattern, which seems at first to be</p>counter-intuitive, works like this: <code>DBI:[DBD driver]:[database name]:[database host]</code>.</p></p><p><p>Remember that DBI applications are designed to easily talk to many</p>different types of databases. Specifying the type of database you</p>want to use in your application is as easy as changing a single part</p>of the string held in the <code>$datasource</code> variable. So, now that all of</p>my connection information has been defined, my next step is to</p>create a connection object. That's as easy as adding the following to my</p>application: <code>my $dbh = DBI->connect($datasource,$user,$passwd);</code>.</p></p><p><p>The string contained in the <code>$datasource</code> variable is</p>saying, &quot;hey, DBI! Use the mysql database dependent module to</p>access the postcards database that exists on the computer named</p>localhost.&quot;</p></p><p><p>Now that I have defined my connection object, my next step is to</p>prepare an SQL statement. I can do that by using the (you guessed it)</p>prepare method:</p></p><p><pre></p>my $sth = $dbh->prepare("SELECT postcard.*,</p>                         location.*</p>                         sender.*</p>                         FROM postcard</p>                         LEFT JOIN location ON postcard.location_id = location.location_id,</p>                         LEFT JOIN sender ON postcard.sender_id = sender.sender_id</p>                         WHERE postcard.pc_id = ?;");</p></pre></p><p><p>Now, with the SQL statement prepared, my next step is to execute</p>it. We do that by employing the execute method: <code>$sth->execute($dynamicvariable);</code></p><p><p>Everything might seem pretty clear in these two lines, except you</p>might notice the question mark in the SQL statement and the</p><code>$dynamicvariable</code> we pass to it when we invoke the execute method. This</p>is a feature of the Perl DBI, which allows me to pass any number of</p>variables to my SQL statement before it is executed. The value of</p>these variables then fits into the question mark placeholders, in</p>the order they are passed. (So I should be sure that the variables I pass go</p>in the right order!) If my application does not require me to</p>pass dynamic values to my SQL statement, I would have simply called the</p>execute method without any parentheses, like this: <code>$sth->execute;</code></p></p><p><p>Now, for the final step in my application, I need a way of</p>getting at the contents of the record set that the execute method</p>returns. As is always the way with Perl, there are a billion different</p>ways of doing this. But since I'm dealing with rows of data, the</p><code>fetchrow_array</code> works well, because it allows me to loop through the</p>returned row as an array.</p></p><p><pre></p>my @array = $sth->fetchrow_array;</p>my $i;</p>for $i (0..$#array) {</p>    print $array[$i],"</p>";</p>}</p></pre></p><p><p>As I have already mentioned, I have many other DBI</p>functions at my disposal at this point. The</p><code>fetchrow_arrayref</code> will return the database row as an</p>array reference. The <code>fetchrow_hashref</code> will return it as a</p>hash reference (this is especially handy if you have a lot of rows and</p>you want to key them up by their column names; if you're like me, you tend to</p>remember names better than numeric values). And there are many</p>others. Be sure to read the documentation to find the function that</p>most suits your needs and programming behaviors.</p></p><p><p>My next step is to clean up my program. Though clearing memory and</p>closing database connections is not always necessary, it is good</p>programming practice (not to mention easy to do). So I recommend</p>it. Here's all you have to do:</p></p><p><pre></p>$sth->finish;</p>$dbh->disconnect;</p></pre></p><p><p>Once that's done, I'm done with my postcard</p>application. But beyond the simple API demonstrated by the code</p>snippets above, it may not be exactly clear why the Perl DBI is</p>valuable. Here are some benefits I have found.</p></p><p><h2>Why You Might Care About This</h2></p><p></p><ul></p><li>Ubiquity: The Perl DBI module is included with the default</p>install of any relatively new version of Perl. So if you have access</p>to a UNIX-based system, you should be able to start programming the</p>Perl DBI.</li></p><p><li>Easy Integration: Because it's a Perl module, database functionality</p>can be easily integrated into existing Perl/CGI applications.</li></p><p><li>Simplicity and Power: being able to talk to a wide variety of</p>databases with Perl (and even within a single Perl script) makes</p>massive exports and/or imports of data even much more manageable</p>(anyone who has had the job of upgrading a corporate RDBMS can see the</p>value in this, I'm sure).</li></p></ul></p><p><h2>Further Reading and DBI Resources</h2></p><p><p>You can start your search for Perl DBI information just about anywhere</p>on the web. There is the <a href="http://www.cpan.org/" target="_blank" title="Comprehensive Perl Archive Network">Database Interfaces section of the CPAN website</a>, there are <a href="http://groups.google.com/groups?hl=en&group=comp.lang.perl" target="_blank" title="Perl-oriented news groups at groups.google.com">Perl-oriented</p>newsgroups</a>. However, the best places to</p>start reading about Perl DBI is either by checking out <a href="http://dbi.symbolstone.org/index.html" target="_blank" title="Symbolstone: everything you want to know about DBI">Symbolstone</a>,</p>the central resource for Perl DBI and DBD modules and documentation on</p>the Web, or else just running the <code>perldoc DBI</code> command at your local</p>UNIX prompt. Generally the information is accessible and easy to understand, and</p>will help you further as you get started.</p></p><p><h2>Conclusion</h2></p><p><p>Notwithstanding all of the pitfalls and shortcomings of Perl</p>programming generally, the power, simplicity, and accessibility of the Perl DBI</p>make it worth understanding. And even though it has the ability to</p>work well with the most complex development projects, it's easy</p>enough to learn in time for your next Web administration crisis as well.</p>