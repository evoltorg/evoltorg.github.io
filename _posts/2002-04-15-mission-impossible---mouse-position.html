---
layout: post
permalink: node/23335
ratings: 19
avgrate: 4.5789
user: ppk
real_name: "Peter-Paul Koch"
user_since: 12 Sep 1999
avatar: "/images/pictures/picture-380.jpg"
article_count: 8
excerpt: "A cross-browser script for finding the mouse coordinates during an event must necessarily use a browser detect, something I truly loathe. The problem is, believe it or not, that Explorer correctly follows the standard."
---
<p>At the moment I am writing an</p><a href="http://www.xs4all.nl/~ppk/js/index.html?introevents.html"</p>	title="To my JavaScript Section"</p>	target="_blank">Introduction to Events</a>.</p>As part of my study I wanted to create a generic, simple script that detects the mouse coordinates at</p>the time of the event. Because such a script <strong>can</strong> work in</p><a href="http://home.netscape.com/computing/download/index.html?cp=hophb2"</p>	title="Download Netscape 6"</p>	target="ppk">Netscape</a>,</p><a href="http://www.microsoft.com/windows/ie/downloads/ie6/default.asp"</p>	title="Download Explorer 6"</p>	target="ppk">Explorer</a>,</p><a href="http://www.opera.com"</p>	title="Event handling improved dramatically between 5 and 6"</p>	target="ppk">Opera</a>,</p><a href="http://www.konqueror.org"</p>	title="An excellent, very standard conforming Linux browser"</p>	target="ppk">Konqueror</a> and</p><a href="http://www.icab.de"</p>	title="A good standard conforming Mac browser"</p>	target="ppk">iCab</a>, it <strong>should</strong> work in all these browsers.</p></p><p><p>But I failed. In fact the situation is so bad that I have reluctantly come to the conclusion that</p>a cross&#8211;browser script for finding the mouse coordinates during an event</p>must necessarily use a browser detect, something I truly loathe.</p></p><p><p>The problem is, believe it or not, that Explorer</p>correctly follows the standard &#8212; or rather that</p>Opera, Konqueror and iCab have <em>en masse</em> decided</p>not to follow the standard &#8212; or maybe that the standard is in fact not the</p>standard.</p></p><p><p>Detecting the mouse coordinates became such a complex matter, and the story</p>contains such fundamental lessons about standardization, that I wrote this article.</p></p><p><h3>In search of a reference point</h3></p><p><p>But let&#8217;s begin at the beginning. We are looking for mouse coordinates.</p></p><p><p>The main question is &#8220;mouse coordinates relative to what?&#8221;</p>If a mouse coordinate property has a value of 300 this always means &#8220;300 pixels</p>from my reference point&#8221;, but it doesn&#8217;t tell us what this reference</p>point is.</p></p><p><p>So first we have to decide which reference point we need and then search the properties to</p>match from the six available pairs (see also my</p><a href="http://www.xs4all.nl/~ppk/js/index.html?events_compinfo.html"</p>	title="To my JavaScript Section"</p>	target="_blank">compatibility table</a>).</p></p><p></p><p>Please note the difference between document and window. The window is the &#8220;viewport&#8221;</p>the user has available to view the document in. The document is frequently far longer than the window; in that</p>case we scroll it to get another portion of the document into our viewport.</p></p><p><pre></p>  ---------------------</p>    Start of document  </p>-------------------------</p>    X                    </p>                         </p> &lt;--- Browser window --&gt; </p>                         </p>-------------------------</p>                       </p>     End of document   </p>  ---------------------</p></pre></p><p><p>For example, the coordinates of the <strong>X</strong> relative to the window would be 10,10</p>while its coordinates relative to the document would be 10,100.</p><p><p>What we need are the mouse coordinates <strong>relative to the document</strong> because we often</p>want to place some kind of DHTML layer on or just next to the mouse position. DHTML layers</p>also calculate their position relative to document.</p>If we can find the mouse coordinates relative to the document we can immediately paste them into the</p><code>top</code> and <code>left</code> properties of the DHTML layer we wish to move, avoiding</p>all kinds of trouble.</p></p><p><p>So where can we find these mouse coordinates relative to the document?</p></p><p><h3>DOM implementation&#8217;s client area</h3></p><p><p>The</p><a href="http://www.w3.org/TR/2002/WD-DOM-Level-3-Events-20020208/events.html#Events-eventgroupings-mouseevents"</p>	target="_blank">W3C DOM Level 2 Events standard</a></p>specifies two property pairs for mouse coordinates: <code>screenX/Y</code>, the mouse</p>coordinates relative to the entire computer screen, and <code>clientX/Y</code>, which are defined</p>as</p></p><p><p title="W3C specification of clientX and clientY"</p>	>&#8220;the horizontal/vertical coordinate at which the event occurred relative to the DOM implementation&#8217;s client area.&#8221;</p></p></p><p><p>Now what, one wonders, is the &#8220;DOM implementation&#8217;s client area&#8221;?</p>Because both Netscape 6 and Explorer define <code>clientX/Y</code> as the mouse coordinates</p>relative to the window, it is commonly translated as <strong>window</strong>.</p></p><p><p>This means that to obtain the mouse position relative to the document</p>we have to add the values of some unstandardized, browser specific scrolling offset properties to the</p>coordinates relative to the window <code>clientX/Y</code> give us.</p>Thus there is <strong>no standards compatible way</strong> to find this information.</p>So far so bad, though it can be worked around.</p></p><p><h3>The minor browsers</h3></p><p><p>But it gets worse. Opera, Konqueror and iCab define <code>clientX/Y</code> as the mouse</p>coordinates relative to the <strong>document</strong>, not to the window. So three important minor browsers</p>disagree with Netscape 6 and Explorer and even with W3C, though all three have a good name for</p>standards compliance.</p></p><p><p>We don&#8217;t see such incompatibilities often because the minor browsers can&#8217;t</p>afford them. Although Netscape/Explorer code branching has been common for many years,</p>few web developers would bother to write special code branches for the minor browsers.</p>If a certain method or property is supported by a minor browser it must</p>be <strong>exactly</strong> equal to the Microsoft property of Explorer or the W3C property of Netscape 6.</p>Incompatibility with both of the big ones means that neither code branch will work and</p>that scripts will not function correctly.</p>Thus incompatibility is uncommon, usually caused by a bug.</p></p><p><p>But now <strong>three</strong> of them disagree with <strong>both</strong> big ones in the <strong>same</strong> way.</p>This is a rare sight, so rare in fact, that we should sit up and take notice. Might they have a point?</p>It is clear that their implementation of <code>clientX/Y</code> would greatly benefit</p>web developers, if it were truly cross&#8211;browser.</p></p><p><h3>Browser incompatibility</h3></p><p><p>But it isn&#8217;t cross&#8211;browser, and in fact our chance at a properly written cross&#8211;browser script</p>is destroyed. As we&#8217;ve seen Netscape 6 and Explorer support <code>clientX/Y</code> according to the standard:</p>the properties contain the mouse coordinates relative to the <strong>window</strong>.</p></p><p><p>Netscape fortunately stores the coordinates relative to the document in another</p>(non&#8211;standard) property pair,</p>so we can avoid using <code>clientX/Y</code>. Again we see that browser vendors</p>are willing to help us find the mouse position relative to the document.</p></p><p><p>That leaves Explorer as the single browser that does not give us the information we need,</p>as the single browser for which we must follow the W3C specification to the last</p>dot and comma. Yet another rare sight.</p></p><p><h3>The standards are not the standards?</h3></p><p><p>Or do we all misunderstand the standard and should &#8220;DOM implementation&#8217;s client area&#8221;</p>be translated as <strong>document</strong>? That would be a blessing to web developers &#8212; and restore</p>the natural order of standards compliance in browser&#8211;land.</p></p><p><p>But if the standard means <strong>document</strong> it hides this fact very carefully.</p>On the other hand, if it means <strong>window</strong> it is pretty vague, too.</p>And we all know what happens when standards are vague. Browser</p>vendors create their own standards. That&#8217;s what has happened here.</p></p><p><p>So let&#8217;s go down the sewer for some dirty fixes.</p></p><p><h3>pageX, pageY</h3></p><p><p>The old Netscape event model contains the <code>pageX/Y</code> property pair, which gives the mouse coordinates</p>relative to the entire document. Since this is exactly the information we&#8217;re looking for,</p>we try to apply these properties.</p></p><p><p><code>pageX/Y</code> is supported by Netscape 4 and 6 and sometimes by iCab. So for the benefit</p>of these browsers we start up a bit of</p><a href="http://www.xs4all.nl/~ppk/js/index.html?support.html"</p>	title="My explanation of this important principle"</p>	target="_blank">object detection</a>.</p>Does the browser actually support these</p>properties? If so, use them.</p></p><p><pre></p>function doSomething(e)</p>{</p>	var posx = 0;</p>	var posy = 0;</p>	if (!e) var e = window.event;</p>	if (e.pageX    e.pageY)</p>	{</p>		posx = e.pageX;</p>		posy = e.pageY;</p>	}</p>	...</p></pre></p><p><p>Not only have we made our script Netscape 4 compatible, we have also neatly evaded the <code>clientX/Y</code></p>problem in Netscape 6.</p></p><p><h3>clientX, clientY</h3></p><p><p>If the browser doesn&#8217;t support <code>pageX/Y</code> we have to use <code>clientX/Y</code>.</p>If your page does not need to scroll you can ignore all compatibility questions.</p>After all when the page hasn&#8217;t scrolled the coordinates relative to the window are the same as</p>those relative to the document.</p></p><p><p>You just do</p></p><p><pre></p>	...</p>	else if (e.clientX    e.clientY)</p>	{</p>		posx = e.clientX;</p>		posy = e.clientY;</p>	}</p>	// posx and posy contain the mouse position relative to the document</p>	// Do something with this information</p>}</p></pre></p><p><p>and you&#8217;re ready.</p></p><p><h3>Browser detect</h3></p><p><p>However, if the page can scroll we have some very serious problems. There are two options.</p></p><p><ol></p><li>If <code>clientX/Y</code> contain the coordinates relative to the document, we read them out and</p>are ready.</li></p><li>If <code>clientX/Y</code> contain the coordinates relative to the window, we read them out, add the scrolling</p>offset of the page and are ready.</li></p></ol></p><p><p>But how do we know which of these two options we have to use?</p>I studied the remaining four property pairs to see if they offer a way out, but they</p>don&#8217;t. I looked at the problem from a theoretical point of view: is it possible to ascertain the</p>meaning of <code>clientX/Y</code> by reading out some screen properties like scrolling offset</p>and window height and performing complex calculations? No go.</p></p><p></p><p>Therefore I&#8217;m forced to use a browser detect. I loathe it, but there is no other way.</p>So let&#8217;s hold our noses and do it.</p></p><p><pre></p>var isOpera = (navigator.userAgent.indexOf('Opera') != -1);</p>var isIE = (!isOpera && navigator.userAgent.indexOf('MSIE') != -1)</p></pre></p><p><p>Remember that Opera can try to disguise itself as Explorer, which would be fatal to this script.</p>Therefore we have to check for Opera first. Konqueror and iCab</p>can disguise themselves too, by the way, but when they do they completely switch identity and are undetectable.</p>Too Bad, cannot be helped.</p></p><p><p>Now we do</p></p><p><pre></p>	...</p>	else if (e.clientX    e.clientY)</p>	{</p>		posx = e.clientX;</p>		posy = e.clientY;</p>		if (isIE)</p>		{</p>			posx += document.body.scrollLeft;</p>			posy += document.body.scrollTop;</p>		}</p>	}</p>	// posx and posy contain</p>	// the mouse position relative to the document</p>	// Do something with this information</p>}</p></pre></p><p><p>and the script works, for the moment.</p></p><p><p>(Note that if you use a DOCTYPE in Explorer 6, you may have to search for <code>scrollTop</code></p>in <code>document.documentElement</code> instead of <code>document.body</code>. I&#8217;m not yet</p>sure of the details of this problem and in any case they are beyond the scope of this</p>article.)</p></p><p><h3>Drawbacks of a browser detect</h3></p><p><p>This script is an interesting example of the drawbacks of browser detection as a regular programming</p>technique. At the moment our dirty fix works fine for undisguised Explorer, Opera, Konqueror</p>and iCab browsers, sure. But what about the future?</p></p><p><p>If <strong>any</strong> of the four browsers changes its <code>clientX/Y</code> implementation</p>the script doesn&#8217;t work correctly any more &#8212; and if Explorer switched it would</p>be downright disastrous.</p></p><p><p>You could of course rewrite your browser detect, but do you remember <strong>every single</p>page</strong> you used the script on? And how about earlier versions of the browser that has changed?</p>You&#8217;d have to write some more code to correctly draw the line between standard&#8211;compatible and</p>non&#8211;standard&#8211;compatible versions. And would these versions be the same on all operating</p>systems?</p></p><p><p>For such reasons I detest the impossible situation W3C&#8217;s vagueness and</p>the browser vendors&#8217; well&#8211;meaning but untimely intervention have created.</p>I want to keep my code clean, but thanks to the mishandling of <code>clientX/Y</code></p>I have no choice but to accept the ugly <code>navigator.userAgent</code> mess.</p></p><p><p>The <code>clientX/Y</code> confusion is a blot on the otherwise excellent DOM Level 2 Events</p>spec. Let&#8217;s hope for a speedy solution.</p>