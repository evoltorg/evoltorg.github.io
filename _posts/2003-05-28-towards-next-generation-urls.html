---
layout: post
permalink: node/60159
ratings: 25
avgrate: 4.2000
category: Site Development
user: port80
real_name: "Joe Lima & Thomas Powell"
user_biog: "<p>Thomas Powell is founder of PINT, Inc. and a lecturer in the Computer Science department at University of California San Diego.  His articles have appeared in serveral magazines and sites, including <i>Network World</i>, <i>Internet Week</i> and <i>ZDNet</i>. He has also published numerous books on Web technology and design, including the best-selling <i>Web Design: The Complete Reference</i>. Visit <a href=\"http://www.pint.com\" rel=\"nofollow\" target=\"_blank\">pint.com</a>.</p> 

<p>Joe Lima is the Director of Product Development for Port80 Software.  He has worked for a variety of Internet, wireless and software development companies, specializing in research and development for server-centric technologies. Visit <a href=\"http://www.port80software.com\" rel=\"nofollow\">port80software.com</a>.</p>"
user_since: 21 May 2003
avatar: 
article_count: 2
excerpt: "For many years we have heard about the impending death of URLs that are difficult to type, remember and preserve. The use of URLs has actually improved little thus far, but changes are afoot in both development practices and Web server technology that should help advance URLs to the next g..."
---
<p></p>For many years we have heard about the impending death of URLs that are difficult to type, remember and preserve. The use of URLs has actually improved little thus far, but changes are afoot in both development practices and Web server technology that should help advance URLs to the next generation.</p></p></p><p><h2>Dirty URLs</h2></p>	</p><p></p>Complex, hard-to-read URLs are often dubbed dirty URLs because they tend to be littered with punctuation and identifiers that are at best irrelevant to the ordinary user. URLs such as <code>http://www.example.com/cgi-bin/gen.pl?id=4&view=basic</code> are commonplace in today's dynamic Web.  Unfortunately, dirty URLs have a variety of troubling aspects, including:</p></p></p><p></p><h3>Dirty URLs are difficult to type.</h3></p><p><p></p>The length, use of punctuation, and complexity of these URLs makes typos commonplace.</p></p></p><p></p><h3>Dirty URLs do not promote usability.</h3></p><p><p></p>Because dirty URLs are long and complex, they are difficult to repeat or remember and provide few clues for average users as to what a particular resource actually contains or the function it performs.</p></p></p><p></p><h3>Dirty URLs are a security risk.</h3></p><p><p></p>The query string which follows the question mark (?) in a dirty URL is often modified by hackers in an attempt to perform a front door attack into a Web application. The very file extensions used in complex URLs such as .asp, .jsp, .pl, and so on also give away valuable information about the implementation of a dynamic Web site that a potential hacker may utilize.</p></p></p><p></p><p><h3>Dirty URLs impede abstraction and maintainability.</h3></p><p><p></p>Because dirty URLs generally expose the technology used (via the file extension) and the parameters used (via the query string), they do not promote abstraction.  Instead of hiding such implementation details, dirty URLs expose the underlying &quot;wiring&quot; of a site.  As a result, changing from one technology to another is a difficult and painful process filled with the potential for broken links and numerous required redirects.</p></p></p><p></p><p></p><p><h2>Why Use Dirty URLs?</h2></p><p><p></p>Given the numerous problems with dirty URLs, one might wonder why they are used at all.  The most obvious reason is simply convention -- using them has been, and so far still is, an accepted practice in Web development.  This fact aside, dirty URLs do have a few real benefits, including:</p></p></p><p></p><h3>They are portable.</h3></p><p><p></p>A dirty URL generally contains all the information necessary to reconstruct a particular dynamic query.  For example, consider how a query for "web server software" appears in Google &#8212; <code>http://www.google.com/search?hl=en&ie=UTF-8&oe=UTF-8&q=Web+server+software</code>.  Given this URL, you can rerun the query at any time in the future.  Though difficult to type, it is easily bookmarked.</p></p></p><p></p><p><h3>They can discourage unwanted reuse.</h3></p><p><p></p>The negative aspects of a dirty URL can be regarded as positive when the intent is to discourage the user from typing a URL, remembering it, or saving it as a bookmark.  The intimidating look and length of a dirty URL can be a signal to both user and search engine to stay away from a page that is bound to change.  This is often simply a welcome side effect, rather than a conscious access control policy &#8212; frequently nothing is done to prevent actual use of the URL by means of session variables or referring URL checks.</p></p></p><p></p><p><h2>Cleaning URLs</h2>	</p><p><p></p>The disadvantages of dirty URLs far outweigh their advantages in most situations. If the last 30 or 40 years of software development history are any indication of where development for the Web is headed, abstraction and data hiding will inevitably increase as Web sites and applications continue to grow in complexity.  Thus, Web developers should work toward cleaner URLs by using the following techniques:</p></p></p><p></p><h3>Keep them short and sweet.</h3></p><p><p></p>The first path to better URLs is to design them properly from the start.  Try to make the site directories and file names short but meaningful.  Obviously, <code>/products</code> is better than <code>/p</code>, but resist the urge to get too descriptive.  Having <code>www.xyz.com/productcatalog</code> doesn't add much meaning (if a user looks for a product catalog, they might well expect to find it at or near the top-level products page), but it does needlessly restrict what the page can reasonably contain in the future.  It's also harder to remember or guess at.  Shoot for the shortest identifiers consistent with a <em>general</em> description of the page's (or directory's) contents or function.</p></p></p><p></p><h3>Avoid punctuation in file names.</h3></p><p><p></p>Often designers use names like <code>product_spec_sheet.html</code> or <code>product-spec-sheet.html</code>.  The underscore is often difficult to notice and type, and these connectors are usually a sign of a carelessly designed site structure. They are only required because the last rule wasn't followed.</p></p></p><p></p><h3>Use lower case and try to address case sensitivity issues.</h3></p><p><p></p>Given the last tip, you might instead name a file <code>ProductSpecSheet.html</code>.  However, casing in URLs is troubling because depending on the Web server's operating system, file names and directories may or may not be case sensitive.  For example, <code>http://ww.xyz.com/Products.html</code> and <code>http://www.xyz.com/products.html</code> are two different files on a UNIX system but the same file on a Windows system.  Add to this the fact that <code>www.xyz.com</code> and <code>WWW.XYZ.COM</code> are always the same domain, and the potential for confusion becomes apparent.  The best solution is to make all file and directory names lowercase by default and, in a case sensitive server operating environment, to ensure that URLs will be correctly processed no matter what casing is used.  This is not easy to do under Apache on Unix/Linux systems (<a href="http://httpd.apache.org/docs/misc/FAQ-H.html#rewrite-nocase" target="_blank" title="Opens in new window.">related info</a>), although URL rewriting and spellchecking can help (discussed below).</p></p></p><p></p><h3>Do not expose technology via directory names.</h3></p><p><p></p>Directory names commonly or easily associated with a given server-side technology unnecessarily disclose implementation details and discourage permanent URLs. More generic paths should be used.  For example, instead of <code>/cgi-bin</code>, use a <code>/scripts</code> directory, instead of <code>/css</code>, use <code>/styles</code>, instead of <code>/javascript</code>, use <code>/scripts</code>, and so on.</p></p></p><p></p><h3>Plan for host name typos.</h3></p><p><p></p>The reality of end user navigation is that around half of all site traffic is from direct type or bookmarked access.  If users want to go to Amazon's web site, they know to type in <code>www.amazon.com</code>.   However, accidentally typing <a href="http://ww.amazon.com" target="_blank" title="Opens in a new window.">ww.amazon.com</a> or <a href="http://wwww.amazon.com" target="_blank" title="Opens in a new window.">wwww.amazon.com</a> is fairly easy if a user is in a hurry.  Adding a few entries to a site's domain name service to map <code>w</code>, <code>ww</code>, and <code>wwww</code> to the main site, as well as the common <code>www.site.com</code> and <code>site.com</code>, is well worth the few minutes required to set them up.</p></p></p><p></p><p><h3>Plan for domain name typos.</h3></p><p><p></p>If possible, secure common &quot;fat finger&quot; typos of domain names.  Given the proximity of the &quot;z&quot; and &quot;x&quot; keys on a standard computer QWERTY keyboard, it is no wonder Amazon also has contingency domains like <a href="http://www.amaxon.com" target="_blank" title="Opens in a new window.">amaxon.com</a>.  Google allows for such variations as <a href="http://www.gooogle.com" target="_blank" title="opens in a new window.">gooogle.com</a> and <a href="http://www.gogle.com" target="_blank" title="Opens in a new window.">gogle.com</a>.  Unfortunately, many Web traffic aggregators will purchase the typo domains for common sites, but most organizations should find some of their typo domains readily available.   Organizations with names that are difficult to spell, like &quot;Ximed,&quot; might want to have related domains like &quot;Zimed&quot; or &quot;Zymed&quot; for users who know the name of the organization but not the correct spelling.  The particular domains needed for a company should reveal themselves during the course of regular offline correspondence with customers.</p></p></p><p></p><h3>Support multiple domain forms.</h3></p><p><p></p>If an organization has many forms to its name, such as International Business Machines and IBM, it is wise to register both forms.  Some companies will register their legal form as well, so XYZ, LLC or ABC, Inc. might register <code>xyzllc.com</code> and <code>abcinc.com</code> as well as primary domains. While it seems like a significant investment, if you use one of the new breed of low-cost registrars (like <a href="http://www.itsyourdomain.com" target="_blank" title="Opens in a new window.">itsyourdomain.com</a>), the price per year for numerous domains for a site is quite reasonable. Given alternate domain extensions like .net, .org, .biz and so on, the question begs -- where to stop?  Anecdotally, the benefits are significantly reduced with new alternate domain forms (like .biz, .cc, and so on), so it is better to stick  with the common domain form (.com) and any regional domains that are appropriate (e.g. co.uk).</p></p></p><p></p><h3>Add guessable entry point URLs.</h3></p><p><p></p>Since users guess domain names, it is not a stretch for users -- particularly power users -- to guess directory paths in URLs.  For example, a user trying to find information about Microsoft Word might type <a href="http://www.microsoft.com/word" target="_blank" title="Opens in a new window.">http://www.microsoft.com/word</a>.  Mapping multiple URLs to common guessable site entry points is fairly easy to do. Many sites have already begun to create a variety of synonym URLs for sections.  For example, to access the careers section of the site, the canonical URL might be <code>http://www.xyz.com/careers</code>.  However, adding in URLs like <code>http://www.xyz.com/career</code>, <code>http://www.xyz.com/jobs</code>, or <code>http://www.xyz.com/hr</code> is easy and vastly improves the chances that the user will hit the target.  You could even go so far as to add hostname remapping so that <code>http://investor.xyz.com</code>, <code>http://ir.xyz.com</code>, <code>http://investors.xyz.com</code>, and so on all go to <code>http://www.xyz.com/investor</code>.  The effort made to think about URLs in this fashion not only improves their usability, but should also promote long term maintainability by encouraging the modularization of site information.</p></p></p><p></p><h3>Where possible, remove query strings by pre-generating dynamic pages.</h3></p><p><p></p>Often, complex URLs like <code>http://www.xyz.com/press/releasedetail.asp?pressid=5</code> result from an inappropriate use of dynamic pages.  Many developers use server-side scripting technologies like ASP/ASP.NET, ColdFusion, PHP, and so on to generate &quot;dynamic&quot; pages which are actually static.  For example in the previous URL, the ASP script drills press release content out of a database using a primary key of <em>5</em> and generates a page.  However, in nearly all cases, this type of page is static both in content and presentation.  The generation of the page dynamically at user view time wastes precious server resources, slows the page down, and adds unnecessary complexity to the URL.   Some dynamic caches and content distribution networks will alleviate the performance penalty here, but the unnecessarily complex URLs remain.  It is easy to directly pre-generate a page to its static form and clean its URL.  Thus, <code>http://www.xyz.com/press/releasedetail.asp?pressid=5</code> might become <code>www.xyz.com/press/pressrelease5</code> or something much more descriptive like <code>http://www.xyz.com/press/03-02-2003</code> -- or even better like <code>http://www.xyz.com/press/newproduct</code>.  The issue of when to generate a page, either at request time or beforehand, is not much different than the question of whether a program should be interpreted or compiled.</p></p></p><p></p><p><h3><a name="rewriting"></a>Rewrite query strings.</h3></p><p><p></p>In the cases where pages should be dynamic, it is still possible to clean up their query strings. Simple cleaning usually remaps the <em>?</em>, <em>&</em>, and <em>+</em> symbols in a URL to more readily typeable characters.  Thus, a URL like <code>http://www.xyz.com/presssearch.asp?key=New+Robot&year=2003&view=print</code>  might become something like <code>http://www.xyz.com/pressearch.asp/key/New-Robot/year/2003/view/print</code>.  While this makes the page &quot;look&quot; static, it is indeed still dynamic.  The look of the URL is a little less intimidating  to users and may be more search engine friendly as well (search engines have been known to halt at the <em>?</em> character).  In conjunction with the next tip, this might even discourage URL parameter manipulation by potential site hackers who can't tell the difference between a dynamic page and a static one.  The challenge with URL rewriting is that it takes some significant planning to do well, and the primary tools used for these purposes -- rule-based URL rewriters like <a href="http://www.apacheref.com/ref/mod_rewrite.html" target="_blank" title="Opens in a new window.">mod_rewrite for Apache</a> and <a href="http://www.isapirewrite.com" target="_blank" title="Opens in a new window.">ISAPI Rewrite for IIS</a> -- have daunting rule syntax for developers unseasoned in the use of regular expressions.  However, the effort to learn how to use these tools properly is well worth it.</p></p></p><p></p><p><h3>Remove extensions from files in URL and source.</h3></p><p><p></p>Probably the most interesting URL improvement that can be made involves the concept of content negotiation.  <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html" target="_blank" title="Opens in a new window.">Despite being a long-supported HTTP specification</a>, content negotiation is rarely used on the Web today.  The basic idea of content negotiation is that the browser transmits information about the resources it wants or can accept (MIME types preferred, language used, character encodings supported, etc.) to the server, and this information is then used, along with server configuration choices,  to dynamically determine the actual content and format that should be transmitted back to the browser.  Metaphorically, the browser and the server hold a negotiation over which of the available representations of a given resource is the best one to deliver, given the preferences of each side.  What this means is that a user can request a URL like <code>http://www.xyz.com/products</code>, and the language of the content returned can be determined automatically -- resulting in the content being delivered from either a file like <code>products-en.html</code> for English speaking users or one like <code>products-es.html</code> for Spanish speakers.  Technology choices such as file format (PNG or GIF, xhtml or HTML) can also be determined via content negotiation, allowing a site to support a range of browser capabilities in a manner transparent to the end user.</p></p></p><p><p></p>Content negotiation not only allows developers to present alternate representations of content but has a significant side effect of allowing URLs to be completely abstract.  For example, a URL like <code>http://www.xyz.com/products/robot</code>, where robot is not a directory but an actual file, is completely legal when content negotiation is employed.  The actual file used, be it <code>robot.html</code>, <code>robot.cfm</code>, <code>robot.asp</code>, etc., is determined using the negotiation rules.  Abstracting away from the file extension details has two significant benefits.  First, security is significantly improved as potential hackers can't immediately identify the Web site's underlying technology.  Second, by abstracting the extension from the URL, the technology can be changed by the developer at will.  If you consider URLs to be effectively function calls to a Web application, cleaned URLs introduce the very basics of data hiding.</p></p></p><p><p></p>URLs can be cleaned server-side using a Web server extension that implements content negotiation, such as <a href="http://www.apacheref.com/ref/mod_negotiation.html" target="_blank" title="Opens in a new window.">mod_negotiation for Apache</a> or <a href="http://www.pagexchanger.com" title="Opens in a new window.">PageXchanger for IIS</a>.  However, getting a filter that can do the content negotiation is only half of the job. The underlying URLs present in HTML or other files must have their file extensions removed in order to realize the abstraction and security benefits of content negotiation.  Removing the file extensions in source code is easy enough using search and replace in a Web editor like Dreamweaver MX or HomeSite.  Some tools like <a href="http://www.w3compiler.com" target="_blank" title="Opens in a new window.">w3Compiler</a> also are being developed to improve page preparation for negotiation and transmission.   One word of assurance: don't jump to the conclusion that your files won't be named page.html anymore. Remember that, on your server, the precious extensions are safe and sound.  Content negotiation only means that the extensions disappear from source code, markup, and typed URLs.</p></p></p><p></p><p><h3>Automatically spell check directory and file names entered by users.</h3></p><p><p></p>The last tip is probably the least useful, but it is the easiest to do: spell check your file and directory names.  On the off chance that a user spells a file name wrong, makes a typo in extension or path, or encounters a broken link, recovery is easy enough with a spelling check.  Given that the typo will start to generate a 404 in the server, a spelling module can jump in and try to match the file or directory name most likely typed.  If file and directory names are relatively unique in a site, this last ditch effort can match correctly for numerous typos. If not, you get the 404 as expected.  Creating simple &quot;Did you mean X?&quot;-style URLs requires the simple installation of a server filter like <a href="http://www.apacheref.com/ref/mod_speling.html" target="_blank" title="Opens in a new window.">mod_speling for Apache</a> or <a href="http://www.urlspellcheck.com" title="Opens in a new window.">URLSpellCheck for IIS</a>.  The performance hit is not an issue, given that the correction filter is only called upon a 404 error, and it is better to result in a proper page than serve a 404 to save a minor amount of performance on your error page delivery.  In short, there is no reason this shouldn't be done, and it is surprising that this feature is not built-in to all modern Web servers.</p></p></p><p></p><p></p><h2>Conclusions</h2>	</p><p><p></p>Most of the tips presented here are fairly straightforward, with the partial exception of URL cleaning and rewriting.  All of them can be accomplished with a reasonable amount of effort.  The result of this effort should be cleaned URLs that are short, understandable, permanent, and devoid of implementation details.   This should significantly improve the usability, maintainability and security of a Web site.  The potential objections that developers and administrators might have against next generation URLs will probably have to do with any performance problems they might encounter using server filters to implement them or issues involving search engine compatibility.  As to the former, many of the required technologies are quite mature in the Apache world, and their newer IIS equivalents are usually explicitly modeled on the Apache exemplars, so that bodes well.  As to the search engine concerns, fortunately, Google so far has not shown any issue at all with cleaned URLs.  At this point, the main thing standing in the way of the adoption of next generation URLs is the simple fact that so few developers know they are possible, while some who do are too comfortable with the status quo to explore them in earnest.   This is a pity, because while these improved URLs may not be <a href="http://www.ietf.org/html.charters/urn-charter.html" target="_blank" title="Opens in a new window.">the mythical URN-style keyword</a> always promised to be just around the corner, they can substantially improve the Web experience for both users and developers alike in the long run.</p></p>