---
layout: post
permalink: RI_to_the_Rescue
ratings: 15
avgrate: 4.3333
categories: [Backend]
user: r937
real_name: "rudy limeback"
user_biog: "<p>My involvement with evolt.org goes back to 1998, as one of the original founders.  I\'m an SQL consultant who dabbled in web development for several years, in the \"golden age\" between HTML 2 and XHTML 1.1. My web sites are <a href=\"http://r937.com/\" rel=\"nofollow\">r937.com</a> and <a href=\"http://rudy.ca/\" rel=\"nofollow\">rudy.ca</a>. I live in Toronto, Canada, and you are all cordially invited to come and visit and play a round of frisbee golf with me.</p>"
user_since: 14 Dec 1998
avatar: /images/pictures/picture-20.jpg
article_count: 12
excerpt: "How Relational Integrity</p>can simplify your database project,</p>shorten development time,</p>and improve the quality of your life."
---
<h2>How Relational Integrity</p>can simplify your database project,</p>shorten development time,</p>and improve the quality of your life.</p></h2></p><p><p>Unless you are a seasoned database pro, </p>&quot;relational integrity&quot; might be just</p>another fancy marketing phrase that you don't really understand</p>but are vaguely suspicious of.</p>If the following explanation helps you, I will be very, </p>very happy -- you don't even have to tell me; I'll know.</p>And if you'd like more information, </p>please contact me; I do database work for a living,</p>answer email for free, and </p>would love to arrange some onsite training or consulting </p>at your company.</p></p><p><p>To illustrate relational integrity concepts, </p>I use the following <strong>sample database</strong>:</p></p><p><ul></p><li><strong>articles</strong> such as stories, columns, opinions, recipes, </p>       quotes, ideas,  or similar items of written content</li></p><li><strong>authors</strong> who write articles</li></p></ul></p><p><p>This database could be for an ezine (an electronic magazine web site), </p>a famous quotes search engine, an online library,</p>or any application which has to keep track of content (articles)</p>by owner (author).</p></p><p><p>If you already know what RI is, please feel free to</p><a href="/RI_to_the_Rescue#RI5">skip over</a> the following </p>basic explanations. </p></p><p><h2>What is a Relational Integrity?</h2></p><p><p>A <strong>relational database</strong></p>contains tables of data which are related to each other.</p>For example, articles are related to the author who wrote them,</p>and conversely, authors are related to the articles they wrote.  </p>(Sounds obvious, and it is.)</p>That's the <strong>relational</strong> part.</p></p><p><p>When we work with a relational database,</p>we naturally expect that data in related tables <strong>stay related</strong>.  </p>For example, articles written by MartinB should always</p>be related to MartinB and never be confused with</p>articles written by any other author.</p>That's the <strong>integrity</strong> part.</p></p><p><p>Relational Integrity is also called</p>Referential Integrity, perhaps because the </p>mechanism for ensuring integrity is implemented</p>by the way the tables <em>reference</em> each other.</p>Both terms are okay with me.  I usually</p>just say <strong>RI</strong> anyway.</p></p></p><p><h2>How RI Works</h2></p><p><p></p>Tables are <strong>related using data values</strong>.</p>Usually, these are the values of numeric  keys instead</p>of text fields.  (Database designers love assigning</p>numeric keys, mainly because it's more</p>efficient than relating tables through </p>text fields, but also because most databases</p>can generate autonumbers or sequence numbers</p>for this purpose.)</p></p><p><p>So let's say MartinB is an author in the</p>database and has author number 32.  </p>Further, let's say that for some reason </p>(which we won't go into here, as it's not important) </p>you need to change MartinB's author number from 32 to </p>45678.  The way it works is that you </p>change his author number on his author </p>record in the author table.</p><em>And then you had better <strong>also change</strong></p>any references to author 32 in <strong>all related tables</strong></em> --</p>like the articles table --</p>because if you don't, they'll still</p>refer to author number 32, which no longer exists.</p></p></p><p><p>Mercifully, you don't have to do this yourself.</p>This is where RI comes in.  RI can do it for you.</p></p><p><p></p>The underlying structure and enforcement of RI</p>is usually handled by the relational database system.</p>I say <em>usually</em> because in all database</p>systems I've ever worked with, RI is optional,</p>absurd as that seems.</p>Database developers have to turn RI on,</p>or else ask the developers to provide external enforcement</p>procedures outside the database system.</p></p><p><p>So if you don't have RI turned on for your particular </p>database, then when the day comes -- and you know it will --</p>when you have to make a change </p>and you forget the external procedure(s) to change all the</p>necessary related data values, the database will be said to have </p>lost integrity.  You will have &quot;broken links&quot; in your tables.</p>You will be up the creek. (Next April 1, mention to a DBA that </p>there are broken links in his database, and watch his face...)</p></p><p><p>You will, I am certain, by this point have guessed</p>that RI can be a very useful feature to employ in your database.</p></p><p><p>Let us take one more brief</p>moment to cover some basic definitions</p>before getting down to business.</p>Again, please feel free to</p><a href="/RI_to_the_Rescue#RI5">skip over</a> these definitions.</p></p><p><h2>Parent and Child</h2></p><p><p>Every database relation is a <strong>one-to-many</strong></p>relation involving just two tables, a parent table and a child table.</p>Yes, you may hear other terms like one-to-one, many-to-many, and so on, but</p>these are all just special cases of the one-to-many relation.</p>Don't let them fool you.  Understanding databases is easy if you keep it simple.</p></p><p><p>So each relation is one-to-many, involving a <strong>parent</strong> table </p>and a <strong>child</strong> table. </p>This terminology is not standard, merely convenient, if somewhat unfortunate.</p>Some people say master and detail; sometimes, I'll</p>say owner and member, a flashback</p>from pre-relational CODASYL databases</p>as out of date as bell-bottom pants (except that unlike </p>pre-relational databases, bell-bottoms may one day be back in style).</p></p><p><p>As you might guess, the parent is the &quot;one&quot; and</p>the child is the &quot;many.&quot;</p>Each parent can have many children.</p>The reverse, I am afraid, is not true, not in a relational database.</p>A child can have only one parent.</p><em>Please</em> don't</p>dwell too long on the obvious fact that in real life a child</p>has two parents -- you will only get confused.  In a relational database,</p>in a one-to-many relation, <strong>each child has <em>at most</em></p>one parent</strong>. This is important.  This is also why the</p>parent-child terminology is unfortunate.</p></p><p><p>Let's look at our sample database.</p>Each author is related one or more articles, the articles written by that author.</p>The author table is the parent table, and</p>the article table is the child table.</p></p><p><p>Note that an author can write many articles, but an article has only one author.</p>This is a natural consequence of it being a one-to-many relation.</p>The scenario where an article</p>is co-authored by more than one author</p>involves a many-to-many relation,</p>the contemplation of which, like the reality that</p>in real life a child has more than one parent,</p>is beyond the scope of this discussion; it will only confuse you</p>now.</p></p><p><h2>Primary and Foreign Keys</h2></p><p><p>Relational databases implement RI</p>using <strong>primary keys</strong> and <strong>foreign keys</strong>.</p>Other than their special role in RI,</p>these &quot;keys&quot; are like any other database fields -- they</p>contain data values.</p></p><p><p>The <strong>parent table contains the primary key</strong> and </p>the <strong>child table contains the foreign key</strong> which </p>references (or &quot;points&quot; to, if you prefer) the parent table.</p></p><p><p>Because each child relates to only one parent,</p>the child table needs only one foreign key.</p>So where are the &quot;many&quot; child records in a</p>one-to-many relation?  They're</p>in the <strong>multiple rows</strong> of the child table</p>that all have the <strong>same data value in</p>their foreign key</strong>, all referencing the same parent.</p></p><p><p>For example, consider the following articles:</p></p><p><table border="0" cellpadding="6" cellspacing="0"></p><tr><th>Author</th><th>Article</th></tr></p><tr><td align="center">32</td><td><a href="/article/Your_clients_need_a_Content_Management_System/20/5127/index.html" title="Your clients need a Content Management System">Your clients need a CMS</a></p>                                         <br /><a href="/article/The_Tao_of_Testing/20/4142/index.html" title="The Tao of Testing">The Tao of Testing</a></td></tr></p><tr><td align="center">88</td><td><a href="/article/640_x_480_Isn_t_Dead_Just_Yet/22/275/index.html" title="640 x 480 Isn't Dead Just Yet">640 x 480 Isn't Dead Yet</a></p>                                         <br /><a href="/article/Inside_the_evolt_org_Rebuild_The_HTML_and_CSS/20/5816/index.html" title="Inside the evolt.org Rebuild: The HTML and CSS">Inside the evolt.org Rebuild</a></td></tr></p><tr><td align="center">20</td><td><a href="/article/Liquid_Tables/20/2321/index.html" title="Liquid Tables">Liquid Tables</a></td></tr></p></table></p><p><p>Above, you can see the one-to-many relation clearly.</p>Now look at it the way you normally see</p>it actually stored in the article table:</p></p><p><table border="0" cellpadding="6" cellspacing="0"></p><tr><th>Article</th><th>Author</th></tr></p><tr><td><a href="/article/Your_clients_need_a_Content_Management_System/20/5127/index.html" title="Your clients need a Content Management System">Your clients need a CMS</a></td><td align="center">32</td></tr></p><tr><td><a href="/article/640_x_480_Isn_t_Dead_Just_Yet/22/275/index.html" title="640 x 480 Isn't Dead Just Yet">640 x 480 Isn't Dead Yet</a></td><td align="center">88</td></tr></p><tr><td><a href="/article/The_Tao_of_Testing/20/4142/20/4142/index.html" title="The Tao of Testing">The Tao of Testing</a></td><td align="center">32</td></tr></p><tr><td><a href="/article/Inside_the_evolt_org_Rebuild_The_HTML_and_CSS/20/5816/index.html" title="Inside the evolt.org Rebuild: The HTML and CSS">Inside the evolt.org Rebuild</a> &nbsp;</td><td align="center">88</td></tr></p><tr><td><a href="/article/Liquid_Tables/20/2321/index.html" title="Liquid Tables">Liquid Tables</a></td><td align="center">20</td></tr></p></table></p><p><p>Now you can see more clearly that each article is</p>related to only one author.  This is the &quot;many-to-one&quot;</p>reversal of the one-to-many relationship.</p>It amounts to the same thing.  You can always say something</p>about a one-to-many relation in two different ways.</p></p><p><p><a name="RI5">&nbsp;</a></p></p><h2>RI Actions</h2></p><p><p>Finally, we get down to business.</p></p><p><p>In a relational database,</p>there are four basic actions you can perform on a table:</p></p><ul></p><li><strong>Select</strong> one or more existing rows from the table</li></p><li><strong>Insert</strong> one or more new rows into the table</li></p><li><strong>Update</strong> one or more rows in the table</li></p><li><strong>Delete</strong> one or more rows from the table</li></p></ul></p><p><p>These actions, known as <strong>SIUD</strong>, are carried out</p>by the -- wait for it -- Select, Insert, Update, and Delete SQL statements.  </p>(These actions are sometimes, as in business process modelling, also</p>called CRUD, using the initials for Create, Reference, Update, and Delete.</p>CRUD is easier to remember, but not as helpful as SIUD, because</p>you may end up getting confused.  For example, there's no </p>Reference SQL statement, but there <em>is</em> a Create SQL statement, </p>although it doesn't create any data.  I'm sorry I even</p>mentioned CRUD.  I just wanted to </p>set the record straight, point out again that simplicity rules,</p>and make sure you were awake.)</p></p><p><p>Three of these actions -- Insert, Update, and Delete --</p>change the contents of the database table and therefore have RI implications.</p>Remember, you want to stay on top of changes, preferably letting</p>the database itself handle them, to ensure you</p>never have &quot;broken links&quot; in your data.</p></p><p><p>Now it gets a wee bit complicated.</p></p><p><p>For every relation, the Insert, Update, and Delete actions</p>can be performed on <em>either</em> the primary key (in the parent table), or the foreign</p>key (in the child table).  </p>There are thus a total of six possible <strong>RI actions</strong> for</p>every one-to-many relation:</p></p><p><table border="0" cellpadding="6" cellspacing="0"></p><tr align="left"><th>Parent Insert</th><td>&nbsp;</td><th>Child Insert</th></tr></p><tr align="left"><th>Parent Update</th><td>&nbsp;</td><th>Child Update</th></tr></p><tr align="left"><th>Parent Delete</th><td>&nbsp;</td><th>Child Delete</th></tr></p></table></p><p><p>Each of these six possible RI actions</p>needs to be examined when you</p>design your database, because what you want to do</p>is turn over as much of the enforcement</p>of RI as possible to the database itself.</p></p><p><h2>RI Rules</h2></p><p><p>Now it gets a little more complicated.</p></p><p><p>For <em>each</em> of the six RI actions mentioned above, </p><em>one of five</em> RI rules can be implemented:</p></p><p><table border="0" cellpadding="6" cellspacing="0"></p><tr><th align="left">Cascade    </th><td>&nbsp;</td><td>perform same action on related keys</td></tr></p><tr><th align="left">Restrict   </th><td>&nbsp;</td><td>disallow action</td></tr></p><tr><th align="left">Set Null   </th><td>&nbsp;</td><td>set related keys to null</td></tr></p><tr><th align="left">Set Default</th><td>&nbsp;</td><td>set related keys to their default value</td></tr></p><tr><th align="left">None       </th><td>&nbsp;</td><td>allow action, do nothing to related keys</td></tr></p></table></p><p><p>Does this mean that implementing RI</p>requires choosing one out of a possible thirty different</p>combinations of actions for each one-to-many relation??</p>The answer is yes -- but I hasten to add that it isn't really as bad or as much</p>work as it may seem!!</p></p><p><p>In fact, most database systems do not let you</p>define all of the above rules.  Where you cannot</p>define the rule, it typically defaults either to Restrict or None.</p></p><p><h2>Sample RI Action Rules</h2></p><p><p>Let's say you want to insert a new article, i.e. a child insert action.</p>In most databases, the Restrict rule would be</p>in effect (assuming you have defined the foreign key properly,</p>i.e. RI has been turned on).</p>What this means is that you cannot insert an article for an </p>author that doesn't exist; you are restricted from doing so.</p></p><p><p>This is typical behaviour</p>for most one-to-many relations.  You have to add the parent to</p>the database first, and then you can add child records</p>that reference that parent.</p>In fact, if you wanted some other rule for Child Insert, </p>you would find it extremely tricky to implement.  Trust</p>me, it's messy.  Luckily, this requirement hardly ever</p>comes up.  I shouldn't even have mentioned it.</p>Of the five possible actions for Child Insert, </p>only Restrict really makes sense.</p></p><p>Okay, I lied.  Actually, there is one other action that </p>makes sense, in a macabre sort of way, only because you see it all the time,</p>not that you would really want to define it</p>this way on purpose (assuming you have been paying attention).</p></p><p>If you do not turn on RI for the author-article</p>one-to-many relation, the Child Insert action defaults to None.</p>In other words, you can add an article that references any author number</p>you like, the database will not check it for you,</p>and who knows, it might result in a broken link.</p>So leaving RI undefined for a given relation</p>results in Child Insert: None.</p></p><p><p>Maintaining the author-article relation involves six different actions.</p>Below, I have chosen the RI rules  that &quot;make the most sense&quot; to me.</p>See if you agree or disagree with my comments:</p></p><p><ol></p><li><p><strong>Author Insert: None</strong></p><br /><em>insert new author, do nothing to related articles</em></p><br />This is fairly trivial, since new authors wouldn't have any articles yet</p>      (assuming other sensible RI rules are in effect).</p></li></p><p><li><p><strong>Author Update: Cascade</strong></p><br /><em>update the author's primary key and also all matching article foreign keys</em></p><br />This is the crucial action we've been talking about that you </p>want the database to do for you, and while you might not need</p>to change a record's primary key often, when you need to do it,</p>you want Cascade.</p></li></p><p><li><p><strong>Author Delete: Restrict</strong></p><br /><em>delete author only if no articles have been written by this author</em></p><br />If you allowed the author delete to happen and left the</p>articles in there, they would all have broken links; Restrict prevents this.</p>Alternatively, if you specified the Author Delete rule as Set Null, </p>the author would be gone and the articles would be left behind but you </p>wouldn't know who wrote them; this is the only other choice that</p>makes sense to me, but maybe not as much as Restrict.</p>(And I'm sorry, I really cannot get into</p>a discussion of nulls at this point.)</p></li></p><p><li><p><strong>Article Insert: Restrict</strong></p><br /><em>insert new article only if the author already exists</em></p><br />This is the example discussed in detail earlier.</p></li></p><p><li><p><strong>Article Update: Restrict</strong></p><br /><em>update article to a different author but only if the new author </p>also already exists</em></p><br />Sometimes this is required to correct an input error.</p></li></p><p><li><p><strong>Article Delete: None</strong></p><br /><em>delete article and do nothing to author</em></p><br />This makes sense, right?  Note that if the article being deleted </p>is the author's last or only one, this may result in an author </p>with no articles -- but that's <em>not</em> the</p>same thing as a broken link.</p></li></p><p></ol></p><p><h2>Options for Implementing RI</h2></p><p><p>If you  made it this far, congratulations -- </p>things are about to get a whole lot simpler.</p></p><p><p>Standard SQL-92 syntax provides a mechanism</p>for setting RI rules only for the <strong>parent delete</strong> and <strong>parent update</strong> actions.</p>All others take a default. The rules are defined when</p>declaring the foreign key on the child table:</p></p><p><p><code></p>CREATE TABLE child ( columndefinitions,</p><br />&nbsp; [constraintname] FOREIGN KEY (fkcolumns)</p><br />&nbsp;&nbsp; REFERENCES parent [(pkcolumns)]</p><br />&nbsp;&nbsp; ON DELETE</p><br />&nbsp;&nbsp;&nbsp; CASCADE   SET NULL   SET DEFAULT   NO ACTION</p><br />&nbsp;&nbsp; ON UPDATE</p><br />&nbsp;&nbsp;&nbsp; CASCADE   SET NULL   SET DEFAULT   NO ACTION</p><br />&nbsp; )</code></p></p><p><p>As mentioned, all other rules take defaults, and</p>if you do not define the parent delete and parent update rules,</p>they take defaults too:</p></p><p><table border="0" cellpadding="6" cellspacing="0"></p><tr><th>Action</th><th>Default Rule</th></tr></p><tr><td>Parent Insert</td><td align="center">None</td></tr></p><tr><td>Parent Update</td><td align="center">Restrict</td></tr></p><tr><td>Parent Delete</td><td align="center">Restrict</td></tr></p><tr><td>Child Insert</td><td align="center">Restrict</td></tr></p><tr><td>Child Update</td><td align="center">Restrict</td></tr></p><tr><td>Child Delete</td><td align="center">None</td></tr></p></table></p><p><p>None of these defaults is very surprising, when you think about it.</p>In fact, the only action for the author-article relation</p>that we thought made sense to be different from the default</p>is Author Update, which we decided we wanted as Cascade.</p>Luckily, that is one of the rules that can </p>be easily set by the SQL syntax.</p></p><p><p>So what's the big deal, then?  If all the defaults are good,</p>and we can change the ones we want, how will RI</p>simplify your database project,</p>shorten development time,</p>and improve the quality of your life?</p></p><p><p>The answer comes when you consider how some</p>applications go about maintaining relational integrity</p>when RI is <em>not</em> turned on in the database.</p></p><p><p>Suppose the application wanted to insert an</p>article, and also wanted to make sure the author </p>already exists in the database.  It is</p>not difficult to imagine a developer</p>coding up something like this --</p></p><p><ul></p><li>do a SELECT on the author table using the author number</p>for the proposed article insert as the search key</li></p><li>if the select fails, issue an error message</p>such as "author does not exist; article insert rejected"</li></p><li>otherwise, proceed to INSERT the article</li></p></ul></p><p><p>There is nothing inherently <em>wrong</em> with this approach,</p>other than that</p></p><ol><li>it requires an additional database call, which </p>is often much less efficient, and</li></p><li>it takes extra time to do this programming</li></p></ol></p><p><p>With RI turned on and Article Insert set to Restrict (the default),</p>the developer simply codes</p></p><p><ul></p><li>INSERT the article</li></p><li>test the database return code, and if it failed</p>on an RI exception, issue the error message</li></p></ul></p><p><p>It is not even always necessary to</p>test the return code and issue a friendly error message.</p>Assuming the foreign key constraint is named properly,</p>the database error message will basically say something</p>like &quot;ERROR: integrity constraint ARTICLEAUTHOR violated - parent key not</p>found&quot; and this is often enough to indicate what's going on.</p></p><p><h2>Conclusions</h2></p><p><p>When designing a database, after all the</p>entities, tables, columns and data types have been identified,</p>you will have a number of one-to-many relations.</p>Examine <em>each</em> relation</p>in light of the six possible actions,</p>and the five possible rules for each.</p><strong>Start by considering all the default rules.</strong></p>Pay special attention to the <strong>parent update</strong></p>and <strong>parent delete</strong> rules, because those can</p>be changed easily, and often are.</p>Then prepare a <strong>rule table</strong> for each</p>relation, similar to the samples we described earlier</p>for the author-article relation:</p></p><p><table border="0" cellpadding="6" cellspacing="0"></p><tr><th>Action</th><th>Rule</th></tr></p><tr><td>Author Insert</td><td align="center">None</td></tr></p><tr><td>Author Update</td><td align="center"><strong>Cascade</strong></td></tr></p><tr><td>Author Delete</td><td align="center">Restrict</td></tr></p><tr><td>Article Insert</td><td align="center">Restrict</td></tr></p><tr><td>Article Update</td><td align="center">Restrict</td></tr></p><tr><td>Article Delete</td><td align="center">None</td></tr></p></table></p><p><p>Highlight the rules that are different</p>from the default, as above.</p>Then pass these rule tables as specifications to your developer.</p></p><p><p>You'll save a lot of hassles, development time,</p>and unnecessary coding.  And you might just see</p>an increase in the quality of your life.</p></p><p><h2>Footnotes</h2></p><p><p>I am indebted to ERwin, a popular data modelling tool,</p>for first introducing me to the concept </p>of RI actions outside the scope of what is</p>normally defined by SQL syntax.  You would</p>not believe what you have to do, and what ERwin</p>can generate in the way of triggers and stored procedures,</p>to achieve non-default RI rules for actions </p>other than parent update and parent delete.</p>If your project requires these, give me a shout.</p></p><p><p>&quot;Improving the quality of life&quot; is a </p>requirement that should be part of every database</p>specification. I was taught this</p>in my very first database design course</p>for IDMS in 1977 by William Casey of Cullinane Corporation,</p>and it's as true today as it was then.</p>