---
layout: post
permalink: RegEx_Basics
ratings: 51
avgrate: 4.5686
category: Site Development
user: sprocket
real_name: "Chris Spruck"
user_since: 18 Sep 2000
avatar: "/images/pictures/picture-3211.gif"
article_count: 1
excerpt: "Regular expressions, sometimes referred to as regex, grep, or pattern matching, </p>  can be a very powerful tool and a tremendous time-saver with a broad range of </p>  application. As an extended form of find-and-replace, regex is supported by </p>  most languages and tools, but because there can "
---
<p>Regular expressions, sometimes referred to as regex, grep, or pattern matching, can be a very powerful tool and a tremendous time-saver with a broad range of application. As an extended form of find-and-replace, you can use a regular expression to do things such as perform client-side validation of email addresses and phone numbers, search multiple documents for strings and patterns you wish to change or remove, or extract a list of links from source code. Regex is supported by most languages and tools, but because there can be varying implementations, this article will cover basic principles that are commonly used.</p> </p><p><h2>Literals and Metacharacters</h2></p><p><p>If you've seen a regular expression before and thought it looked like alien </p>  space-algebra, it does, but have no fear - you'll be fluent in alien space-algebra </p>  in no time! To make the most of the power of regex, you need to be familiar </p>  with a few classifications of characters. <em>Literals</em> are normal text </p>  characters and can include whitespace (tabs, spaces, newlines, etc.). Unless </p>  modified by a metacharacter, a literal will match itself on a one-for-one basis. </p>  <em>Metacharacters'</em> power lies in how they are arranged and interpreted </p>  as wildcards. Metacharacters can be escaped with a backslash (\) to find instances </p>  of themselves, for instance, if you need to find a caret (^) or a backslash, </p>  as well as used in nested groups or other combinations.</p></p><p><p>Below is a list of some metacharacters and character classes for a quick glance - each will be explained in further detail with examples. Keep in mind that a "match" can be as simple as a single character or as complex as a sequence of literals and metacharacters in nested and compounded combinations.</p> </p><p><table cellpadding="0" cellspacing="0" class="data"></p>  <thead> </p>  <tr> </p>    	<th>Metacharacter</th></p>    	<th>Match</th></p>  	</tr></p>  </thead></p>  <tbody>	</p>  <tr> </p>    <td>\</td></p>    <td>the escape character - used to find an instance of a metacharacter like </p>      a period, brackets, etc.</td></p>  </tr></p>  <tr> </p>    <td>. (period)</td></p>    <td>match any character except newline</td></p>  </tr></p>  <tr> </p>    <td>x</td></p>    <td>match any instance of x</td></p>  </tr></p>  <tr> </p>    <td>^x</td></p>    <td>match any character except x</td></p>  </tr></p>  <tr> </p>    <td>[x]</td></p>    <td>match any instance of x in the bracketed range - [abxyz] will match any </p>      instance of a, b, x, y, or z</td></p>  </tr></p>  <tr> </p>    <td>  (pipe)</td></p>    <td>an OR operator - [x y] will match an instance of x or y</td></p>  </tr></p>  <tr> </p>    <td>()</td></p>    <td>used to group sequences of characters or matches</td></p>  </tr></p>  <tr> </p>    <td>{}</td></p>    <td>used to define numeric quantifiers</td></p>  </tr></p>  <tr> </p>    <td>{x}</td></p>    <td>match must occur exactly x times</td></p>  </tr></p>  <tr> </p>    <td>{x,}</td></p>    <td>match must occur at least x times</td></p>  </tr></p>  <tr> </p>    <td>{x,y}</td></p>    <td>match must occur at least x times, but no more than y times</td></p>  </tr></p>  <tr> </p>    <td>?</td></p>    <td>preceding match is optional or one only, same as {0,1}</td></p>  </tr></p>  <tr> </p>    <td>*</td></p>    <td>find 0 or more of preceding match, same as {0,}</td></p>  </tr></p>  <tr> </p>    <td>+</td></p>    <td>find 1 or more of preceding match, same as {1,}</td></p>  </tr></p>  <tr> </p>    <td>^</td></p>    <td>match the beginning of the line</td></p>  </tr></p>  <tr> </p>    <td>$</td></p>    <td>match the end of a line</td></p>  </tr></p>  </tbody></p></table></p><h3>Detailed descriptions of regex operators</h3></p><p><p>Within these descriptions, x is used as a placeholder for examples - x can </p>  be an actual x or it can be an entire sequence like href="http://www.evolt.org", </p>  &lt;DIV&gt;, or ((\.\.)?/[a-z]+\.jpg).</p><p>. - Matches any one character except newline and is generally used with quantifiers, which will be explained below. For instance, </p>  .{3} would find three-letter words</p> </p><p>x - Matches any instance of x and can include </p>  specific character sets or ranges, for instance, [wxyz] would match any instance </p>  of w, x, y, or z, but not wz, yx, or other combinations of the given character </p>  set, unless it was followed by a quantifier.</p> </p><p>^x - Matches any character that is not x and can also be used in a range. For </p>  example, &lt;[^abel]+&gt; would match one or more letters that are not a, b, </p>  e, or l, and which are surrounded by &lt; and &gt;, thus it would match &lt;font&gt; </p>  but not &lt;table&gt;.</p> </p><p>[x] - Matches any character in the given range. Examples of a range would be </p>  the expression [0-9], which would find a single digit, or [a-z], which would </p>  find a single lower case character. You can combine ranges as well - [A-Za-z0-9] </p>  will find a single upper or lower case character or digit. You may also combine </p>  ranges with commas, such as [0-3, 5-8] which would find any digit that isn't </p>  4 or 9.</p> </p>  <p>  - The OR operator can be used at the character level or combined in sequences. </p>  [x y] will find instances of x or y and you aren't limited to just two objects </p>  - [w x y z] is perfectly valid.</p> </p><p>() - Parentheses are used to group operators much like basic algebra and are </p>  also used to delineate a backreference, which is the way you can do replaces </p>  with matches. (Backreferences get their own section below). A simple example </p>  would look something like: www\.([a-z]+)\.com which will find www.anycharactersathroughzhere.com.</p> </p><p>{} - Curly brackets (or braces) are used to define numeric quantifiers, which </p>  allow you to specify the optional, minimum, or maximum number of occurrences </p>  in the match. x{3} would find exactly 3 occurrences of x. x{3,} matches on <em>at </p>  least</em> 3 occurrences of x. x{3,5} matches at least 3 occurrences of x and </p>  no more than 5.</p></p><p>? - The preceding match is optional or must match exactly one time. An example </p>  would be: ((\.\.)?/[a-z]+\.jpg) which matches a path to an image file ending </p>  in .jpg and could start with a ../ or just a /. A ./ or ../../ would fail to </p>  match that particular expression.</p></p><p>* - Matches the preceding character or group 0 or more times. </p>  Note that this is not the same as the use of the ? listed above. z* can match </p>  no z, z, or for those readers who have already fallen asleep, zzzzzzzzzzzzzzzzzzzzzzz.</p> </p>  <p>+ - Matches the preceding character or group 1 or more times. In comparison </p>  to the previous example, z+ would have to match at least z or zz or zzz and </p>  so on.</p> </p><p>^ - Used to force a match to the beginning of a line. Note that this is not </p>  the same as a character exclusion such as [^xyz], which would match any characters </p>  that are not x, y, or z. ^Hello would match at the beginning of a line such </p>  as <em>Hello Chris</em> and would not match <em>Chris said Hello</em>.</p></p><p>  $ - Used to force a match to the end of a line. $end would match at the end </p>  of a line such as <em>This is the end</em> and would not match <em>end this </p>  article already</em>!</p></p><p>The various operators and metacharacters listed above are pretty standard across </p>  most implementations of regex. POSIX class names and character class shorthands </p>  are shortcuts to specify character types like digits, whitespace, and so on.</p></p><p> POSIX (Portable Operating System Interface) classes should be more consistent </p>  across languages and applications but there may not be an exact parallel between </p>  certain class shorthands and POSIX classes, and either class type may not always </p>  be fully supported. If they are supported, POSIX classes can be useful since </p>  they have a little more precision when it comes to things like whitespace and </p>  other non-alphanumeric characters.</p></p><table cellpadding="0" cellspacing="0" class="data"></p>  <thead></p>  	<tr></p>    	<th>POSIX Class</th></p>    	<th>Match</th></p>  	</tr></p>  </thead></p>  <tbody>	</p>  <tr></p>    <td>[:alnum:]</td></p>    <td>alphabetic and numeric characters</td></p>  </tr></p>  <tr></p>    <td>[:alpha:]</td></p>    <td>alphabetic characters</td></p>  </tr></p>  <tr></p>    <td>[:blank:]</td></p>    <td>space and tab</td></p>  </tr></p>  <tr></p>    <td>[:cntrl:]</td></p>    <td>control characters</td></p>  </tr></p>  <tr></p>    <td>[:digit:]</td></p>    <td>digits</td></p>  </tr></p>  <tr></p>    <td>[:graph:]</td></p>    <td>non-blank (not spaces and control characters)</td></p>  </tr></p>  <tr></p>    <td>[:lower:]</td></p>    <td>lowercase alphabetic characters</td></p>  </tr></p><tr></p>    <td>[:print:]</td></p>    <td>any printable characters</td></p>  </tr></p>  <tr></p>    <td>[:punct:]</td></p>    <td>punctuation characters</td></p>  </tr></p>  <tr></p>    <td>[:space:]</td></p>    <td>all whitespace characters (includes [:blank:], newline, carriage </p>      return)</td></p>  </tr></p>  <tr></p>    <td>[:upper:]</td></p>    <td>uppercase alphabetic characters</td></p>  </tr></p>  <tr></p>    <td>[:xdigit:]</td></p>    <td>digits allowed in a hexadecimal number (i.e. 0-9, a-f, A-F)</td></p>  </tr></p>  </tbody></p></table></p><p>&nbsp;</p></p><table cellpadding="0" cellspacing="0" class="data"></p>  <thead> </p>  <tr> </p>    <th>Character class </th></p>    <th>Match</th></p>  </tr></p>  </thead></p>  <tbody> </p>  <tr> </p>    <td>\d</td></p>    <td>matches a digit, same as [0-9]</td></p>  </tr></p>  <tr> </p>    <td>\D</td></p>    <td>matches a non-digit, same as [^0-9]</td></p>  </tr></p>  <tr> </p>    <td>\s</td></p>    <td>matches a whitespace character (space, tab, newline, etc.)</td></p>  </tr></p>  <tr> </p>    <td>\S</td></p>    <td>matches a non-whitespace character</td></p>  </tr></p>  <tr> </p>    <td>\w</td></p>    <td>matches a word character</td></p>  </tr></p>  <tr> </p>    <td>\W</td></p>    <td>matches a non-word character </td></p>  </tr></p>  <tr> </p>    <td>\b</td></p>    <td>matches a word-boundary (NOTE: within a class, matches a backspace)</td></p>  </tr></p>  <tr> </p>    <td>\B</td></p>    <td>matches a non-wordboundary</td></p>  </tr></p>  </tbody></p></table></p><h2>Think dif{2}erently</h2></p><p><p>Many Macintosh applications can easily handle regular expressions, but that's </p>  not what I mean here. The philosophy of regex is one of surgical precision and </p>  extreme logic, and you have to play by the rules. Like doing a complex database </p>  query, you have to know exactly what you want and exactly how to get it or you'll </p>  end up with either way more data than you need or not enough information. The </p>  concepts of AND, OR, wildcards, and the liberal use of parentheses all come </p>  into play with regex. You have to carefully create an expression that meets </p>  your needs but is neither too restrictive nor too inclusive or the dark side </p>  of regular expressions will rear its ugly head.</p> </p><p><h2>A warning about "greediness"</h2></p><p><p>With true power, comes an unhealthy dose of greed. Regular expressions are very greedy.  They may seem nice and friendly, but they'll take all they can get. What this means is that a regex will try to match as much as it can, since it's not smart enough to stop on the earliest possible match. It assumes you want the "whole thing", which is why you need to create a surgical strike of an expression. You <em>can</em> take care of a broken toe by amputating above the knee, but then where does that leave you? (Hopping mad, probably).</p> </p><p><p>A great example of regex greediness is the expression:</p></p><blockquote>&lt;a href=".*"&gt;.*&lt;/a&gt;</blockquote> </p> <p> At first glance, it appears this expression will find an href tag (having no </p>  extra attributes) with a reference containing just about any URL, followed by </p>  "&gt;, then anything in the link text, then the closing &lt;/a&gt;. You could </p>  use this to get a list of all the links in a web page. Sounds useful and looks </p>  mostly harmless, right? What you end up with is something like this:</p> </p><p><blockquote>&lt;a href="http://sample.url.here"&gt;Click this!&lt;/a&gt;. Some text goes </p>  &lt;a href="../text.htm"&gt;here&lt;/a&gt;. Maybe several paragraphs go here. </p>  More text goes &lt;a href="/less/is/more.htm"&gt;here&lt;/a&gt;. Another big </p>  block of text, text, and more text. &lt;a href="end.htm"&gt;The End&lt;/a&gt;</blockquote> </p><p><p>The reason you get a whole block of text mixed with links as a single match </p>  instead of a simple list containing each link is because the sub-expression </p>  .* is where the greed kicks in. The .* really does mean "match <em>anything</em>" </p>  so it merrily goes along until it can't match anything else, which matches up </p>  to the very last &lt;/a&gt; it can find and grabs everything in between along </p>  the way. It started at the toe and went straight to the thigh, without even </p>  thinking about slowing down at the knee.</p> </p><p><p>Here's where we put a splint on the toe instead of amputating the whole leg. </p>  Break down the parts of this expression: </p></p><blockquote></p>  <p>&lt;a href="[^"]+"&gt;[^&lt;]+&lt;/a&gt;</p></p></blockquote></p><p> You start with the &lt;a href=" and then you see [^"]+"&gt;. If you've been </p>  following along with the rules, you know that this means find at least one of </p>  any character except a double-quote, <em>then</em> find the first instance of </p>  a double-quote, then a &gt;. The same principle applies to the next part - [^&lt;]+&lt;/a&gt; </p>  finds at least one of any character except a &lt;, then matches the first literal </p>  instance of &lt;/a&gt;. Search with this expression and you get a nice short </p>  list of complete href tags. Conquer the greed! A clear understanding of the </p>  rules of regex and the various operators is paramount and it will take patience </p>  as well as experimentation with your logic to learn to tune an expression to </p>  yield exactly what you need.</p></p><h2>Backreferences</h2></p><p><p>Using a backreference is how you finally get to witness the real power of regular </p>  expressions. Extracting a list of links from a page of source is useful, but </p>  nowhere as useful as being able to do something with that data. Parentheses </p>  can be used to "remember" a subexpression, and a backreference in the form of </p>  <em>\digit</em> is how you refer to that particular group. Parentheses are counted </p>  from left to right within the expression, so the first open parentheses group </p>  has a backreference of \1, the second has a backreference of \2, and so on. </p>  You can use the memory-like functionality of a backreference in a replace string.</p> </p><p><p>A good example of this uses the href expression from above. You can get a list </p>  of complete hrefs from some source with the expression &lt;a href="[^"]+"&gt;[^&lt;]+&lt;/a&gt;. </p>  Let's say you need to find all external links on a web site and remove the href </p>  tag, but leave the link text intact, and we'll assume for this example that </p>  none of your local links start with http://. You would add parentheses to your </p>  expression like this: </p></p><blockquote></p>  <p>&lt;a href="http://[^"]+"&gt;<strong>(</strong>[^&lt;]+<strong>)</strong>&lt;/a&gt;</p></p></blockquote></p><p>You would then perform a find with this expression and simply replace with </p>  \1. The parentheses "memorize" the link text and the \1 calls it into the replace, </p>  leaving you with just the link text e.g. <em>some text about &lt;a href="http://www.evolt.org"&gt;evolt&lt;/a&gt;</em> </p>  results in <em>some text about evolt</em>.</p></p><p><p>A more interesting example might be a transposition using more than one backreference. </p>  Pretend you have a text list of web site users in the form of LastName, FirstName </p>  and you want a list of names in a FirstName LastName format. The expression, </p>  ([^,]+),\s(.+) would find Spruck, Chris, since ([^,]+), matches any number of </p>  characters that aren't a comma, followed by a comma, then a space, then (.+) </p>  finds any number of characters again. Notice where I placed both sets of parentheses. </p>  To change Spruck, Chris to the preferred format, you would replace that with </p>  \2\s\1, yielding Chris Spruck.</p></p><p>When you're doing replaces, it's very important that you test your expressions </p>  on backup copies of files, or even a dummy test file of your own creation, so </p>  if your expression is off by a parenthesis or something else, you haven't ruined </p>  your files permanently. Once you know your expression works on a sample, then </p>  go ahead and work on all your files. If you do run an expression that gives </p>  you unintended results, you can probably run another one again to correct the </p>  mishap. Don't ask how I know this. </p></p><p>Sometimes it may also be useful to run more than one expression over the same </p>  set of data to make it easier to catch every last bit that you need with a second </p>  expression. For instance, you might want to add quotes to all your tag attributes </p>  if some are unquoted, then run another expression that somehow operates based on </p>  the quotes. </p> </p><p><h2>A few practical examples</h2></p><p><h3>Get a list of IP addresses from a server log:</h3> </p><p>(\d{1,3}\.){3}\d{1,3} - This expression will find three instances of a one </p>  to three digit number followed by a period, then one to three more digits, e.g. </p>  206.159.10.1 </p></p><h3>Find doubled words in text such as &quot;Rate this article high high, please!&quot;:</h3></p><p>\s([A-Za-z]+)\s\1 - This expression will match a space, followed by a word </p>  of any length (which is later recalled by using the parentheses for a backreference), </p>  then a space again. The backreference, \1, then picks up the second instance </p>  of the same word. You could then simply replace the match with \1, which will </p>  remove the second instance of the word.</p></p><h3>Remove FONT tags from your web pages:</h3></p><p>&lt;(FONT font)([ ]([a-zA-Z]+)=(&quot; ')[^&quot;\']+(&quot; '))*[^&gt;]+&gt;([^&lt;]+)(&lt;/FONT&gt; &lt;/font&gt;) </p>  and replace with the backreference \6 - This expression looks quite complicated, </p>  but I wanted to show an example with some more involved logic. A simpler example </p>  that finds the same string will follow this explanation. &lt;(FONT font) accounts </p>  for an upper or lower case tag. ([ ]([a-zA-Z]+)= matches a space followed by </p>  any attribute name and an =. The next subexpression, (&quot; ')[^&quot;\']+(&quot; '), </p>  finds the leading double or single quotes on the attribute(s), then any attribute </p>  value that's not a double or single quote, i.e. Arial, +5, #c3d4ff, etc., then </p>  the closing double or single quote. Notice that the subexpression for the entire </p>  attribute is enclosed in parentheses and followed by an asterisk - ([ ]([a-zA-Z]+)=(&quot; ')[^&quot;\']+(&quot; '))*. </p>  This allows you to find a tag with either no attributes or any number that may </p>  exist. [^&gt;]+&gt; then matches anything up to the first &gt; (similar to the </p>  &quot;greediness&quot; example above). The backreference is defined next as </p>  ([^&lt;]+), which will capture any text between the opening and closing font </p>  tags, and is referred to as \6 because it's the sixth parenthetical group in </p>  the entire expression. Then (&lt;/FONT&gt; &lt;/font&gt;) accounts for the closing </p>  font tag in either case.</p></p><p>&lt;(FONT font)[^&gt;]*&gt;[^&lt;]*(&lt;/FONT&gt; &lt;/font&gt;) is a simpler example that accomplishes the same thing as the expression explained </p>  above. The difference is that it is much less picky about what is between the </p>  font tags, so if you have inconsistent tag syntax, it will probably capture </p>  the various instances you may have. On the other hand, if you have any extra junk </p>  characters in your search data, you may catch things you didn't intend, which </p>  is why you should test your expressions ahead of time.</p></p><h2>A brief history of the 31 Flavors</h2></p><p>There are a number of applications and languages that support regular expressions, </p>  but unfortunately, not all of them support regex in quite the same way. Although </p>  regular expressions had their origins in neurophysiology in the 1940s and were </p>  developed by theoretical mathematicians in the 1950s and 1960s, the evolution </p>  and subsequent divergence of regex implementations was due to the independent </p>  development of various Unix tools such as grep, awk, sed, Emacs, and others. </p>  [1] </p></p><p>Today, it's probably safe to say that Perl has the most robust regex engine </p>  in common use. Other languages and applications that have some form of regex </p>  support or pattern matching (and this by no means is a complete list) include: </p>  JavaScript, VBScript, PHP, Python, Tcl, Java, C, Macromedia Dreamweaver/Ultradev, </p>  ColdFusion and ColdFusion Studio, BBEdit, NoteTabPro, TextPad, UltraEdit, the </p>  XML Schema and XPath Recommendations, the various Unix tools used for text processing </p>  and their clones, and just about any modern application with a Find function.</p></p><h2>Conclusion</h2></p><p>Regular expressions are a powerful tool to keep in your web belt. They can </p>  appear daunting, but by learning a few simple rules, you can save yourself from </p>  hours of time doing manual find-and-replaces the slow, boring way.</p></p><p>I'll close with what may be the world's first (and undoubtedly the world's </p>  worst) regular expression joke:</p></p><p>What did one regex say to the other?</p></p><p>.+</p></p><h2>Other Resources</h2></p><p><p>[1] <a href="http://www.oreilly.com/catalog/regex/" target="_blank">Mastering </p>  Regular Expressions - Friedl</a><br></p>  <a href="http://www.regexlib.com" target="_blank">www.regexlib.com</a><br></p>  <a href="http://www.webreference.com/js/column5/" target="_blank">www.webreference.com/js/column5/</a></p></p><p><em>All the regular expressions in this article were tested using ColdFusion </p>  Studio 4.5.2, so you may encounter slight differences in different applications </p>  or languages. Thanks to <a href="http://purl.org/net/sbp/" target="_blank">Sean Palmer</a> for some expression testing.</em><br></p></p>