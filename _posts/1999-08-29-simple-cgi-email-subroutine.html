---
layout: post
permalink: node/398
ratings: 1
avgrate: 4.0000
user: MartinB
real_name: "Martin Burns"
user_since: 1999-04-26
avatar: "/images/pictures/picture-32.jpg"
article_count: 143
excerpt: "When I'm writing CGI programs, I find that many - if not most - need to send email at some point. Rather than rewrite a mailing routine every time, I produced a simple reuseable Perl subroutine. What"
---
When I'm writing CGI programs, I find that many - if not most - need to send email at some point. Rather than rewrite a mailing routine every time, I produced a simple reuseable Perl subroutine. What you're about to see is a simplified version of it, for you to build on yourself if you like.<p><a href='http://www.easyweb.co.uk/tutorials/sendmail_evolt_org.txt' target='_new' name='Download me'>Here</a>'s the subroutine. You'll need to save it locally, rename it with a <code>.pl</code> file extension, and upload it to your webserver.<p>System requirements<p></p>You'll need 3 things:</p><ol></p><li>A Unix server. It won't work on NT, but it might on MacOSX Server.</p><li>Access to Sendmail or an equivalent. Exim and qmail usually work just fine, but check with your sysadmin.</p><li>Perl5. Perl4 *should* work, but I can't promise anything.</p></ol><p>How to use it.<p></p>All you have to do is require the file, tell it where your Sendmail is, and call the subroutine with appropriate variables. Here's the most trivial example:</p><p><pre></p>!#/usr/bin/perl</p>require '/path/to/sendmail_evolt_org.pl';</p>$SENDMAIL = '/usr/bin/sendmail';</p>&amp;simple;_sendmail('Hello!', 'scripts@easyweb.co.uk', 'martin@easyweb.co.uk', 'Hello World');</p></pre></p><p>Easy!<p>The general format of the subroutine variables is:</p><blockquote></p>	<code></p>		subject, from, to, body, cc, bcc</p>	</code></p></blockquote></p>The body, cc and bcc variables are completely optional, and you can either have each variable literally used as above (make sure you use single quotes, or your @ signs will cause trouble), or derived from variables:</p><blockquote></p>	<code></p>		&amp;simple;_sendmail($subject, $from, $to, $body, $cc, $bcc);</p>	</code></p></blockquote><p>Limitations<p></p><ul></p><li>This subroutine doesn't check the validity of email address formats. If you're deriving any address from user input, it's wise to add some validation.</p><li>This subroutine doesn't attach files or support HTML email.</p><li>You can only use one recipient in each of the <code>from</code>, <code>cc</code> and <code>bcc</code> fields.</ul></p>None of these limitations is particularly taxing to rectify.<p>The routine<p></p>Let's step through it.</p><blockquote></p>	<code></p>		&nbsp;<font color='#0000cc'>67:</font> sub simple_sendmail {<br></p><font color='#0000cc'>102:</font> }<br></p><font color='#0000cc'>103:</font> 1;</p>	</code></p></blockquote></p>This is the bare outline of any subroutine. Because we're requiring the file, it works as if the file is part of the main script, so you don't need a <code>#!usr/bin/perl</code> line. All you have to do is ensure that it's in correct syntax, and the last line evaluates to <code>true</code>.<p><blockquote></p>	<code></p>		<font color='#0000cc'>69:</font> local($subject, $from, $to, $body, $cc, $bcc) = @_;</p>	</code></p></blockquote></p>This grabs the incoming data (stored in the Perl special variable @_), and puts it into sensible variable names. Because we're using <code>local</code> variables, there won't be any problems if you've used <code>$to</code> (etc) in your main script.<p><blockquote></p>	<code></p>	<font color='#0000cc'>73:</font> open(MAIL, &quot;&#124;$SENDMAIL -t&quot;);<br></p>    <font color='#0000cc'>75:</font> $&#124; = 1; </p>	</code></p></blockquote></p>This is the main engine of the script. Unix works in such a way that everything - programs included - can be considered as a file. So what we do here is open a connection to the 'file' that is the Sendmail program, and attach it to a filehandle, MAIL; just as if we were outputting to a real file. Line 75 ensures that each line will be dispatched as it's output, which will give a more reliable result.<p><blockquote></p>	<code></p>	<font color='#0000cc'>80:</font> print MAIL &quot;To: $to</p>&quot;;<br></p>    <font color='#0000cc'>81:</font> print MAIL &quot;From: $from</p>&quot;;<br></p>    <font color='#0000cc'>82:</font> print MAIL &quot;CC: $cc</p>&quot; if $cc;<br></p>    <font color='#0000cc'>83:</font> print MAIL &quot;BCC: $bcc</p>&quot; if $bcc;<br></p>    <font color='#0000cc'>84:</font> print MAIL &quot;Subject: $subject</p>&quot;;</p>	</code></p></blockquote></p>These are the functional headers, which tell the email where to go, who it's from, and what its subject is.<p>    </p><blockquote></p>	<code></p>		    <font color='#0000cc'>85:</font> print MAIL &quot;x-mailer: EasyWeb Design - email scripts@easyweb.co.uk</p>&quot;;<br></p>    <font color='#0000cc'>86:</font> print MAIL &quot;x-copyright: simple_sendmail 1.0, Copyright (C) 1999 Martin Burns</p>&quot;;<br></p>    <font color='#0000cc'>87:</font> print MAIL &quot;x-license: GNU General Public License version 2</p>&quot;;<br></p>    <font color='#0000cc'>88:</font> print MAIL &quot;x-license_url: http://evolt.org/index.cfm?menu=8&cid=137&catid=17</p><p>&quot;;</p>	</code></p></blockquote></p>If you've looked at our <a href='http://evolt.org/article/The_Headology_of_Email/18/392/index.html' name='The Headology of Email'>mail headers tutorial</a>, you'll remember that any header which begins with <code>x-</code> is ours to play with. So I've used it to add an unobtrusive credit to myself for the routine. Most people won't notice it, but someone who's in a position to give you work just might. I've also put on the licensing info for the routine, so that anyone literate enough to be interested in how it's done can find out what restrictions I've put on its distribution.<p>I also use the <code>x-mailer</code> header - typically used by email clients - to distinguish incoming email from forms. As I receive a bcc from most forms I install for monitoring and diagnostic purposes, I can filter them into my deleted mail folder, where they sit for 24 hours before they're auto-deleted. My mail client (Claris Emailer) also colour codes them for me, so it's easy to keep an eye what's going on.<p>The other important thing to notice is that, while most of the other headers end with a line-break to separate them, the last one ends with two. This is how mail clients know where the headers end, and the message body begins - there's a blank line between the two.<p>Finally, we get to print the body of the message, if there is one:</p>    <blockquote></p>	<code></p>	<font color='#0000cc'>93:</font> if ($body) {<br></p>    <font color='#0000cc'>94:</font>    &nbsp;&nbsp;print MAIL $body;<br></p>    <font color='#0000cc'>95:</font>        }<br></p>    <font color='#0000cc'>96:</font> print MAIL &quot;</p>&quot;;</p>	</code></p></blockquote></p>And there's another blank line at the end.<p>The very last thing we need to do is close the file handle:</p><blockquote></p>	<code></p>		<font color='#0000cc'>101:</font> close(MAIL);</p>	</code></p></blockquote><p>So there you have it - a simple, all-purpose mail subroutine.