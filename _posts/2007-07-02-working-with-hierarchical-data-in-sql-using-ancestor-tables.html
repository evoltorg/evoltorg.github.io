---
layout: post
permalink: working_with_hierarchical_data_in_sql_using_ancestor_tables
ratings: 0
avgrate: 
categories: [Software]
user: christian cadieux
real_name: "christian cadieux"
user_biog: ""
user_since: 06 Jun 2007
avatar: 
article_count: 1
excerpt: "<p>This document describe an approach to SQL queries of hierarchical data using ancestor tables. Multiple inheritance are allowed but cycles are not allowed for this approach to work.</p></p>"
---
<p>This document describe an approach to SQL queries of hierarchical data using ancestor tables. Multiple inheritance are allowed but cycles are not allowed for this approach to work.</p></p><p></p>This approach is most appropriate when recursive SQL is not available and the hierarchies are not too deep.</p>With ancestor tables, inserts and deletes are slower but selects are very fast and there is no need to update the whole tree with each insert.</p></p><p></p>We use this hierarchy of objects as an example to illustrate the problem:</p></p></p><img src="http://www.blogger.com/post-edit.g?blogID=36261639&postID=1111444548545387761" alt="" /></p><p><img src="http://docs.google.com/File?id=dd59kfz4_11g8w6tmtg" /></p><p></p>A common way to model this hierarchy is with a Parent table:</p></p></p><div><table border="1" cellpadding="3" cellspacing="0" height="194" width="153"><tbody><tr><td width="50%"><b>ObjectID</b></p></td><td width="50%"><b>ParentID</b></p></td></tr><tr><td align="center" width="50%">5</p></td><td align="center" width="50%">3</p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">3</p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">4</p></td></tr><tr><td align="center" width="50%">7</p></td><td align="center" width="50%">4</p></td></tr><tr><td align="center" width="50%">3</p></td><td align="center" width="50%">2</p></td></tr><tr><td align="center" width="50%">4</p></td><td align="center" width="50%">2</p></td></tr><tr><td align="center" valign="top">2</p></td><td align="center" valign="top">1</p></td></tr></tbody></table><br></p><p></p>This table can keep the relationships between the objects but does not allow to search for all the ancestors of an object or all the children of a parent using single SQL queries.</p></p><p></p>Using an ancestor table instead of a parent table has the advantage of flattening the relationships between object and simplifying the queries:</p></p></p><div><table border="1" cellpadding="1" cellspacing="0" height="362" width="259"><tbody><tr><td width="50%"><b>ObjectID</b></p></td><td width="50%"><b>AncestorID</b></p></td><td width="50%"><b>hops</p></b></td></tr><tr><td align="center" width="50%">5</p></td><td align="center" width="50%">3</p></td><td align="center" width="50%"><b>1</b></p></td></tr><tr><td align="center" width="50%">5</p></td><td align="center" width="50%">2</p></td><td align="center" width="50%">2</p></td></tr><tr><td align="center" width="50%">5</p></td><td align="center" width="50%">1</p></td><td align="center" width="50%">3</p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">3</p></td><td align="center" width="50%"><b>1</b></p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">2</p></td><td align="center" width="50%">2</p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">1</p></td><td align="center" width="50%">3</p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">4</p></td><td align="center" width="50%"><b>1</b></p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">2</p></td><td align="center" width="50%">2</p></td></tr><tr><td align="center" width="50%">6</p></td><td align="center" width="50%">1</p></td><td align="center" width="50%">3</p></td></tr><tr><td align="center" width="50%">7</p></td><td align="center" width="50%">4</p></td><td align="center" width="50%"><b>1</b></p></td></tr><tr><td align="center" width="50%">7</p></td><td align="center" width="50%">2</p></td><td align="center" width="50%">2</p></td></tr><tr><td align="center" valign="top">7</p></td><td align="center" valign="top">1</p></td><td align="center">3</p></td></tr><tr><td align="center" valign="top">3</p></td><td align="center" valign="top">2</p></td><td align="center"><b>1</b></p></td></tr><tr><td align="center" valign="top">3</p></td><td align="center" valign="top">1</p></td><td align="center">2</p></td></tr><tr><td align="center" valign="top">4</p></td><td align="center" valign="top">2</p></td><td align="center"><b>1</b></p></td></tr><tr><td align="center" valign="top">4</p></td><td align="center" valign="top">1</p></td><td align="center">2</p></td></tr><tr><td align="center" valign="top">2</p></td><td align="center" valign="top">1</p></td><td align="center"><b>1</b></p></td></tr></tbody></table></div><br></p><p></p>Modeling the same hierarchy requires more records when ancestors are explicitly recorded but it simplifies the queries. For example, to get all the children of object-1:</p></p></p><code></p>select distinct object_id  from ancestor_table where ancestor_id = 1;</p>object_id</p>=======</p>5</p>6</p>7</p>3</p>4</p>2</p></code></p><p><p></p>In order to preserve the hierarchical order, a third column called 'hops' can be added to the table. This is useful when query results need to be in order of proximity of the object to the ancestor. Saving the number of hops information in the table also allows to recontruct the table from scratch by first deleting all the records with hops &gt; 1 and then re-inserting all the ancestors. The records with hops=1 are equivalent to the parent table, hops&gt; 1 are the ancestor records.</p></p><p></p>It is also important to have the ability to add and delete associations from this graph without having to re-write the complete tree to the database. This is the general algorithm for inserting and deleting an association in the graph:</p></p> </p><blockquote>To add an association between child1 and parent1, find all the parents of parent1 and attach them to each children of child1</blockquote></p><p></p>Similarly, for deleting an association:</p></p></p><blockquote>To remove an association between child1 and parent1, find all the parents of parent1 and remove them from each child of child1</blockquote></p><p></p>For this solution to work, redundant associations need to be recorded in the database. In our example, there is two associations between object-6 and object-2, one using object-3 and one using object-4. They both need to be present in the ancestor table. This allows the delete function to delete only one of the two associations. In our example, even after removing the object-3 to object-2 association, object-6 can still reach object-2.</p></p><p></p>The insert and delete algorithms need to properly maintain the 'hops' value. Updates need to be converted into a delete and insert combination.</p></p><p></p>Here are the two algorithms in Perl:</p><p></p><code></p>sub insert_association {</p>  my($child, $parent) = @_;</p>  # give all group ancestors to all children of group. </p>  my $rc = sql("select ancestor_id, hops from ancestor_table  where object_id = $parent"); </p>  my $rc2 = sql("select group_id,hops from ancestor_table  where ancestor_id = $child "); </p>  foreach my $obj (@$rc2) { </p>    foreach my $anc (@$rc) { </p>       my $hops = $obj->[1] + $anc->[1] + 1; # adjust the hops</p>       sql("insert into ancestor_table (object_id,  ancestor_id, hops)  </p>           values ($obj->[0], $anc->[0], $hops )");</p>    }</p>  }</p>}</code></p><p></p><code></p>sub delete_association {</p>   my($child, $parent) = @_;</p>   # remove parent and it's ancestors from group and its children </p>   my $rc = sql("select ancestor_id,hops from ancestor_table  where object_id = $parent "); </p>   my $rc2 = sql("select object_id,hops from ancestor_table  where ancestor_id = $child"); </p><p>   foreach my $c (@$rc2) { </p>      foreach my $p (@$rc) { </p>      my $hops = $c->[1] + $p->[1] + 1; </p>      my $rc3 = sql("select oid,hops from ancestor_table </p>           where object_id = $c->[0] and ancestor_id =  $p->[0] and hops = $hops");</p>      # delete only one association, with the right hops.</p>      # oid is a postgres generated sequence_id used to identify each    association.</p>      foreach my $o (@$rc3) { </p>         sql("delete from ancestor_table where oid =  $o->[0]"); </p>         last; </p>      } </p>    }</p>}</p></code></p>