---
layout: post
permalink: node/27855
ratings: 4
avgrate: 4.2500
user: Nautilus
real_name: ""
user_since: 
avatar: ""
article_count: 0
excerpt: "Ever had problems putting HTML within XML? Here's a solution that will let you leave your HTML in peace &#8212; providing backwards compatible HTML in your XML applications."
---
<p>Ever tried adding HTML within XML, but can't keep the XML validated? Using ASP as the backend to create your XML output, this solution will provide backwards compatible HTML in your XML applications.</p></p><p><h2>Why Would I Do That?</h2></p><p><p>When developing an XML news feed, a forum or a CMS feature to create webpages, a useful feature to include is the ability to edit the HTML input right in the web (a lot like the process used by evolt.org for adding these articles)</p></p><p><p>Anyway, the downside to this is the need to embed these HTML fragments created, within XML resultsets without modification at XML creation stage so they can be written to the HTML based forums, or added to the XML news feed while keeping the HTML formatting. </p></p><p><h2>For example</h2></p><p><p>Say you have an XML news feed pulling news (TITLE and DATA) from a database. Its easy with just plain text stored in the database, just grab it and print it - the XML and XSL do the hard work.<br><strong>But</strong> what if you have HTML tags in the news feed (images, tables, font styles, etc). The HTML would displays ok if it where on a normal page, but how will it look when passed through the XML parser and displayed as part of the XML feed?</p></p><p><h2>So, Where's The Problem?</h2></p><p><p>The problem is that HTML is not well-formed XML, and I don't want to get into the process of processing the text input into the text boxes to validate the HTML tags, client or server side, since HTML can be very sloppily put together and still work. Key point being, you don't want any unneccessary processing of what could be potentially large HTML strings, whether at read or write stage. So, here's what to do about it:</p></p><p><h3>The XML :</h3></p><p><p>When I retrieve the HTML and create the XML output, I put the untouched HTML into an XML fragment using ASP code like this:</p></p><p><pre></p>' Here I concatenate in the data's title record</p>' which is not XML, so I process it using a simple</p>' XMLEncode function which replaces all the</p>' reserved XML character Entities</p><p>sXML = sXML & "  &lt;TITLE&gt;" & XMLEncode(RS("Title")) & "&lt;/TITLE&gt;" & vbcrlf</p><p>' The following line places the HTML in a comment block</p>' which means it will be completely ignored by any XML</p>' validation, hence can contain malformed XML.</p><p>sXML = sXML & "  &lt;DATA&gt;&lt;!--" & RS("Data") & "--&gt;&lt;/DATA&gt;" & vbcrlf</p></pre></p><p><h3>The XSL:</h3></p><p><p>This part is very easy, but there's two things you must always remember. The typical way of spitting out the &lt;TITLE&gt; element's content's would be:</p></p><p><p></p><code>&lt;xsl:value-of select="TITLE"/&gt;</code></p></p></p><p><p>The way to output the Embedded HTML is to use the comment() XPath Node test. The other very important step is to add the disable-output-escaping="yes" attribute to your value-of element. So:</p></p><p><p></p><code>&lt;xsl:value-of select="DATA/comment()" disable-output-escaping="yes"/&gt;</code></p><p></p><p><p>outputs the HTML intact. The disable output escaping prevents your HTML looking like &lt;HTML&gt; which is not the desired effect. Lastly, to prevent the XSL Processor spitting out crap instead of all your nice font characters, use encoding on both the XML and XSL files to prevent errors.</p></p><p><h2>The Final Code:</h2></p><p><h3>XML:</h3></p><p><pre></p>&lt;?xml version="1.0" encoding="iso-8850-150"?&gt;</p>&lt;MYDATA&gt;</p>    &lt;TITLE&gt;This is a News Title&lt;/TITLE&gt;</p>    &lt;HTMLDATA&gt;</p>        &lt;!--</p>        &lt;BODY bgcolor=white&gt;&lt;P&gt;This contains malformed HTML&lt;BR&gt;</p>        &lt;IMG SRC=http://www.evolt.org/images/logo.gif width=120 height=30&gt;</p>        --&gt;</p>    &lt;/HTMLDATA&gt;</p>&lt;/MYDATA&gt;</p></pre></p><p><h3>XSL:</h3></p><p><pre></p>&lt;?xml version="1.0" encoding="iso-8850-150"?&gt;</p>&lt;xsl:stylesheet&gt;</p><p>&lt;xsl:template match="/"&gt;</p>      &lt;xsl:value-of select="MYDATA/TITLE"/&gt;</p>      &lt;xsl:value-of select="MYDATA/HTMLDATA/comment()" disable-output-escaping="yes"/&gt;</p>&lt;/xsl:template&gt;</p><p>&lt;/xsl:stylesheet&gt;</p></pre></p><p><p>You now have a page with an invalid HTML layout, but which still validates properly as XML.</p>