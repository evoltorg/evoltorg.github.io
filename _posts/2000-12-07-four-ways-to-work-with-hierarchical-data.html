---
layout: post
permalink: node/4047
ratings: 11
avgrate: 4.4545
categories: [Code]
user: ghost_inside
real_name: "Kirby Fling"
user_biog: ""
user_since: 05 Dec 2000
avatar: 
article_count: 1
excerpt: "Many thanks to RatFace for his article BBS style recursion How-To.  I have also recently been wrestling with the concept of displaying heirarchical lists, specifically in a discussion forum tool that I\'ve been writing."
---
<p>Many thanks to <a href="/user/ratface/300/evolt.org">RatFace</a> for his article  </p><a href="/article/BBS_style_recursion_How_To/17/3962/evolt.org">BBS style recursion How-To</a>.  I have also recently been wrestling with the concept of displaying heirarchical lists, specifically in a discussion forum tool that I've been writing.</p><p>I've spent quite a bit of time working out the data structure and display methods for the concept of heirarchical data and I've come to the conclusion that there are four main programming methods to approach the problem:</p><ol></p><li>Recursion</p><li>Stack</p><li>Flat Table</p><li>Modified Preorder Tree Traversal Algorithm</p></ol></p><p>So let's begin our discussion of each method:</p></p><p><h2><a name="recursion"></a>Recursion</h2></p><p>To many computer science types, recursion is frequently found to be the most &quot;elegant&quot; method to drill down through a hierarchical list of data.  </p><p>And I would have to agree with that summation, but then again, that might be my first year of computer science speaking.  (&quot;Welcome to CS 101: Recursion until your head explodes&quot;)</p><p>The reason it is such an &quot;elegant&quot; solution is that you essentually have one function that does all of your data processing, display, and iteration to possible children.  You call the function once (with the root of the tree) and everything is done.  The added benefit is that you can call the function with any subnode of the tree and it will display the entire subtree without an additional logic or coding effort.  In pseudo-code, a hierarchical list display function would look something like this:</p></p><p></p><pre></p>function DisplayChildren(uid, indent_level)</p>  SELECT id, (info)</p>  FROM (db)</p>  WHERE ParentID = uid</p><p>  if recordcount &gt; 0 then </p>    (indent by indent_level) (HTML to display info for this child)</p>    child_id = recordset.id</p>    DisplayChildren(child_id, indent_level+1)</p>  end if</p>end function</p></pre></p></p></p><p><p>That's really all there is to the recursive method, which is why it's seen as such an elegant solution.</p></p><p><h4>Disadvantages</h4></p><p><p>The problem is that the vast majority of coding solutions we have at our disposal handle recursion very poorly.  The idea is that every function (ideally) gets executed in its own memory space.  And have to leave cleanup to whatever middleware we are using.  So let's do a quick little check on efficiency with arbitrary numbers.</p></p><p><p>Let's take the following to be true (just for example):</p><ul></p><li>Each time we get one record from the DB, it takes <code>n</code> seconds.</li></p><li>Each DB connection/disconnection takes <code>n * 2</code> seconds.</li></p><li>Allocating memory for a new incidence of the function takes <code>n/10 * iteration</code> seconds (in ASP, and Cold Fusion, recursive algorithms have demonstrated a logorithmic decay in performance).</li></p></ul></p><p>So, if we had 1000 messages in our discussion forum, the equation would look something like this: <code>(1000 * n) + (1000 * n * 2) + (n/10 * iteration)</code>.  Take a look at the following chart for better clarification:</p><p><p></p><pre></p>Record    1:   3 * n seconds</p>Record  250:  29 * n seconds</p>Record  500:  53 * n seconds</p>Record  750:  79 * n seconds</p>Record 1000: 103 * n seconds</p>----------------------------</p>Total = approx 50,000 * n seconds</p></pre></p></p></p><p><p>As you can see, that logorithmic decay really ends up biting in the end.  And granted, the numbers I used are just for the sake of example, but you can see that there is a fundamental issue of excess over head with the recursion model.  It <em>is</em> a very elegant model, it fits in your head very well, and in the code even better, but unless the system you are using is designed for recursion (e.g. scheme, lisp, etc), you will always run into excessive overhead when the numbers start getting huge.</p></p><p><h2><a name="stack"></a>Using a Stack</h2></p><p><p>The stack is usually the second method of approaching large, crazy lists.  There are 2 types of stack programming:  </p><u>F</u>irst </p><u>I</u>n </p><u>F</u>irst </p><u>O</u>ut and </p><u>F</u>irst </p><u>I</u>n </p><u>L</u>ast </p><u>O</u>ut.</p>When working with heirachcical lists, you have to use the FILO model.  The idea is that</p>you create a stack somewhere, which is essentially just a list.  Then add the id of the record you are currently working with, and when you are done with that record, you pull it off the list.  If that record has any children, then you start working with the first child and put it's id at the end of the list. etc.</p></p><p><p>Much like the recursion model, the data looks something like this:</p></p><p><table border="1" cellspacing="0"></p><tr align="left"><th>Field:</th><th>Type:</th><th>Null:</th><th>Comments:</th></tr></p><tr valign="top"><td>UID</td><td>int, numeric, etc.</td><td>no</td><td>the unique identifier for each record</td></tr></p><tr valign="top"><td>name, title, etc</td><td>varchar(x)</td><td>yes</td><td>the name or title of this record</td></tr></p><tr valign="top"><td>ParentID</td><td>int, numeric, etc.</td><td>yes</td><td>the UID of the parent to this object, NULL for the top level of the tree</td></tr></p></table></p><p><p>But now the question is whether you want to do everything in the middlewareor closer to the data in an SQL stored procedure.</p></p><p>Advantages to running the stack model in your middleware:</p></p><ol></p>  <li>you can display your HTML inside each iteration.</li></p>  <li>easier to code/read/modify?</li></p></ol></p><p>Disadvantages:</p></p><ol></p>  <li>just as many DB connections being created as in the recursive model</li></p></ol></p><p>Advantages of running the stack with a stored procedure:</p></p><ol></p>  <li>executes closer to the data, so it's faster</li></p>  <li>gives you a compiled temp table that needs little effort in the middleware</li></p>  <li>only one connection to the database</li></p></ol></p><p>Disadvantages:</p></p><ol></p>  <li>you might not be able to run stored procedures on your DB system</li></p>  <li>you might not have access to create stored procedured on your DB system</li></p>  <li>more difficult to code/read/manage it it's remote and in a different language</li></p></ol></p><p><p>Here is the code for a hierarchical stack algorithm that is outlined in the Microsost SQL 6.5 documentation as an example:</p></p><p><p></p><pre></p>CREATE PROC expand (@current char(20)) AS</p>SET nocount on</p>DECLARE @level int, @line char(20)</p>CREATE TABLE #stack (item char(20), level int)</p>INSERT INTO #stack VALUES (@current, 1)</p>SELECT @level = 1</p>WHILE @level &gt; 0</p>BEGIN</p>  if EXISTS (SELECT * FROM #stack WHERE level = @level)</p>    BEGIN</p>      SELECT @current = item</p>      FROM #stack</p>      WHERE level = @level</p>      SELECT @line = space(@level - 1)  @current</p>      PRINT @line</p>      DELETE FROM #stack</p>      WHERE level = @level</p>        AND item = @current</p>      INSERT #stack</p>      SELECT child, @level  1</p>      FROM hierarchy</p>      WHERE parent = @current</p>      if @@rowcount &gt; 0</p>        SELECT @level = @level  1</p>    END</p>  else</p>    SELECT @level = @level - 1</p>END</p></pre></p></p></p><p><p>You can modify the concept in this code to fit your particular middleware.</p></p><p>Now let's take a look at the theoretical efficiency numbers like we did in therecursive model:</p></p><p>Let's take the following to be true (just for example):</p></p><ul></p>  <li>Each time we get one record from the DB, it takes <code>n</code> seconds.</li></p>  <li>Each DB connection/disconnection (from middleware) takes <code>n * 2</code>  seconds.</li></p>  <li>Time to execute the list/stack operations is almost nonexistant</li></p>  <li>Time to create the temporary table in the stored procedure takes <code>n / 2</code> seconds</li></p></ul></p><p>So, we have the same 1000 messages in our discussion forum, the equation would look something like this:</p></p><p>Running the Stack with middleware: <code>(1000 * n) + (1000 * n * 2) = 3000 * n</code></p></p><p>Running the Stack with a stored procedure: <code>(1000 * n) + (2 * n) + (1000 * (n / 2)) = 1502 * n</code></p></p><p><h2><a name="table"></a>Flat Table Model</h2></p><p><p>While I was building my discussion forum, I immediately went for the recursive model to get my data and display it on the screen.  I successfully built my forum in both Cold Fusion and ASP.  It worked in both, but I wasn't very happy with the performance of either.  I decided to investigate other ways of turning a sequence of parent-child relationships into a hierarchical list of data.  I started playing with the stack model, and eventually discovered the stored procedure method, and while I was working with that, I had this little flash of insight:</p></p><p><p><b>A flat table will always yield the fastest query.</b></p></p><p><p>So I started asking myself &quot;How do I turn the data I've got (or am about to get) into a flat table?&quot;  As it turns out, it's really quite easy.  Take the example of a discussion forum.  What information is really on the page? If the information looks like this:</p></p></p><p><table border="0" cellpadding="0" cellspacing="0"></p><tr valign="top"><td>&quot;hello world&quot;</td><td>johnDoe</td><td>12/2/00</td></tr></p><tr valign="top"><td> &nbsp; &quot;Re: hello world&quot;</td><td>janeDoe</td><td>12/4/00</td></tr></p><tr valign="top"><td> &nbsp; &quot;How is your foobar?&quot;</td><td>johnDoe</td><td>12/3/00</td></tr></p><tr valign="top"><td> &nbsp; &nbsp; &quot;my foobar is fine&quot;</td><td>sysadmin</td><td>12/2/00</td></tr></p><tr valign="top"><td> &nbsp; &quot;hello yourself&quot;</td><td>jackDoe</td><td>12/2/00</td></tr></p><tr valign="top"><td>&quot;my app RuLeZ&quot;</td><td>idiotboy</td><td>12/1/00</td></tr></p><tr valign="top"><td> &nbsp; &quot;learn how to spell&quot; </td><td>jacksnot</td><td>12/2/00</td></tr></p></table>  </p>     </p><p>Everybody sees that there is a subject, author and date.  But the indenting on the left is usually seen as the parent-child  relationship.  &quot;my foobar is fine&quot; is a child of &quot;How is your foobar?&quot; etc.  But you can also look at it apart from the parent-child relationship and see it as:</p></p><ol></p>  <li>the order in which to be displayed</li></p>  <li>the level to be indented</li></p></ol></p><p>So, we can contruct the data schema to look something like this:</p></p><table border="1" cellspacing="0"></p><tr align="left"><th>Field:</th><th>Type:</th><th>Null:</th><th>Comments:</th></tr></p><tr valign="top"><td>UID</td><td>int, numeric, etc.</td><td>no</td><td>the unique identifier for each record</td></tr></p><tr valign="top"><td>name, title, etc</td><td>varchar(x)</td><td>yes</td><td>the name or title of this record</td></tr></p><tr valign="top"><td>ParentID</td><td>int, numeric, etc.</td><td>yes</td><td>the UID of the parent to this object, NULL for the top level of the tree</td></tr></p><tr valign="top"><td>rank (or display_order)</td><td>int, numeric, etc.</td><td>yes</td><td>the order to display all records</td></tr></p><tr valign="top"><td>indent_level</td><td>int, numeric, etc.</td><td>yes</td><td>how much to indent this item</td></tr></p></table></p><p><p>Now, how do we work with this data structure once it's built? The selection of the data is easy:</p></p><p><p></p><pre></p>function DisplayChildren()</p>  SELECT id, (info), indent_level</p>  FROM (db)</p>  ORDER BY rank</p><p>    while the recordset isn't empty {</p>      (indent by indent_level) (HTML to display info for this child)</p>    }</p>end function</p></pre></p></p></p><p><p>But, as easy as that is, the difficulty is now shifted to the point of insertion. The indent level is easy, it is always (parent.indent_level + 1).  The display_order (or rank) is a little more challenging.  The rank of the new child needs to be greater than it's parent, but less than any of it's children or the next sibling at the same level. In the example above a new child of "hello world" should have a rank of 2.  But if they were all ranked from 1 to 7 to begin with, that means that you need to increment the rank of all messages whose rank is greater than 1.  Which just happens to be the parent of the child we are inserting. So you end up calling a stored procedure that looks something like this:</p></p><p><p></p><pre></p>CREATE PROC increment_rank (@start_rank int) AS</p>  BEGIN</p>    UPDATE (table_name)</p>    SET rank = rank + 1</p>    WHERE rank &gt; @start_rank</p>  END</p></pre></p></p></p><p><p>Note: you can do this in middleware if you need, but it's such a simply query that will gain such benefit from a pre-compiled query path that a stored procedure is the best way to go.</p></p><p><p>This solution ends up with the biggest database hit at the point of insertion, but even that hit isn't terribly bad, and the lessening of the hit for each view of the folder is VERY significant.  Let's go back to our efficiency numbers for a moment:</p></p><p><p>Let's take the following to be true (just for example):</p></p><ul></p>  <li>Each time we get one record from the DB, it takes <code>n</code> seconds.</li></p>  <li>Each DB connection/disconnection (from middleware) takes <code>n * 2</code> seconds.</li></p></ul></p><p><p>In order to view all of of our 1000 example messages, the equation looks like this: <code>(1000 * n) + (2 * n) = 1002 * n</code></p></p><p>But in order to be fair, we also have to look at our numbers for the insertion of a given message...</p></p><p><p>Let's take the following to be true (just for example):</p></p><ul></p>  <li>Each time a record is inserted, it takes <code>n * 2</code> seconds.</li></p>  <li>Each time a record is updated, it takes <code>n * 2</code> seconds.</li></p></ul></p><p><p>So, for both the recursive and stack models, the cost of insertion is simply: (connection + insertion) <code>n * 2 + n * 2 = n * 4 </code></p></p><p>But for the flat table model, the cost of insertion is something akin to: (connection + updating 1-1000 records + insertion) <code>n * 2 + (n * 2 * x) + n * 2 = [6n to 1004n]</code></p></p><p><p>As you can see, the cost of insertion is MUCH higher for the flat table model, but even the highest cost of insertion is not as high as the fastest <em>viewing</em> method that we've discussed thus far (the stored procedure/stack model @ 1502 * n).  And the viewing</p>speed is 30% faster.  So if you expand the numbers to include some kind of usage metric, with an estimated 8,000 page views a month, and an estimated 300 messaged inserted a month.  The flat table model is the hands down winner.....  for a discussion forum....</p></p><p><h4>Disadvantages</h4></p><p><p>Which brings us to our disadvantages to the flat table model.  It isn't easily ported to a lot of other uses.  With a discussion forum, you almost always want it sorted hierarchically, then by date descending.  And the rank-increment method works perfectly</p>for this application.  If you wanted to sort it by date ascending, it is still relatively easy (insert the child before the next message with the same parent id).  But for other large lists of information that needs to be displayed hierarchically, it's very difficult to get them to display properly without some kind of re-ordering interface that you can </p>expose to whoever is in charge of the information.  In my experience, that is almost always the case anyway so the flat table model is once again a viable option for your hierarchical list pages.</p></p><p><h2><a name="treetraversal"></a>A Modified Preorder Tree Traversal Algorithm</h2></p><p><p>To be completely honest, I've never used this method for working with hierarchical data, and I don't even understand it that well.  I read about in a book called <a target="newwindow" href="http://www.amazon.com/exec/obidos/ASIN/1558605762/o/qid=976072005/sr=8-1/ref=aps_sr_b_1_3/002-7271924-9125651">SQL for Smarties</a></p>where Joe Celko devotes 2 entire chapters to working with hierarchical data in databases that aren't really designed to.  I figured I should at least make a reference to this method since it purportedly has so many great advantages to the traditional parent-child relationship model.</p></p><p><p>The basic idea is that you start at the right-most branch of the root of your tree and give it a 1 where the relationship starts and a 2 where it ends.  Then you take that node's right-most relationship and give it a 3 where it starts and a 4 where it ends.  So that node ends up with 2 numbers: left and right.  Decrement the &quot;left&quot; and you get the &quot;right&quot; of it's parent, increment the &quot;right&quot; and you get either it's child or it's sibling at the same level.  Continue that idea all the way around the tree until you are back at the root again.  Each object ends up with 2 numbers and from those number you can run some fun queries and come up with lots of information about that particular node, the tree in general, paths between different nodes and lots of other stuff.  But as I said, I don't fully understand it yet.  Maybe when I do, I'll write another article.</p></p><p><p>Here are some more links I've found on tree traversal:</p></p><p><ul></p>  <li><a target="newwindow" href="http://www.guides.sk/data_structures/lect13/lecture.htm">Trees - General &amp; Binary</a></li></p>  <li><a target="newwindow" href="http://pirun.ku.ac.th/~b39prp/discrete/traversal.html">Tree Traversal</a></li></p></ul>