---
layout: post
permalink: node/360
ratings: 1
avgrate: 4.0000
rating: 3.91
categories: [Code]
user: dmah
real_name: "Dean Mah"
user_biog: "<p>Founding member of evolt.org.<br />
<a href=\"http://claimid.com/dmah\" rel=\"nofollow\"><img src=\"http://claimid.com/images/claimid_badge.gif\" border=\"0\" alt=\"Dean Mah\" title=\"Dean Mah\"/></a>
</p>
"
user_since: 05 Jun 1999
avatar: /images/pictures/picture-92.jpg
article_count: 25
excerpt: "Have you ever needed to change the text in a</p>bunch of files quickly? Here's one way in Perl."
---
<p>Have you ever needed to change the text in a</p>bunch of files quickly?  You could open each file</p>and then do a search-and-replace.  This process</p>can be time-consuming, tedious, and error-prone.</p>So instead, let's automate this task with</p>Perl.</p></p><p><p><strong>The </p>Code</strong></p></p><p><pre></p>#!/usr/local/bin/perl</p>#</p># Replaces a string within multiple files</p># specified on the command line</p><p>$mv = '/bin/mv';</p><p>$op = shift &#124;&#124; die(&quot;Usage: $0 perlexpr [filenames]</p>&quot;);</p><p>if (!@ARGV) {</p>  @ARGV = &lt;STDIN&gt;;</p>  chop(@ARGV);</p>}</p><p>foreach $file (@ARGV) {</p>  if (!-f $file) {</p>       print &quot;Skipping non-regular file: $file</p>&quot;;</p>       next;</p>  }</p>  if (-B $file) {</p>       print &quot;Skipping binary file: $file</p>&quot;;</p>       next;</p>  }</p><p>  $outfile = &quot;/usr/tmp/$file.$$&quot;;</p><p>  open(FILE, $file) &#124;&#124;</p>       die(&quot;Couldn't open $file: $!</p>&quot;);</p>  undef $/;</p>  $_ = &lt;FILE&gt;;</p>  close(FILE);</p><p>  if (eval $op) {</p>    open(OFILE, &quot;&gt; $outfile&quot;) &#124;&#124;</p>        die(&quot;Couldn't open $outfile: $!</p>&quot;);</p>    print OFILE;</p>    close(OFILE);</p><p>    system($mv, '-f', $file, &quot;$file.bak&quot;);</p>    system($mv, '-f', $outfile, $file);</p><p>    print &quot;File changed: $file</p>&quot;;</p>  }</p>  else {</p>    print &quot;No change to file: $file</p>&quot;;</p>  }</p>}</p><p>exit(0);</p></pre></p><p><p><strong>The Explanation</strong></p></p><p><p>Save the above code into a file called</p><strong>replace</strong>.  Make sure that the</p>permissions are set correctly so that you can</p>execute the script.  Also check to make sure that</p>your Perl interpreter is in /usr/local/bin.  If</p>Perl is somewhere else, you'll need to change the</p>first line to point to where Perl is installed on</p>your system.  Finally, check to make sure that</p>your <strong>mv</strong> executable is in /bin</p>which it should be.  If not, you'll need to change</p>line 6, <strong>$mv = '/bin/mv';</strong> to point </p>to the correct location of the executable.</p></p><p><p>To use the script you would type:</p></p><p><p><blockquote>replace perlexpr</p>[files]</blockquote></p></p><p><p>where <strong>perlexpr</strong> is the</p>substitution operator, i.e., s///.  You can</p>actually pass any Perl expression through to</p><strong>perlexpr</strong> allowing you to do more</p>complex text substitutions.  If you decide to</p>that, however, make sure that your expression</p>leaves the block with a non-zero value if you want </p>the change to take place.  It's easiest to make</p>this value the number of replacements that</p>actually occurred.  The <strong>files</strong></p>argument is a list of filesname that you want to</p>change.  You can leave this argument out and the</p>script will take a list of names from STDIN.</p></p><p><p>The script works by reading in each text file</p>that is passed to it and evaluating the Perl</p>expression that is supplied on the command-line.</p>If the expression evaluates to TRUE, it creates a</p>temporary file containing the changes, makes a</p>backup of the original file</p>(<em>filename</em>.bak), and then copies the</p>changed file over top of the original file.  Also,</p>since the script reads the entire file into a</p>single scalar variable, you'll probably want to</p>use the /g modifier to any substitution commands</p>that you pass in; this will ensure that multiple</p>occurrences are replaced and not just the first</p>one.</p></p><p><p><strong>The Examples</strong></p></p><p><ol></p><li><p>Your company has changed its name from 'Get</p>Rich Quick Corp.' to 'Suckers Are Us' and you need </p>to change all your Web pages to reflect this.</p></p><p><blockquote>replace 's/Get Rich Quick</p>Corp\./Suckers Are Us/g' *</blockquote></p><p><li><p>The new guy in your office has started</p>using .htm in all of his links while the files are </p>actually end in .html.</p></p><p><blockquote>replace 's/\.htm\&quot;/\.html\&quot;/g'</p>*.htm</blockquote></p><p><p>You can then use your</p><a href="http://evolt.org/article/Renaming_Files_with_Perl/17/351/index.html">rename</p>script</a> to change the file suffixes from .htm</p>to .html.</p></p><p><p><strong>Note:</strong> This assumes that your</p>links end with a double quotation mark and that</p>.htm&quot; does not appear anywhere but in a</p>link.</p></p><p><li><p>You want to highlight all references to my</p>name in your files.</p></p><p><blockquote>replace 's!Dean Mah!&lt;strong&gt;Dean</p>Mah&lt;/strong&gt;!g' *</blockquote></p></ol></p><p><p>The standard warning applies here when using</p>regular expressions, make your expressions as</p>specific as possible, otherwise they are bound to</p>match something that you didn't want it to.  To be</p>safe, you should compare the original file with</p>the changed file using something like</p><strong>diff</strong> to make sure that only the</p>changes that you wanted occurred.</p></p><p><p>If you have any problems or questions about</p>this script, you can e-mail them to me at:</p><a href="mailto:dmah@vox.org">dmah@vox.org</a>.</p>