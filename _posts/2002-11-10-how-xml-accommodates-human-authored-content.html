---
layout: post
permalink: node/47030
ratings: 1
avgrate: 4.0000
category: Code
user: dougdomeny
real_name: "Doug Domeny"
user_since: 30 Apr 2002
avatar: "/images/pictures/picture-25912.gif"
article_count: 1
excerpt: "Widespread adoption of XML technology depends on DTD and schema designs that provide a structure convenient for humans. In other words, people will use XML only if it is easy and solves a problem. Managing semi-structured content for multiple audiences across multiple media (for example, the web, te"
---
<p>XML is gaining acceptance today, not because it is a great technology looking for a problem, but because today's problems require its flexibility and simplicity. XML enables you to create structured and semi-structured documents that can be transferred and read by people and programs in multiple formats (for example, pages that can be read on the web, handheld devices and print). This &quot;multi-use&quot; of content is the driving force behind the adoption of XML technology.</p></p><p><p>Today, most of the world's information is locked in paper, unsearchable documents with proprietary file formats, or web pages where search engines return too much data and not enough information. Just think about how much your company has spent to create documents that can't be easily found or distributed because they are unstructured.</p></p><p><p>XML lets business users create structured documents that can be leveraged for multiple purposes in-house and exchanged to people and businesses around the world. XML breaks new ground by connecting the front office business users with the back office developers.</p></p><p><p>Bill Trippe, in his article &quot;Do XML Editors Matter?&quot; (<cite>Transform</cite>	October 2001, page 27), makes this point by saying, &quot;You can view XML as the bridge between the two worlds of structured (relational) and unstructured (document) data.&quot; He continues, &quot;On one hand, you have a growing need for content to be tagged at its source and maintained in a structured form. On the other hand, users are resistant to more complex tools and processes.&quot;</p></p><p><p>Like a telephone line, which carries both voice and data, XML can carry information suitable for computers and people.� Computer-generated XML is dynamically created by a program for B2B ecommerce or other server-to-server transaction. These applications are addressed by XML standards such as ebXML and SOAP.� Human-authored content uses XML for improved search capabilities, multi-channeled publication, and syndication. These applications are addressed by standards such as MathML, NewsML, VoiceXML, and any number of custom XML dialects. This article focuses on how to apply XML to human-authored content.</p></p><p><h2>How XML Accommodates Human-Authored Content</h2></p><p><p>While highly structured data is independent of the style used to present it, unstructured data is full of style and format. Contrast plain text (no style) with rich text (full of style).</p></p><p><p>Text documents meant for human authoring and reading have design needs that only XML can address. Examples of semi-structured documents include catalogs, press releases, news reports, and technical documentation. Even highly structured data becomes semi-structured if it includes comments, descriptions, or instructions meant to be read by people.</p></p><p><p>XML supports the development of semi-structured documents that contain both relational meta data (the structure) and free-form (unstructured) formatted text. The meta data (that is, the XML tags) meets the programmatic need for structure. Without meta data, a computer program cannot understand the content. Formatted text meets the human and business need to express richly styled content. Without style, the content is dry and unattractive.</p></p><p><p>The paragraph you are reading now is an example of formatted text. Most document editors display content (unstructured data) as WYSIWYG (what you see is what you get). For a business user to comfortably create semi-structured textual documents, a document editor must allow the author to add style to the text.</p></p><p><h2>Variations of Structured and Unstructured Data</h2></p><p><p>Two kinds of semi-structured data exist between highly structured and unstructured data:</p></p><p><ul></p>	<li>highly structured data</li></p>	<li>structured data with unstructured elements</li></p>	<li>unstructured documents with tagged meta data</li></p>	<li>unstructured documents</li></p></ul></p><p><p>Structured data with unstructured elements is commonly used in web forms, where most fields are tightly constrained (for example, &quot;State&quot; must be selected from a list and &quot;ZIP&quot; must be all digits), yet a 'comment' field is available for human-readable content.</p></p><p><p>For example,</p></p><p><pre>&lt;product&gt;</p>��� &lt;name&gt;Deluxe Widget&lt;/name&gt;</p>��� &lt;listprice units="usd"&gt;$19.95&lt;/listprice&gt;</p>��� &lt;radius&gt;6mm&lt;/radius&gt;</p>��� &lt;description&gt;</p>��� This &lt;em&gt;deluxe &lt;strong&gt;gold&lt;/strong&gt; plated&lt;/em&gt; product fits most attachments.</p>��� &lt;/description&gt;</p>&lt;/product&gt;</pre></p><p><p>For this kind of document, use a DTD or schema to validate the structure, and include an unstructured element (for example, description) that allows both text and tags. In a DTD, this element would typically be defined as</p></p><p><p><code>&lt;!ELEMENT description ANY&gt;</code></p></p><p><p>Unstructured documents with tagged meta data are less common but offer the best promise for content that can be effectively searched. HTML provides some meta tags, like <code>&lt;ADDRESS&gt;</code> and <code>&lt;CODE&gt;</code>, but XML provides the flexibility to create custom tags.</p></p><p><p>Examples,</p></p><p><pre></p>&lt;owner studentid="2456"&gt;Jim Smith&lt;/owner&gt; owns a &lt;automobile model="OCC96"&gt;Cutlass Ciera&lt;/automobile&gt;.</pre></p><p><pre></p>&lt;my:conditional value="birds"&gt;</p>&lt;my:reference&gt;</p>&lt;my:author&gt;Joe Kluck&lt;/my:author&gt; in his article &lt;my:title type="article"&gt;Why Chicken have Wings&lt;/my:title&gt; &lt;my:bibliography&gt;(&lt;my:source&gt;&lt;my:periodical&gt;Poultry Monthly&lt;/my:periodical&gt; &lt;my:issue&gt;September 2001&lt;/my:issue&gt;&lt;/my:source&gt;, page &lt;my:page&gt;9&lt;/my:page&gt;)&lt;/my:bibliography&gt; dispels the usual stereotypes of flightless birds."</p>&lt;/my:reference&gt;</p>&lt;/my:conditional&gt;</pre></p><p><p>This kind of document must be well formed to allow processing by an XML parser but is usually not validated against a DTD or schema. For such a document, XHTML is a natural choice because it is well formed, has extensive formatting capability, and custom XML tags can be added without causing display problems in browsers. Note the namespace &quot;my&quot; was used to distinguish the custom XML tags from standard HTML tags.</p></p><p><h2>Tips for Designing an XML DTD or Schema</h2></p><p><p>XML transfers information between two parties, whether human or machine. Just as two people must know the same language, both parties must speak the same XML dialect. The dialect, defined in the DTD (data type definition) or schema, is the vocabulary and grammar used to describe the information being transferred.</p></p><p><p>The producer and the processor of XML information must share a common DTD or schema. Because the DTD or schema is vital to the success of XML, this article provides guidelines for designing a DTD or schema. Even if you are not designing a DTD or schema, it is worthwhile to understand the rationale behind their design, since it is the structure of XML data that gives it meaning. This structure changes a random sequence of unintelligible words to speech, that is, it transforms data to information.</p></p><p><p>When designing a DTD or schema for XML data, analyze the nature of the data and how it is created and processed. Consider how data is stored in a relational database, with a clearly defined structure of records, fields and tables.</p></p><p><p>Before you begin your design, decide whether to store data as the value of an attribute or as a text element (even if numeric) within tags. Generally, it is better to store data in elements, as this approach is more flexible when used with XSL. (XSL is a specification for transforming XML to HTML or some other XML structure.)</p></p><p><p>Be careful not to design solely from a developer's perspective. Consider who produces the XML data. If it is produced and processed programmatically, a developer-friendly perspective is appropriate. In fact, XML for B2B transactions should be designed from this perspective to generate fast, reliable and efficient transfer of information.� However, if a human will author or read the XML data, consider those needs when designing a DTD or schema.</p></p><p><h3>Elements and Attributes</h3></p><p><p>An attribute is the name-value pair that immediately follows a tag name. An element is a tag along with its attributes and all the text and elements that it encloses. Elements within another element are called child elements. Consider the following example.</p></p><pre>&lt;tag_name attr_name1="value1" attr_name2="value2"&gt;</p>��� &lt;child_tag attr_name3="value3" /&gt;</p>��� &lt;child_with_text&gt;This is some text&lt;/child_with_text&gt;</p>��� This text is part of the tag_name element</p>&lt;/tag_name&gt;</pre></p><p><p>As seen in this illustration, the tags are <code>tag_name</code>, <code>child_tag</code> and <code>child_with_text</code>. The attribute <code>attr_name1</code> has a value of "<code>value1</code>". The element, <code>tag_name</code>, consists of the following attributes and child elements:</p></p><p><p>Attributes: <code>attr_name1</code>, <code>attr_name2</code></p></p><p><p>Child Elements: <code>child_tag</code>, <code>child_with_text</code></p></p><p><p>Note that, in XML, every attribute value must be quoted with single (') or double quotes (&quot;). Also, every tag must have a closing tag or end with &quot;/&gt;&quot;.� Since the child_tag element has no child elements or text, the tag ends with &quot;/&gt;&quot; instead of a closing tag, for example, &quot;&lt;/child_tag&gt;&quot;.</p></p><p><p>Michael C. Daconta, in his article &quot;Are Elements and Attributes Interchangeable?&quot; (<cite>XML Journal</cite> volume 2 issue 7, page 42), presents eight practical rules for deciding whether to use elements or attributes. Some rules depend on whether the design is implemented in a DTD or schema. DTDs cannot enforce constraints between attributes and elements as extensively as schemas can. As a result, the decision to use an attribute may depend on whether a value is constrained.</p></p><p><h3>Elements vs. Attributes with Semi-Structured Documents</h3></p><p><p>When creating semi-structured data and content-oriented documents, place human-readable text in elements, not attributes. This is because attributes are part of the structure, not the content.� If you can separate structure from content, you can extract content without tags while retaining the human-readable information.</p></p><p><p>Text within an element should be considered &quot;viewable.&quot;� Attribute values, on the other hand, are either invisible or rendered in some other way by a graphical object. Use attribute values to modify or further identify specific elements.</p></p><p>Examples,</p></p><pre>&lt;prompt type="boolean"&gt;Do you want the information?</p>��� &lt;choice value="true"&gt;Yes, please send the information&lt;/choice&gt;</p>��� &lt;choice value="false"&gt;Don't send me the information&lt;/choice&gt;</p>&lt;/prompt&gt;</pre></p><pre>&lt;photo width="x" height="y" src="URL" alt="Text if photo not rendered or on mouse-over"&gt;</p>This is the caption for the photo.</p>&lt;/photo&gt;</pre></p><p><p>If you follow this rule, the value-of XSL tag or nodeValue property in the XML DOM (or text property in the Microsoft XML DOM) can easily recondition the content for publication on an unformatted device, as illustrated below.</p></p><p>This following XSL statement</p></p><p><code>&lt;xsl:value-of select="photo"/&gt;</code></p></p><p>produces the following text:</p></p><p><code>"This is the caption for the photo."</code></p></p><p><h3>Elements vs. Attributes with Database Oriented Data</h3></p><p>To contrast attributes with elements, here are two examples of student record data that are traditionally stored in a database. The first example primarily uses elements (element-centric) to store data values. The second example primarily uses attributes (attribute-centric).</p></p><p><h4>Element-centric</h4></p><pre>&lt;students&gt;</p>��� &lt;student id="2456"&gt;</p>������� &lt;name&gt;Jim Smith&lt;/name&gt;</p>������� &lt;grade&gt;10&lt;/grade&gt;</p>������� &lt;gpa&gt;3.5&lt;/gpa&gt;</p>��� &lt;/student&gt;</p>��� &lt;student id="2457"&gt;</p>������� &lt;name&gt;Mary Jones&lt;/name&gt;</p>������� &lt;grade&gt;12&lt;/grade&gt;</p>������� &lt;gpa&gt;3.4&lt;/gpa&gt;</p>��� &lt;/student&gt;</p>��� :</p>&lt;/students&gt;</pre></p><p><h4>Attribute-centric</h4></p><pre>&lt;students&gt;</p>��� &lt;student id="2456" name="Jim Smith" grade="10" gpa="3.5" /&gt;</p>��� &lt;student id="2457" name="Mary Jones" grade="12" gpa="3.4" /&gt;</p>��� :</p>&lt;/students&gt;</pre></p><p><p>With relational database data, the choice between attributes and elements does not appear all that important. Only unique keys, which establish a link between elements (such as student id), must be attributes to facilitate the linking of records (that is, other elements). With the attribute-centric approach, each element is a record, and each attribute is a field.</p></p><p><p>Although either approach works, it is generally recommended to use elements instead of attributes. For instance, to distinguish between first and last name, the element-centric approach can be changed to:</p></p><p><pre>&lt;name&gt;</p>��� &lt;first&gt;Jim&lt;/first&gt;</p>��� &lt;last&gt;Smith&lt;/last&gt;</p>&lt;/name&gt;</pre></p><p><p>The attribute-centric approach is less favorable because the attribute must be split into two attributes.</p></p><p><code>&lt;student ... firstname="Jim" lastname="Smith" .../&gt;</code></p></p><p>Only the element-centric approach is compatible with XSL.</p></p><p>Element-centric XSL transform:</p></p><p><code>&lt;xsl:value-of select="name"/&gt;</code></p></p><p>The transform above results in "Jim Smith" in both element-centric approaches, but the attribute-centric approach requires two different transforms.</p></p><p>Attribute-centric XSL transform for one attribute:</p></p><p><code>&lt;xsl:value-of select="@name"/&gt;</code></p></p><p>Attribute-centric XSL transform for two attributes:</p></p><p><code>&lt;xsl:value-of select="@firstname"/&gt; &lt;xsl:value-of select="@lastname"/&gt;</code></p></p><p><h3>Elements vs. Attributes with Object Oriented Data</h3></p><p><p>Besides relational database data, we should also consider object-oriented data, which describes a physical object, such as a car or a wooden barrel. Like the student record, the data is highly structured. Every part and subassembly relate to the others.</p></p><p><p>For object-oriented data, the relationship between parts and subassemblies is best described using the element approach. For example,</p></p><p><pre>&lt;automobile modelno="OCC96" class="midsize"&gt;</p>��� &lt;name&gt;Cutlass Ciera&lt;/name&gt;</p>��� &lt;engine size="3.0l"&gt;</p>������� &lt;cylinders count="4" /&gt;</p>��� &lt;/engine&gt;</p>��� &lt;wheels count="4" /&gt;</p>��� &lt;doors&gt;</p>������� &lt;door&gt;driver</p>����������� &lt;mirror /&gt;</p>����������� &lt;lock type="4 button combination" /&gt;</p>����������� &lt;window /&gt;</p>������� &lt;/door&gt;</p>������� &lt;door&gt;front passenger</p>����������� &lt;mirror&gt;OBJECTS IN MIRROR ARE CLOSER THAN THEY APPEAR&lt;/mirror&gt;</p>����������� &lt;lock type="key" /&gt;</p>����������� &lt;window /&gt;</p>������� &lt;door /&gt;</p>������� &lt;door&gt;left rear</p>����������� &lt;lock type="child safety" /&gt;</p>����������� &lt;window openable="no" /&gt;</p>������� &lt;/door&gt;</p>��� &lt;/doors&gt;</p>&lt;/automobile&gt;</pre></p><p><p>Example of an object-oriented approach for a 10 gallon wooden barrel:</p></p><pre>&lt;barrel capacity="10g" material="wood"&gt;</p>��� &lt;hoops width="2in" dia="2.5ft" material="iron" /&gt;</p>&lt;/barrel&gt;</pre></p><p><p>As you can see, both database-oriented and object-oriented data have little text. The data is highly structured and can be easily expressed in a tabular or hierarchical format. However, these highly structured examples would become semi-structured if the student record included teachers' comments or the automobile object included part descriptions and assembly instructions.</p></p><p><h2>Summary</h2></p><p><p>Widespread adoption of XML technology depends on DTD and schema designs that provide a structure convenient for humans. In other words, people will use XML only if it is easy and solves a problem.</p></p><p><p>XML may solve database problems by providing a common format to exchange data. But databases have been around for a long time, and most database problems have been solved. XML may improve B2B commercial transactions, although B2B is not new either--standards like EDI have been in use for some time. XML may also be beneficial for mathematical equations, CAD-CAM, UML (software design and modeling), and other graphically oriented content.</p></p><p><p>Managing semi-structured content for multiple audiences across multiple media (for example, the web, text-enabled handheld wireless devices, and print) is a new problem. Because of its unique design, XML is perfect for managing such content.</p></p><p><!--</p><p>Copyright �2002 Ektron, Inc. <a href="http://www.ektron.com">www.ektron.com</a> - Doug Domeny <a href="mailto:doug@ektron.com">doug@ektron.com</a> - January 10, 2002</p></p>-->