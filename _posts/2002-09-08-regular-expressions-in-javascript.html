---
layout: post
permalink: regexp_in_javascript
ratings: 11
avgrate: 4.5455
categories: [Code]
user: liorean
real_name: "David Andersson"
user_biog: "Liorean is a twenty one years old medical student and hobbyist web designer mostly working with JavaScript and CSS, DOM and the newest html standards available. His personal dwelling on the net can  be found at <a href=\"http://liorean.web-graphics.com/\" rel=\"nofollow\">liorean&#0064;web-graphics.com</a>."
user_since: 14 Jan 2002
avatar: 
article_count: 1
excerpt: "An explanation of concept and a reference to using regex in JavaScript, with some compatibility notes."
---
<h2>What is a regular expression?</h2></p><p><p>Regular expressions is a form of pattern matching that you can apply on textual content. Take for example the DOS wildcards <strong>?</strong> and <strong>*</strong> which you can use when you're searching for a file. That is a kind of very limited subset of RegExp. For instance, if you want to find all files beginning with <strong>&quot;fn&quot;</strong>, followed by 1 to 4 random characters, and ending with <strong>&quot;ht.txt&quot;</strong>, you can't do that with the usual DOS wildcards. RegExp, on the other hand, could handle that and much more complicated patterns.</p></p><p><p>Regular expressions are, in short, a way to effectively handle data, search and replace strings, and provide extended string handling. Often a regular expression can in itself provide string handling that other functionalities such as the built-in string methods and properties can only do if you use them in a complicated function or loop.</p></p><p><h2>RegExp Syntax</h2></p><p><p>There are two ways of defining regular expressions in JavaScript &#8212; one through an object constructor and one through a literal. The object can be changed at runtime, but the literal is compiled at load of the script, and provides better performance. The literal is the best to use with known regular expressions, while the constructor is better for dynamically constructed regular expressions such as those from user input. In almost all cases you can use either way to define a regular expression, and they will be handled in exactly the same way no matter how you declare them.</p></p><p><h3>Declaration</h3></p><p><p>Here are the ways to declare a regular expression in JavaScript. While other languages such as PHP or VBScript use other delimiters, in JavaScript you use forward slash (<code>/</code>) when you declare RegExp literals.</p></p><p><table border="1" cellspacing="0" cellpadding="0" class="data" width="100%"></p><thead></p><tr></p>  <th align="left">Syntax</th></p>  <th align="left">Example</th></p></tr></p></thead></p><tbody></p><tr></p>  <td colspan="2"><strong>RegExp Literal</strong></td></p></tr></p><tr></p>  <td valign="top" nowrap>/<strong>pattern</strong>/<strong>flags</strong>;</td></p>  <td valign="top">var re = <strong>/mac</strong>/<strong>i</strong>;</td></p></tr></p><tr></p>  <td colspan="2"><strong>RegExp Object Constructor</strong></td></p></tr></p><tr></p>  <td valign="top" nowrap>new RegExp(&quot;<strong>pattern</strong>&quot;,&quot;<strong>flags</strong>&quot;);</td></p>  <td valign="top">var re = new RegExp(window.prompt(&quot;Please input a regex.&quot;,&quot;<strong>yes yeah</strong>&quot;),&quot;<strong>g</strong>&quot;);</td></p></tr></p></tbody></p></table></p><p><h3>Flags</h3></p><p><p>There are three flags that you may use on a RegExp. The multiline flag has bad support in older browsers, but the other two are supported in pretty much every browser that can handle RegExp. These flags can be used in any order or combination, and are an integral part of the RegExp.</p></p><p><table border="1" cellspacing="0" cellpadding="0" class="data" width="100%"></p><thead></p><tr></p>  <th align="right">Flag</th></p>  <th align="left">Description</th></p></tr></p></thead></p><tbody></p><tr></p>  <td colspan="2"><strong>Global Search</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code>g</code></td></p>  <td>The global search flag makes the RegExp search for a pattern throughout the string, creating an array of all occurrences it can find matching the given pattern.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Ignore Case</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code>i</code></td></p>  <td>The ignore case flag makes a regular expression case insensitive. For international coders, note that this might not work on extended characters such as &aring;, &uuml;, &ntilde;, &aelig;.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Multiline Input</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code>m</code></td></p>  <td>This flag makes the beginning of input (<code>^</code>) and end of input (<code>$</code>) codes also catch beginning and end of line respectively.</td></p></tr></p></tbody></p></table></p><p><h3>Pattern</h3></p><p><p>The patterns used in RegExp can be very simple, or very complicated, depending on what you're trying to accomplish. To match a simple string like &quot;Hello World!&quot; is no harder then actually writing the string, but if you want to match an e-mail address or html tag, you might end up with a very complicated pattern that will use most of the syntax presented in the table below.</p></p><p><table border="1" cellspacing="0" cellpadding="0" class="data" width="100%"></p><thead></p><tr></p>  <th align="right">Pattern</th></p>  <th align="left">Description</th></p></tr></p></thead></p><tbody></p><tr></p>  <td colspan="2"><strong>Escaping</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code>\</code></td></p>  <td>Escapes special characters to literal and literal characters to special.<br><br></p>  E.g: <code>/\(s\)/</code> matches '(s)' while <code>/(\s)/</code> matches any whitespace and captures the match.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Quantifiers</strong></td></p></tr></p><tr></p>  <td align="right" valign="top">{<strong>n</strong>}, {<strong>n</strong>,},  {<strong>n</strong>,<strong>m</strong>}, *, +, ?</td></p>  <td>Quantifiers match the preceding subpattern a certain number of characters. The subpattern can be a single character, an escape sequence, a pattern enclosed by parentheses or a character set.<br><br></p>  {<strong>n</strong>} matches exactly <em>n</em> times.<br></p>  {<strong>n</strong>,} matches <em>n</em> or more times.<br></p>  {<strong>n</strong>,<strong>m</strong>} matches <em>n</em> to <em>m</em> times.<br></p>  <code>*</code> is short for <code>{0,}</code>. Matches zero or more times.<br></p>  <code>+</code> is short for <code>{1,}</code>. Matches one or more times.<br></p>  <code>?</code> is short for <code>{0,1}</code>. Matches zero or one time.<br><br></p>  E.g: <code>/o{1,3}/</code> matches 'oo' in &quot;tooth&quot; and 'o' in &quot;nose&quot;.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Pattern delimiters</strong></td></p></tr></p><tr></p>  <td align="right" valign="top">(<strong>pattern</strong>), (?:<strong>pattern</strong>)</td></p>  <td>Matches entire contained pattern.<br><br></p>  (<strong>pattern</strong>) captures match.<br></p>  (?:<strong>pattern</strong>) doesn't capture match<br><br></p>  E.g: <code>/(d).\1/</code> matches and captures 'dad' in &quot;abcdadef&quot; while <code>/(?:.d){2}/</code> matches but doesn't capture 'cdad'.<br><br></p>  <strong>Note:</strong> (?:<strong>pattern</strong>) is very badly supported in older browsers.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Lookaheads</strong></td></p></tr></p><tr></p>  <td align="right" valign="top">(?=<strong>pattern</strong>), (?!<strong>pattern</strong>)</td></p>  <td>A lookahead matches only if the preceeding subexpression is followed by the pattern, but the pattern is not part of the match. The subexpression is the part of the regular expression which will be matched.<br><br></p>  (?=<strong>pattern</strong>) matches only if there is a following <strong>pattern</strong> in input.<br></p>  (?!<strong>pattern</strong>) matches only if there is not a following <strong>pattern</strong> in input.<br><br></p>  E.g: <code>/Win(?=98)/</code> matches 'Win' only if 'Win' is followed by '98'.<br><br></p>  <strong>Note:</strong> Support for lookaheads is lacking in most but the newest browsers.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Alternation</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code> </code></td></p>  <td>Alternation matches content on either side of the alternation character.<br><br></p>  E.g: <code>/(a b)a/</code> matches 'aa' in &quot;dseaas&quot; and 'ba' in &quot;acbab&quot;.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Character sets</strong></td></p></tr></p><tr></p>  <td align="right" valign="top">[<strong>characters</strong>], [^<strong>characters</strong>]</td></p>  <td>Matches any of the contained characters. A range of characters may be defined by using a hyphen.<br><br></p>  [<strong>characters</strong>] matches any of the contained <em>characters</em>.<br></p>  [^<strong>characters</strong>] negates the character set and matches all but the contained <em>characters</em><br><br></p>  E.g: <code>/[abcd]/</code> matches any of the characters 'a', 'b', 'c', 'd' and may be abbreviated to <code>/[a-d]/</code>. Ranges must be in ascending order, otherwise they will throw an error. (E.g: <code>/[d-a]/</code> will throw an error.)<br></p>  <code>/[^0-9]/</code> matches all characters but digits.<br><br></p>  <strong>Note:</strong> Most special characters are automatically escaped to their literal meaning in character sets.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Special characters</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code>^</code>, <code>$</code>, <code>.</code>, <code>?</code> and all the highlighted characters above in the table.</td></p>  <td>Special characters mean characters that match something else than what they appear as.<br><br></p>  <code>^</code> matches beginning of input (or new line with <em>m</em> flag).<br></p>  <code>$</code> matches end of input (or end of line with <em>m</em> flag).<br></p>  <code>.</code> matches any character except a newline.<br><code>?</code> directly following a quantifier makes the quantifier non-greedy (makes it match minimum instead of maximum of the interval defined).<br><br></p>  E.g: <code>/(.)*?/</code> matches nothing or '' in all strings.<br><br></p>  <strong>Note:</strong> Non-greedy matches are not supported in older browsers such as Netscape Navigator 4 or Microsoft Internet Explorer 5.0.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Literal characters</strong></td></p></tr></p><tr></p>  <td align="right" valign="top">All characters except those with special meaning.</td></p>  <td>Mapped directly to the corresponding character.<br><br></p>  E.g: <code>/a/</code> matches 'a' in &quot;Any ancestor&quot;.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Backreferences</strong></td></p></tr></p><tr></p>  <td align="right" valign="top">\<strong>n</strong></td></p>  <td>Backreferences are references to the same thing as a previously captured match. <em>n</em> is a positive nonzero integer telling the browser which captured match to reference to.<br><br></p>  <code>/(\S)\1(\1)+/g</code> matches all occurrences of three equal non-whitespace characters following each other.<br></p>  /&lt;(\S+).*&gt;(.*)&lt;\/\1&gt;/ matches any tag.<br><br></p>  E.g: /&lt;(\S+).*&gt;(.*)&lt;\/\1&gt;/ matches '&lt;div id=&quot;me&quot;&gt;text&lt;/div&gt;' in &quot;text&lt;div id=\&quot;me\&quot;&gt;text&lt;/div&gt;text&quot;.</td></p></tr></p><tr></p>  <td colspan="2"><strong>Character Escapes</strong></td></p></tr></p><tr></p>  <td align="right" valign="top"><code>\f</code>, <code>\r</code>, <code></p></code>, <code>\t</code>, <code>\v</code>, <code>\0</code>, <code>[\b]</code>, <code>\s</code>, <code>\S</code>, <code>\w</code>, <code>\W</code>, <code>\d</code>, <code>\D</code>, <code>\b</code>, <code>\B</code>, \c<strong>X</strong>, \x<strong>hh</strong>, \u<strong>hhhh</strong></td></p>  <td><code>\f</code> matches form-feed.<br></p>  <code>\r</code> matches carrriage return.<br></p>  <code></p></code> matches linefeed.<br></p>  <code>\t</code> matches horizontal tab.<br></p>  <code>\v</code> matches vertical tab.<br></p>  <code>\0</code> matches NUL character.<br></p>  <code>[\b]</code> matches backspace.<br></p>  <code>\s</code> matches whitespace (short for <code>[\f</p>\r\t\v\u00A0\u2028\u2029]</code>).<br></p>  <code>\S</code> matches anything but a whitespace (short for <code>[^\f</p>\r\t\v\u00A0\u2028\u2029]</code>).<br></p>  <code>\w</code> matches any alphanumerical character (word characters) including underscore (short for <code>[a-zA-Z0-9_]</code>).<br></p>  <code>\W</code> matches any non-word characters (short for <code>[^a-zA-Z0-9_]</code>).<br></p>  <code>\d</code> matches any digit (short for <code>[0-9]</code>).<br></p>  <code>\D</code> matches any non-digit (short for <code>[^0-9]</code>).<br></p>  <code>\b</code> matches a word boundary (the position between a word and a space).<br></p>  <code>\B</code> matches a non-word boundary (short for <code>[^\b]</code>).<br></p>  \c<strong>X</strong> matches a control character. E.g: <code>\cm</code> matches control-M.<br></p>  \x<strong>hh</strong> matches the character with two characters of hexadecimal code <em>hh</em>.<br></p>  \u<strong>hhhh</strong> matches the Unicode character with four characters of hexadecimal code <em>hhhh</em>.</td></p></tr></p></tbody></p></table></p><p><h3>Usage</h3></p><p><p>Now, knowing how a RegExp is written is only half the game. To gain anything from them you have to know how to use them too. There are a number of ways to implement a RegExp, some through methods belonging to the String object, some through methods belonging to the RegExp object. Whether the regular expression is declared through an object constructor or a literal makes no difference as to the usage.</p></p><p><table border="1" cellspacing="0" cellpadding="0" class="data" width="100%"></p><thead></p><tr></p>  <th align="left">Description</th></p>  <th align="left">Example</th></p></tr></p></thead></p><tbody></p><tr></p>  <td colspan="2"><em>RegExp</em><strong>.exec(</strong><em>string</em><strong>)</strong></td></p></tr></p><tr></p>  <td valign="top">Applies the RegExp to the given string, and returns the match information.</td></p>  <td>var match = /s(amp)le/i.exec(&quot;Sample text&quot;)<br><br></p>  <code>match</code> then contains [&quot;Sample&quot;,&quot;amp&quot;]</td></p></tr></p><tr></p>  <td colspan="2"><em>RegExp</em><strong>.test(</strong><em>string</em><strong>)</strong></td></p></tr></p><tr></p>  <td valign="top">Tests if the given string matches the Regexp, and returns true if matching, false if not.</td></p>  <td>var match = /sample/.test(&quot;Sample text&quot;)<br><br></p>  <code>match</code> then contains <code>false</code></td></p></tr></p><tr></p>  <td colspan="2"><em>String</em><strong>.match(</strong><em>pattern</em><strong>)</strong></td></p></tr></p><tr></p>  <td valign="top">Matches given string with the RegExp. With <code>g</code> flag returns an array containing the matches, without <code>g</code> flag returns just the first match or if no match is found returns null.</td></p>  <td>var str = &quot;Watch out for the rock!&quot;.match(/r?or?/g)<br><br></p>  <code>str</code> then contains [&quot;o&quot;,&quot;or&quot;,&quot;ro&quot;]</td></p></tr></p><tr></p>  <td colspan="2"><em>String</em><strong>.search(</strong><em>pattern</em><strong>)</strong></td></p></tr></p><tr></p>  <td valign="top">Matches RegExp with string and returns the index of the beginning of the match if found, -1 if not.</td></p>  <td>var ndx = &quot;Watch out for the rock!&quot;.search(/for/)<br><br></p>  <code>ndx</code> then contains <code>10</code></td></p></tr></p><tr></p>  <td colspan="2"><em>String</em><strong>.replace(</strong><em>pattern</em><strong>,</strong><em>string</em><strong>)</strong></td></p></tr></p><tr></p>  <td valign="top">Replaces matches with the given string, and returns the edited string.</td></p>  <td>var str = &quot;Liorean said: My name is Liorean!&quot;.replace(/Liorean/g,'Big Fat Dork')<br><br></p>  <code>str</code> then contains &quot;Big Fat Dork said: My name is Big Fat Dork!&quot;</td></p></tr></p><tr></p>  <td colspan="2"><em>String</em><strong>.split(</strong><em>pattern</em><strong>)</strong></td></p></tr></p><tr></p>  <td valign="top">Cuts a string into an array, making cuts at matches.</td></p>  <td>var str = &quot;I am confused&quot;.split(/\s/g)<br><br></p>  <code>str</code> then contains [&quot;I&quot;,&quot;am&quot;,&quot;confused&quot;]</td></p></tr></p></tbody></p></table>