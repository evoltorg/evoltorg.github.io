---
layout: post
permalink: node/60122
ratings: 8
avgrate: 4.2500
category: Backend
user: madeonmoon
real_name: "James Shvarts"
user_since: 11 Apr 2003
avatar: ""
article_count: 1
excerpt: "Most of the web sites today have some sort of a registration module where a user is asked to choose a username/password combination.  You might wonder if the password you provide will be kept well-protected (read encrypted). In case you are the person designing such backend registration component, w"
---
<h2>Where has your password been?</h2></p><p><p></p>Most of the web sites today have some sort of a registration module where a user is asked to choose a username/password combination. This data gets stored in the database. You might wonder if the password you provide will be kept well-protected (read encrypted). In case you are the person designing such  backend registration component, why not give your users peace of mind by encrypting their passwords?</p></p></p><p><h2>One-way hash encryption</h2></p><p><p></p>This scenario is a perfect candidate for "one-way hash encryption" also known as a message digest, digital signature, one-way encryption, digital fingerprint, or cryptographic hash. It is referred to as "one-way" because although you can calculate a message digest, given some data, you can't figure out what data produced a given message digest. This is also a collision-free mechanism that guarantees that no two different values will produce the same digest. Another property of this digest is that it is a condensed representation of a message or a data file and as such it has a fixed length. </p></p></p><p><p></p>There are several message-digest algorithms used widely today.</p></p></p><p><p></p><table border="1"></p><tr></p><th></p>Algorithm</p></th></p><th></p> Strength</p></th></p></tr></p><tr></p><td></p>MD5</p></td></p><td></p>128 bit</p></td></p></tr></p><tr></p><td></p>SHA-1</p></td></p><td></p>160 bit</p></td></p></tr></p></table></p></p></p><p><p></p>SHA-1 (Secure Hash Algorithm 1) is slower than MD5, but the message digest is larger, which makes it more resistant to brute force attacks. Therefore, it is recommended that Secure Hash Algorithm is preferred to MD5 for all of your digest needs. Note, SHA-1 now has even higher strength brothers, SHA-256, SHA-384, and SHA-512 for 256, 384 and 512-bit digests respectively.</p></p></p><p><h2>Typical registration scenario</h2></p><p></p>Here is a typical flow of how our message digest algorithm can be used to provide one-way password hashing:</p></p></p><p></p>1) User registers with some site by submitting the following data:</p><p></p><table border="1"></p><tr></p><th></p>username</p></th></p><th></p>password</p></th></p></tr></p><tr></p><td>jsmith</p></td></p><td></p>mypass</p></td></p></tr></p></table></p></p></p><p><p></p>2) before storing the data, a one-way hash of the password is created: "mypass" is transformed into "5yfRRkrhJDbomacm2lsvEdg4GyY="</p></p></p><p></p>The data stored in the database ends up looking like this:</p></p></p><p><p></p><table border="1"></p><tr></p><th></p>username</p></th></p><th></p>password</p></th></p></tr></p><tr></p><td></p>jsmith</p></td></p><td></p>5yfRRkrhJDbomacm2lsvEdg4GyY=</p></td></p></tr></p></table></p></p></p><p><p></p>3) When jsmith comes back to this site later and decides to login using his credentials (jsmith/mypass), the password hash is created in memory (session) and is compared to the one stored in the database. Both values are equal to "5yfRRkrhJDbomacm2lsvEdg4GyY=" since the same password value "mypass" was used both times when submitting his credentials. Therefore, his login will be successful.</p></p></p><p><p></p>Note, any other plaintext password value will produce a different sequence of characters. Even using a similar password value ("mypast") with only one-letter difference, results in an entirely different hash: "hXdvNSKB5Ifd6fauhUAQZ4jA7o8="</p></p></p><p><p></p><table border="1"></p><tr></p><th></p>plaintext password</p></th></p><th></p>encrypted password</p></th></p></tr></p><tr></p><td></p>mypass</p></td></p><td></p>5yfRRkrhJDbomacm2lsvEdg4GyY=</p></td></p></tr></p><tr></p><td></p>mypast</p></td></p><td></p>hXdvNSKB5Ifd6fauhUAQZ4jA7o8=</p></td></p></tr></p></table></p></p></p><p><p></p>As mentioned above, given that strong encryption algorithm such as SHA is used, it is impossible to reverse-engineer the encrypted value from "5yfRRkrhJDbomacm2lsvEdg4GyY=" to "mypass". Therefore, even if a malicious hacker gets a hold of your password digest, he/she won't be able determine what your password is.</p></p></p><p><h2>Java code that implements one-way hash algorithm</h2></p><p><p></p>Let's assume that you are writing a web application to be run in a servlet container. Your registration servlet might have the following portion (for clarity, I ommitted input validation steps and assume that a password value was passed in within the password form input field):</p></p></p><p><pre></p>[...]</p>public void doPost(HttpServletRequest request, HttpServletResponse response)</p>{</p>  User user = new org.myorg.registration.User();</p>  user.setPassword(org.myorg.services.PasswordService.getInstance().encrypt(request.getParameter("password"));</p>[...]</p></pre></p><p><p></p>Here is the definition of my PasswordService class that does the job of generating a one-way hash value:</p></p></p><p><pre></p>package org.myorg.services;</p>import java.io.UnsupportedEncodingException;</p>import java.security.MessageDigest;</p>import java.security.NoSuchAlgorithmException;</p>import org.myorg.SystemUnavailableException;</p>import sun.misc.BASE64Encoder;</p>import sun.misc.CharacterEncoder;</p><p>public final class PasswordService</p>{</p>  private static PasswordService instance;</p><p>  private PasswordService()</p>  {</p>  }</p><p>  public synchronized String encrypt(String plaintext) throws SystemUnavailableException</p>  {</p>    MessageDigest md = null;</p>    try</p>    {</p>      md = MessageDigest.getInstance("SHA"); //step 2</p>    }</p>    catch(NoSuchAlgorithmException e)</p>    {</p>      throw new SystemUnavailableException(e.getMessage());</p>    }</p>    try</p>    {</p>      md.update(plaintext.getBytes("UTF-8")); //step 3</p>    }</p>    catch(UnsupportedEncodingException e)</p>    {</p>      throw new SystemUnavailableException(e.getMessage());</p>    }</p><p>    byte raw[] = md.digest(); //step 4</p>    String hash = (new BASE64Encoder()).encode(raw); //step 5</p>    return hash; //step 6</p>  }</p>  </p>  public static synchronized PasswordService getInstance() //step 1</p>  {</p>    if(instance == null)</p>    {</p>       instance = new PasswordService(); </p>    } </p>    return instance;</p>  }</p>}</p></pre></p><p><p></p>The method of interest here is encrypt(). I chose to make this class a singleton in order to ensure that there is only one instance of it at any given time to avoid concurrency issues and conflicts between generated hash values. For an explanation of this design pattern, try a google search for "java singleton pattern".</p></p></p><p><p></p>Let's step through the code above to see what's going on:</p></p></p><p></p><b>step 1</b>: The registration servlet will interface with our PasswordService class using this static getInstance() method. Whenever it is invoked, a check will be made to see if an instance of this service class already exists. If so, it will be returned back to the caller (registration servlet). Otherwise, a new instance will be created.</p></p></p><p><p></p><b>step 2</b>: We are asking Java security API to obtain an instance of a message digest object using the algorithm supplied (in this case, SHA-1 message digest algorithm will be used. Both SHA and SHA-1 refer to the same thing, a revised SHA algorithm). Sun JDK includes JCA (Java Cryptography Architecture) which includes support for SHA algorithm. If your environment does not support SHA, NoSuchAlgorithmException will be thrown. </p></p></p><p><p></p><b>step 3</b>: Feed the data:<br></p>a) convert the plaintext password (eg, "jsmith") into a byte-representation using UTF-8 encoding format.<br></p>b) apply this array to the message digest object created earlier. This array will be used as a source for the message digest object to operate on.</p></p></p><p><p></p><b>step 3</b>: Do the transformation: generate an array of bytes that represent the digested (encrypted) password value.</p></p></p><p><p></p><b>step 4</b>: Create a String representation of the byte array representing the digested password value. This is needed to be able to store the password in the database. At this point, the hash value of the plaintext "jsmith" is "5yfRRkrhJDbomacm2lsvEdg4GyY=".</p></p></p><p><p></p><b>step 5</b>: Return the String representation of the newly generated hash back to our registration servlet so that it can be stored in the database. The user.getPassword() method now returns "5yfRRkrhJDbomacm2lsvEdg4GyY="</p></p></p><p><p></p>That's all. Your database password data is now encrypted and if an intruder gets a hold of it, he/she won't have much use of it. Note, you have to consider how you will handle "forgot password" functionality in this case as you now cannot simply send a password to the user's email address. (Well, you should not be doing things like that anyway) . Sounds to me like a perfect topic for my next article.</p></p>