---
layout: post
permalink: node/33907
ratings: 5
avgrate: 3.6000
user: DevilM
real_name: "Matt Liotta"
user_since: 11 Mar 2002
avatar: "/images/pictures/picture-22348.jpg"
article_count: 6
excerpt: "One of the most requested extensions to ColdFusion is the ability to do image </p>manipulation. Whether the request is as simple as just getting the rendered </p>height and width of an image or as complex as creating a thumbnail in a different </p>format, the Java Advanced Imaging API (JAI) may well"
---
<p>One of the most requested extensions to ColdFusion is the ability to do image </p>manipulation. Whether the request is as simple as just getting the rendered </p>height and width of an image or as complex as creating a thumbnail in a different </p>format, the Java Advanced Imaging API (JAI) may well hold the answer. In this </p>article I will explain how to make use of JAI from CFMX to do the following </p>four operations, thumbnail generation, format conversion, cropping, and border </p>creation. Additionally, I will show how to obtain image properties such as </p>the height and width of the rendered image.</p></p><p><p>Before getting started using JAI, it is worth learning a little bit about </p>JAI. JAI is a set of interfaces that provide image manipulation for Java. </p>JAI is an optional package that does not ship with Java 1.3. Since JAI is </p>just a set of interfaces, an implementation of those interfaces is also required </p>in order to make use of it. Sun provides a free implementation of the JAI </p>interfaces along with the <a href="http://java.sun.com/products/java-media/jai/" target="_blank">JAI package that you can download here</a>. </p>Sun does implement all of the interfaces, but may not provide all the functionality </p>you are looking for. For example, the Sun interface can read BMP, JPG, GIF, </p>TIF, and PNG image formats, while it can write DMP, JPG, TIF, PNG. If you </p>need the ability to write GIF files than you will have to find another implementation </p>(PNG is the generally accepted substitute for GIF).</p></p><p><p>To easily make use of JAI I am going to create a Java class that accesses the JAI APIs and then a CFC that wraps my Java class. The first step is to create a shell class with the correct imports. I am also going to declare some private variables Iï¿½ll make use of later in the methods. The shell class is as follows.</p></p><p><pre></p>import java.io.*;</p>import java.util.*;</p>import java.awt.image.renderable.*;</p>import javax.media.jai.*;</p>import com.sun.media.jai.codec.*;</p><p>public class ImageUtils</p>{</p>	private RenderedOp image = null;</p>	private RenderedOp result = null;</p>	private int height = 0;</p>	private int width = 0;</p>}</p></pre></p><p><p>After creating the shell class I am ready for my first method. Since all my image manipulation methods will depend on having an image loaded into memory, I will create a load method. Below is my method for loading the image into memory.</p></p><p><pre></p>public void load(String file) throws IOException</p>{</p>  FileSeekableStream fss = new FileSeekableStream(file);</p>  image = JAI.create(&quot;stream&quot;, fss);</p>  height = image.getHeight();</p>  width = image.getWidth();</p>}</p></pre></p><p><p>As you can see my method take a single parameter indicating the file it should </p>load into memory. This parameter needs to be the complete path to the file. </p>First, I create a new <code>FileSeekableStream</code> instance </p>using the passed in path as a parameter. I then need to create an image stream. </p>For convenience I will be using the provided static JAI factory. The static </p><code>JAI.create</code> method&#8217;s first parameter is the type </p>of object I want to create, while all the other parameters depend on what </p>object I want to create. In this case I want to create a stream, so I pass </p>it the <code>FileSeekableStream</code> instance I just created. </p>The <code>JAI.create method</code> returns a <code>RenderedOp</code> </p>object. Now that I have my image in memory I am going to go ahead and get </p>its height and width using the respective <code>getHeight()</code> and <code>getWidth()</code> methods of RenderedOp.</p></p><p><p>No matter what type of image manipulation I want to do, I will always need </p>to write to disk the resulting image. In order to write an image to disk I </p>will need to know what type of encoding to use as well as the name of the </p>file to create. Below is the method I created for writing an image to disk.</p></p><p><pre></p>public void writeResult(String file, String type) throws IOException</p>{</p>  FileOutputStream os = new FileOutputStream(file);</p>  JAI.create(&quot;encode&quot;, result, os, type, null);</p>}</p></pre></p><p><p>With only two lines of code, the <code>writeResult</code> method </p>is quite simple. Using the static <code>JAI.create</code> method </p>I encode my image by passing it a <code>RenderedOp</code> (the </p>image), the <code>FileOutputStream</code> I just created, and </p>the type of encoding to use. It then calls the encode method on my behalf, </p>which write the image to disk in the appropriate format. Almost all of the </p>popular image encodings are support except for GIF. Check the JAI documentation </p>for a list of what encodings are supported. For the most part PNG is an acceptable </p>substitute for GIF.</p></p><p><p>Now that I have finished my <code>writeResult</code> method </p>I have actually gotten image format conversion for free. This is because I </p>can load an image in any acceptable format and then write it as any of the </p>supported encodings. For example, I could load a BMP image and then write </p>it as a JPG thus converting the image from a bitmap to a jpeg.</p></p><p><p>From here I can create new methods for each additional type of image manipulation </p>operation I want to support. As stated earlier, I also want to be able to </p>generate thumbnails, crop images, and create borders. When creating thumbnails </p>it is often easy to distort the image by not scaling each dimension according </p>the image&#8217;s aspect ratio. For my thumbnail method I am going to accept a single </p>number that represents what the longest edge of the resulting image should </p>be. I will then scale the image according to its aspect ratio to the desired </p>edge length. The following code is my thumbnail method.</p></p><p><pre></p>public void thumbnail(float edgeLength)</p>{</p>  boolean tall = (height &gt; width);</p>  float modifier = edgeLength / (float) (tall ? height : width);</p>  ParameterBlock params = new ParameterBlock();</p>  params.addSource(image);</p>  params.add(modifier);//x scale factor</p>  params.add(modifier);//y scale factor</p>  params.add(0.0F);//x translate</p>  params.add(0.0F);//y translate</p>  params.add(new InterpolationNearest());//interpolation method</p>  result = JAI.create(&quot;scale&quot;, params);</p>}</p></pre></p><p><p>My first step is to determine if the image is tall or wide. I do this simply </p>by seeing if the height is greater than the width. From there I create a modifier </p>value based on the desired edge length divided by the longest edge. Now that </p>I have my modifier value, I need to create a <code>ParameterBlock</code> to pass to the scale method. My first parameter </p>is the image source. From there I add parameters for the x and y scale factor. </p>Notice how I use the same x and y scale factor. This keeps the image from </p>being distorted. The rest of the parameters aren&#8217;t so important for generating </p>thumbnails and are more useful for scaling operations. If you are interested </p>in different types of scaling operations the JAI documentation will describe </p>how these additional parameters can be useful for you. After creating the </p><code>ParameterBlock</code> I pass it to the static <code>JAI.create</code> method, which calls scale and returns my result.</p></p><p>For image cropping I decided to have my method crop the same amount for both </p>the height and width of the image. Thus, my method only takes a single parameter, </p>how much edge to crop. The code for the method is below.</p></p><p><pre></p>public void crop(float edge)</p>{</p>  ParameterBlock params = new ParameterBlock();</p>  params.addSource(image);</p>  params.add(edge);//x origin</p>  params.add(edge);//y origin</p>  params.add((float) width - edge);//width</p>  params.add((float) height - edge);//height</p>  result = JAI.create(&quot;crop&quot;, params);</p>}</p></pre></p><p><p>Again, I need to create a <code>ParameterBlock</code>. My first </p>parameter is the image source. From there I need to add the x and y origins. </p>The origin is where the cropping should start. Next, I add the width and height </p>of crop. I determine the width and height by subtracting the origin from its </p>respective edge. Since I am cropping the same amount for both the height and </p>the width, I use the same value for x and y and thus for subtracting from </p>the width and height. Finally, I pass the <code>ParameterBlock</code> </p>to the static <code>JAI.create</code> method, which calls crop </p>and returns my result.</p></p><p><p>Much like the crop method, I decide to have my border method use the same </p>size border for each side of the image. Besides the width of the border, my </p>method will also allow a color for the border to be specified. Thus, my method </p>takes two parameters; the code is as follows.</p></p><p><pre></p>public void border(int edge, double edgeColor)</p>{</p>  ParameterBlock params = new ParameterBlock();</p>  params.addSource(image);</p>  params.add(edge);//left pad</p>  params.add(edge);//right pad</p>  params.add(edge);//top pad</p>  params.add(edge);//bottom pad</p>  double fill[] = {edgeColor};</p>  params.add(new BorderExtenderConstant(fill));//type</p>  params.add(edgeColor);//fill color</p>  result = JAI.create(&quot;border&quot;, params);</p>}</p></pre></p><p><p>Again, I create a <code>ParameterBlock</code> and set the image </p>source. From there I add a parameter for each side&#8217;s border width. Since I </p>am using the same border width for all sides, this value is the same. Next </p>I need to add the border color, which is done with two parameters, a <code>BorderExtenderConstant</code> </p>and the color. There are more options for border file than using a single </p>constant color, but that is out of the scope of this article. Again, the JAI </p>documentation will provide the details of what additional border operations </p>are possible and how to make use of them. Having created my <code>ParameterBlock</code>, </p>I pass it to the static <code>JAI.create</code> method, which </p>calls border and returns my result.</p></p><p><p>With my Java class complete I can compile it. Make sure you include the JAI </p>jars in your <code>CLASSPATH</code> before attempting to compile it. Once my Java class </p>is compiled I simply place in ColdFusion&#8217;s <code>CLASSPATH</code>, </p>so that I can make use of it from my CFC.</p></p><p><p>To get started on my CFC, I am going to declare three variables in my component </p>body, iu, loaded, and result. </p>The code for the three declarations is below.</p></p><p><pre></p>&lt;cfobject type=&quot;java&quot; name=&quot;iu&quot; class=&quot;ImageUtils&quot; action=&quot;create&quot;&gt;</p>&lt;cfset loaded = false&gt;</p>&lt;cfset result = false&gt;</p></pre></p><p><p>As you can see, I named my Java class <code>&#8220;ImageUtils&#8221;</code> </p>and I am using the <code>&lt;cfobject&gt;</code> tag to create </p>an instance of it. Since all of my CFC&#8217;s methods will be making use of the </p>ImageUtils class I created the instance in my component body </p>instead of in an individual method. My two other variables, loaded and result, </p>are simply booleans representing the state of my </p>CFC.</p></p><p><p>Since all my CFC does is wrap my Java class, all the methods are very straight </p>forward. Each one is included below and briefly explained.</p></p><p><pre></p>&lt;cffunction name=&quot;load&quot; access=&quot;public&quot;&gt;</p>  &lt;cfargument name=&quot;filename&quot; type=&quot;string&quot; required=&quot;true&quot;&gt;</p>  &lt;cfscript&gt;</p>    iu.load(arguments.filename);</p>    loaded = true;</p>  &lt;/cfscript&gt;</p>&lt;/cffunction&gt;</p></pre></p><p><p>The above load method simple passes the file to load directly to <code>ImageUtils</code> </p>and then sets the boolean loaded to true indicating </p>that an image has been loaded.</p></p><p><pre></p>&lt;cffunction name=&quot;writeResult&quot; access=&quot;public&quot;&gt;</p>  &lt;cfargument name=&quot;filename&quot; type=&quot;string&quot; required=&quot;true&quot;&gt;</p>  &lt;cfargument name=&quot;type&quot; type=&quot;string&quot; required=&quot;true&quot;&gt;</p>  &lt;cfif result&gt;</p>    &lt;cfscript&gt;</p>      if(result)</p>        iu.writeResult(arguments.filename, arguments.type);</p>    &lt;/cfscript&gt;</p>  &lt;/cfif&gt;</p>&lt;/cffunction&gt;</p></pre></p><p><p>The above <code>writeResult</code> method checks to see if a </p>result has been created before calling the <code>ImageUtils writeResult</code> method.</p></p><p><pre></p>&lt;cffunction name=&quot;thumbnail&quot; access=&quot;public&quot;&gt;</p>  &lt;cfargument name=&quot;edgeLength&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;</p>  &lt;cfif loaded&gt;</p>    &lt;cfscript&gt;</p>      iu.thumbnail(arguments.edgeLength);</p>      result = true;</p>    &lt;/cfscript&gt;</p>  &lt;/cfif&gt;</p>&lt;/cffunction&gt;</p></pre></p><p><p>The above thumbnail method checks to see if an image has been loaded. Then </p>it calls the <code>ImageUtils</code> thumbnail method and sets </p>the boolean result to true </p>indicating that a result has been created.</p></p><p><pre></p>&lt;cffunction name=&quot;crop&quot; access=&quot;public&quot;&gt;</p>  &lt;cfargument name=&quot;edge&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;</p>  &lt;cfif loaded&gt;</p>    &lt;cfscript&gt;</p>      iu.crop(arguments.edge);</p>      result = true;</p>    &lt;/cfscript&gt;</p>  &lt;/cfif&gt;</p>&lt;/cffunction&gt;</p></pre></p><p><p>Just like the thumbnail method, the above crop method checks to see if an </p>image has been loaded. Then it calls the <code>ImageUtils</code> </p>crop method and sets the boolean </p>result to true indicating that a result has been created.</p></p><p><pre></p>&lt;cffunction name=&quot;border&quot; access=&quot;public&quot;&gt;</p>  &lt;cfargument name=&quot;edge&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;</p>  &lt;cfargument name=&quot;edgeColor&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;</p>  &lt;cfif loaded&gt;</p>    &lt;cfscript&gt;</p>      iu.border(arguments.edgeLength, arguments.edgeColor);</p>      result = true;</p>    &lt;/cfscript&gt;</p>  &lt;/cfif&gt;</p>&lt;/cffunction&gt;</p></pre></p><p><p>Finally, the above border method checks to see if an image has been loaded. </p>Then it calls the <code>ImageUtils</code> border method and sets </p>the boolean result to true </p>indicating that a result has been created.</p></p><p><p>After creating my Java class and associated wrapper CFC, I am now able to </p>perform image manipulation from ColdFusion with ease. Further, both the Java </p>class and the CFC are easily extendible to support additional operations that </p>are implemented with JAI. While creating a wrapper CFC may seem like additional </p>work for nothing, further additions to the Java class could prove challenging </p>for ColdFusion to make use of. Since Java is a typed language and ColdFusion </p>is typeless, it is often useful to have a wrapper </p>class that can act as an adapter.</p>