---
layout: post
permalink: Session_Hijacking_Cold_Fusion_Dynamic_Proxies
---
<p>\nYet <em>another</em> reason to hate AOL&reg;\n</p>\n<p>\nSession hijacking, grabbing somebody else's URL and stealing their session, is one of the biggest security concerns around for anyone developing user-centric applications.  Developers generally use client-side cookies to combat this problem.  A lot of people hate cookies and may even have them disabled.  Question, can session hacking protection be implemented without cookies?\n</p>\n<p>\nThe answer is "mostly".\n</p>\n<p>\n<em>NOTE:</em> The author (me) uses Cold Fusion, so the examples will be in CF.\n</p>\n<p>\nIf all you care about is the <a href="/Session_Hijacking_Cold_Fusion_Dynamic_Proxies#technique">technique, click here</a>.  If all you care about is <a href="/Session_Hijacking_Cold_Fusion_Dynamic_Proxies#CFcode">code, click here</a>.\n</p>\n<p>\n<h2>Background Check</h2>\n</p>\n<p>\n<h3>Why are Cookies Used?</h3>\n</p>\n<p>\nCookies offer a way to check the identity of the user by means of storing the CFID and CFTOKEN in client side cookies and using that information to uniquely identify the user.  The cookies are only issued at login and therefore this technique is generally sound.  One would actually have to copy the cookies off another's machine to steal their identity.\n</p>\n<p>\n<h3>If Not Cookies, Then What?</h3>\n</p>\n<p>\nIf you don't want to use cookies you must find some other means of identifying the user.  Normally, that means passing the <code>CFID</code> and <code>CFTOKEN</code> around in the URL.  It is possible, therefore to copy somebody's URL into your own browser and steal their identity.  Though session variables do time out after prolonged periods of inactivity (as designated by the server), there is a window of time where a hijacking could happen.\n</p>\n<p>\nMost developers use one of two different approaches:\n<ol>\n<li>Check the <code>HTTP_REFERER</code> variable for each page request and drop the session if the variable is empty.</li>\n<li>Store the IP address of the machine actually performing the login and destroy the session if a page request occurs to the same session, but from a different IP address.</li>\n</ol>\n</p>\n<p>\n<b>1</b> does not work because IE does not always return a referrer.  For example, when it opens a popup window under certain (?) conditions it may not return the referrer to the server.  ALSO, <code>HTTP_REFERER</code> is a browser variable and could be hacked by anyone so inclined, AND, browsers such as Opera &amp iCap, etc actually give the user the ability to turn off the reporting of the <code>HTTP_REFERER</code>.  FINALLY, in some versions of Netscape, the sub-frames of a <code>FRAMESET</code> do not get issued the <code>HTTP_REFERER</code> when they are requested (Oh yeah, I don't like Netscape&reg; either).\n</p>\n<p>\n<b>2</b> does not work for dynamic proxies.  AOL, for example, routes its users through proxies, and the particular proxy used from page request to page request might be different.  Since a proxy reports its own IP address to the server, you cannot use this method without excluding AOL users from using your site. Maybe it's time to come up with another method.\n</p>\n<p>\n<code>&lt;GRIPE&gt</code>\n<blockquote>If only the US Government hadn't pressured Intel to remove the serial numbers from CPU's...</blockquote>\n<code>&lt;/GRIPE&gt</code>\n</p>\n<p>\n<h3>So Those Two Don't Work Too Well, Now What?</h3>\n</p>\n<p>\nSo the answer is use cookies, use lots of them...\n</p>\n<p>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...on every image in fact! (jk)\n</p>\n<p>\nWell, to be honest, we'll have to use some sort of cookie to regrab some of the AOL and dynamic proxy users.  But, we can do some twiddling to make those particular users the only users that are mandated the user of cookies.  Everybody else can turn off their cookies and not have to worry about session hijacking.  So, it's not a total solution, but a start.\n</p>\n<p>\n<a name="technique"></a><h2>Start the Good Stuff</h2>\n</p>\n<p>\nFor this technique to work with Cold Fusion you must have session management turned on, a la:\n</p>\n<p>\n<pre>\n&lt;cfapplication name=&quot;whatever&quot;\n     clientmanagement=&quot;No&quot;\n     sessionmanagement=&quot;Yes&quot;\n     setclientcookies=&quot;No&quot;\n     sessiontimeout=&quot;#CreateTimeSpan(0,2,0,0)#&quot;&gt;\n</pre>\n</p>\n<p>\nAnd, it would be a good idea to have session timeout turned on, like it is set for 2 hours in the example above.\n</p>\n<p>\n<b>The overall idea</b> is that you want to set a cookie that contains their IP address and set a session variable that contains the same IP address.  We are able to inspect the IP address of the request VIA the <code>cgi.remote_addr</code> variable.  In some instances, this variable contains the actual IP of the source machine.  In others, if a proxy is used, for example, this variable will contain the last most proxy used before the request hit the Internet.\n</p>\n<p>\nAt the time of setting, all three variables&#151;the cookie, the session variable, and their actual IP address&#151;should match.  So, in the future so long as their session variable IP address and the cookie IP address match, keeping in mind that we'll <em>never</em> send a cookie that contains anything other than their <code>cgi.remote_addr</code>, you'll never have to worry that the session is being hijacked.\n</p>\n<p>\nSince all three match at the beginning of the process, if the situation arises where the cookie does exist and does not match the session variable IP, then you know for certain the session is being hijacked.\n</p>\n<p>\nIf the cookie is not set, there is <b>no chance</b> that the session is being hijacked if the actual IP address matches the session variable IP.  Okay okay, I concede that your friend in the next cube over to whom that you just IM'd the URL could hijack your session since your both behind the same proxy, but there is no way around that using the IP address as the differentiator as we are in this implementation.\n</p>\n<p>\nHowever, if there is no cookie set and the actual and session IP's do not match, the equation becomes a bit tougher. The user could be a hijacker, or the user could be behind a dynamic proxy, such as the situation with AOL where the proxy can change at any time, thus making it appear as if the originating machine has changed IP's.  In this case, we have to mandate the use of cookies.  There is really no other known way around the issue as of the publication date of this article.\n</p>\n<p>\nThe benefit gained using the code presented here is that we have eliminated the need to use cookies to avoid session hijacking <em>except</em> for users behind dynamic proxies, such as AOL.  Though all users entering the session-enabled state are presented cookies, only those AOL are going to have difficulty using the site if they decline the cookie.\n</p>\n<p>\n<a name="CFcode"></a><h2>Here's Some Code</h2>\n</p>\n<p>\nIt is self contained and does not rely on any session variables to be created before this appears.  A likely spot for this code is in APPLICATION.CFM  Note that it does try to set the cookie exactly once.  This single try to set a cookie fires the first time the session tokens are passed through the URL.  All subsequent attempts will be filtered on the <code>session.cookieset</code> variable.\n</p>\n<p>\n<pre>&lt;!--- Session Hijacking Defense ---&gt;</p><p>&lt;cfparam name=&quot;session.cookieset&quot; default=&quot;0&quot;&gt;\n&lt;cfparam name=&quot;url.cftoken&quot; default=&quot;0&quot;&gt;\n&lt;cfparam name=&quot;session.ipaddr&quot; default=&quot;&quot;&gt;</p><p>&lt;!--- We assume cfid and cftoken at at the end of\n      the query string and make a query string\n      w/o them ---&gt;\n&lt;cfset new_query = cgi.script_name\n                 &amp; IIF(Len(cgi.query_string),\n                    DE(&quot;?#cgi.query_string#&quot;),\n                    DE(&quot;&quot;))&gt;\n&lt;cfif FindNoCase(&quot;cfid=&quot;, new_query)&gt;\n  &lt;cfset new_query = Left(new_query,\n                     FindNoCase(&quot;cfid=&quot;,\n                                new_query) - 2)&gt;\n&lt;/cfif&gt;</p><p>&lt;cfif Val(url.cftoken)&gt;\n  &lt;cfif IsDefined(&quot;cookie.ipaddr&quot;)\n        AND LEN(session.ipaddr)&gt;\n    &lt;cfif cookie.ipaddr NEQ session.ipaddr&gt;\n      &lt;!--- session is being hijacked ---&gt;\n      &lt;cflocation url=&quot;#new_query#&quot; addtoken=&quot;No&quot;&gt;\n    &lt;/cfif&gt;\n  &lt;cfelse&gt;\n    &lt;cfif session.cookieset&gt;\n      &lt;!--- This is not the first time the tokens\n            have appeared in the URL ---&gt;\n      &lt;cfif session.ipaddr NEQ cgi.remote_addr&gt;\n        &lt;!--- either hijacking or did not accept\n              cookie. We need cookies in this case, so\n              send to a page saying as such ---&gt;\n        &lt;cflocation url=&quot;#new_query#&quot; addtoken=&quot;No&quot;&gt;\n      &lt;/cfif&gt;\n	  &lt;cfelse&gt;\n      &lt;!--- This is the first time the tokens have\n            appeared in the URL ---&gt;\n      &lt;cfcookie name=&quot;ipaddr&quot; value=&quot;#session.ipaddr#&quot;&gt;\n      &lt;cfset session.cookieset = 1&gt;</p><p>      &lt;cfset session.ipaddr = cgi.remote_addr&gt;\n      &lt;html&gt;\n        &lt;head&gt;\n          &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;0&quot;&gt;\n        &lt;/head&gt;\n        &lt;body bgcolor=&quot;#dddddd&quot;&gt;&nbsp;&lt;/body&gt;\n      &lt;/html&gt;\n      &lt;cfabort&gt;\n	  &lt;/cfif&gt;\n  &lt;/cfif&gt;\n&lt;/cfif&gt;</p><p>&lt;!--- /Session Hijacking Defense ---&gt;</pre>\n</p>\n<p>\nFeedback is encouraged and welcomed for this article.  Session hijacking is a long-standing problem and very few implementations of a hijacking defense system are bulletproof.  If we put everybody's head together on this, we may find a solution yet.\n</p>\n<p>\nI would like to thank <a href="http://www.evolt.org/user/jeff/15/index.html">.jeff</a> again for his help in creating this document.\n</p>