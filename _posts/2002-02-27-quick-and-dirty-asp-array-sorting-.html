---
layout: post
permalink: node/21724
ratings: 6
avgrate: 4.3333
rating: 4.13
categories: [Code]
user: AnthonyB
real_name: "Anthony Baratta"
user_biog: "Mutated into a life-size Dilbert doll, Anthony spends the days wedged into his replica of Cardinal Fang's Comfy Chair coding solutions to the most thorny of internet software problems."
user_since: 10 Jul 1999
avatar: /images/pictures/picture-140.jpg
article_count: 12
excerpt: "One of the most frustrating non-options with VB Scripting is the inability to sort arrays. If you've rolled your own, most people opt for the bubble sort method. This works great until you have a medium to large array. Then it becomes horribly inefficient."
---
<h2>or How I stopped worrying and hacked someone else's code.</h2></p><p><p>One of the most frustrating non-options with VB Scripting is the inability to sort arrays. If you've rolled your own, most people opt for the <a href="http://www.4guysfromrolla.com/webtech/011601-1.shtml" title="Sorting a Two-Dimensional Array using a Bubble Sort - Opens new window" target="_blank">bubble sort</a> method. This works great until you have a medium to large array. Then it becomes horribly inefficient.</p></p><p><p>On the <a href="http://www.4guysfromrolla.com" title="4 Guys from Rolla Web Site - Opens new window" target="_blank">4 Guys From Rolla</a> web site, they have a nifty ASP function published called <a href="http://www.4guysfromrolla.com/webtech/012799-3.shtml" title="Sorting Two Dimensional Arrays: VBScript Implementation - Opens new window" target="_blank">Quick Sort</a> that can handle multi-dimensional sorting. It's based on the algorithm given in Data Abstractions & Structures using C++ by Mark Headington and David Riley, (pg. 586).</p></p><p><p>The 4 Guys From Rolla QuickSort is very nice, but has a few short comings. One: It does not offer an option for Ascending/Descending Sorting. Two: It does string compares for all field comparisons. Three: You must have the array structured as Row,Column which is backwards from how ADO returns an array via the getRows function. [rant]<em>MvHO it's ADO that returns the array backwards. Why couldn't MS offer both ways if there was a need to "maintain backwards compatibility" with a historically fubarred thought process??</em>[/rant]</p></p><p><p>Anywho - I hacked the 4 Guys From Rolla Quick Sort routine (it's nice to be able to stand on the shoulders of giants) to support sorting direction as well as embedded a function that checks to see if the two fields being compared can both be evaluated as Numeric or as Strings (default) and "cloned" the QuickSort routine for the ADO way of array thinking.</p></p><p><p>The only thing lacking now with QuickSortv2 and QuickSortv2_ADO is a second column sort - but I'll leave that to someone better qualified to implement. ;-)</p></p><p><p>To utilize the Quick Sort routines, call it this way:</p></p><p><blockquote>QuickSortADO <em>vec</em>,&nbsp;<em>loBound</em>,&nbsp;<em>hiBound</em>,&nbsp;<em>SortField</em>,&nbsp;<em>SortDir</em><br><br></p>QuickSort <em>vec</em>,&nbsp;<em>loBound</em>,&nbsp;<em>hiBound</em>,&nbsp;<em>SortField</em>,&nbsp;<em>SortDir</em><br><br></p>Parameters:<br></p><ul type="none"></p><li><strong>vec</strong> - array to be sorted<br><br></li></p><li><strong>loBound</strong> &</li> </p><li><strong>hiBound</strong>  -  are simply the upper and lower bounds of the array's "row" dimension. [ADO = UBound(vec,2), Regular = UBound(vec,1)] It's probably easiest to use the LBound and UBound functions to set these.<br><br></li></p><li><strong>SortField</strong> - The field to sort on (1st dimension value)<br><br></li></p><li><strong>SortDir</strong> - ASC, ascending; DESC, descending</li></ul></blockquote></p><p><p><strong>Note:</strong> The PrintArray and PrintArrayADO are quick and dirty functions to print out your array in a table structure to quickly evaluate the sorting routine. So at minimum you need three functions: QuickSortADO, SwapRowsADO, and FormatCompare and/or QuickSort, SwapRows, and FormatCompare. Obviously you only need one copy of FormatCompare if you want both QuickSort routines in your library.</p></p><p><h2>***Quick Sort v2***</h2></p><p><pre></p>''' Regular Array Sort</p><p>Sub QuickSort(vec,loBound,hiBound,SortField,SortDir)</p>  '==--------------------------------------------------------==</p>  '== Sort a multi dimensional array on SortField            ==</p>  '==                                                        ==</p>  '== This procedure is adapted from the algorithm given in: ==</p>  '==    ~ Data Abstractions &amp; Structures using C++ by ~     ==</p>  '==    ~ Mark Headington and David Riley, pg. 586    ~     ==</p>  '== Quicksort is the fastest array sorting routine for     ==</p>  '== unordered arrays.  Its big O is n log n                ==</p>  '==                                                        ==</p>  '== Parameters:                                            ==</p>  '== vec       - array to be sorted                         ==</p>  '== SortField - The field to sort on (1st dimension value) ==</p>  '== loBound and hiBound are simply the upper and lower     ==</p>  '==   bounds of the array's &quot;row&quot; dimension. It's probably ==</p>  '==   easiest to use the LBound and UBound functions to    ==</p>  '==   set these.                                           ==</p>  '== SortDir   - ASC, ascending; DESC, Descending           ==</p>  '==--------------------------------------------------------==</p>  if not (hiBound - loBound = 0) then</p>      Dim pivot(),loSwap,hiSwap,temp,counter</p>      Redim pivot (Ubound(vec,2))</p>      SortDir = UCase(SortDir)</p><p>      '== Two items to sort</p>      if hiBound - loBound = 1 then</p>        if (SortDir = &quot;ASC&quot;) then</p>            if FormatCompare(vec(loBound,SortField),vec(hiBound,SortField)) &gt; FormatCompare(vec(hiBound,SortField),vec(loBound,SortField)) then Call SwapRows(vec,hiBound,loBound)</p>        else</p>            if FormatCompare(vec(loBound,SortField),vec(hiBound,SortField)) &lt; FormatCompare(vec(hiBound,SortField),vec(loBound,SortField)) then Call SwapRows(vec,hiBound,loBound)</p>        end if</p>      End If</p><p>      '== Three or more items to sort</p>      For counter = 0 to Ubound(vec,2)</p>        pivot(counter) = vec(int((loBound + hiBound) / 2),counter)</p>        vec(int((loBound + hiBound) / 2),counter) = vec(loBound,counter)</p>        vec(loBound,counter) = pivot(counter)</p>      Next</p><p>      loSwap = loBound + 1</p>      hiSwap = hiBound</p><p>      do</p>        '== Find the right loSwap</p>        if (SortDir = &quot;ASC&quot;) then</p>            while loSwap &lt; hiSwap and FormatCompare(vec(loSwap,SortField),pivot(SortField)) &lt;= FormatCompare(pivot(SortField),vec(loSwap,SortField))</p>              loSwap = loSwap + 1</p>            wend</p>        else</p>            while loSwap &lt; hiSwap and FormatCompare(vec(loSwap,SortField),pivot(SortField)) &gt;= FormatCompare(pivot(SortField),vec(loSwap,SortField))</p>              loSwap = loSwap + 1</p>            wend</p>        end if</p>        '== Find the right hiSwap</p>        if (SortDir = &quot;ASC&quot;) then</p>            while FormatCompare(vec(hiSwap,SortField),pivot(SortField)) &gt; FormatCompare(pivot(SortField),vec(hiSwap,SortField))</p>              hiSwap = hiSwap - 1</p>            wend</p>        else</p>            while FormatCompare(vec(hiSwap,SortField),pivot(SortField)) &lt; FormatCompare(pivot(SortField),vec(hiSwap,SortField))</p>              hiSwap = hiSwap - 1</p>            wend</p>        end if</p>        '== Swap values if loSwap is less then hiSwap</p>        if loSwap &lt; hiSwap then Call SwapRows(vec,loSwap,hiSwap)</p>      loop while loSwap &lt; hiSwap</p><p>      For counter = 0 to Ubound(vec,2)</p>        vec(loBound,counter) = vec(hiSwap,counter)</p>        vec(hiSwap,counter) = pivot(counter)</p>      Next</p><p>      '== Recursively call function .. the beauty of Quicksort</p>        '== 2 or more items in first section</p>        if loBound &lt; (hiSwap - 1) then Call QuickSort(vec,loBound,hiSwap-1,SortField,SortDir)</p>        '== 2 or more items in second section</p>        if hiSwap + 1 &lt; hibound then Call QuickSort(vec,hiSwap+1,hiBound,SortField,SortDir)</p>  end if</p>End Sub  'QuickSort</p><p>Sub SwapRows(ary,row1,row2)</p>  '==------------------------------------------==</p>  '== This proc swaps two rows of an array     ==</p>  '==------------------------------------------==</p><p>  Dim x,tempvar</p>  For x = 0 to Ubound(ary,2)</p>    tempvar = ary(row1,x)</p>    ary(row1,x) = ary(row2,x)</p>    ary(row2,x) = tempvar</p>  Next</p>End Sub  'SwapRows</p><p>function FormatCompare(sOne,sTwo)</p>  '==------------------------------------------==</p>  '==  Checks sOne &amp; sTwo, returns sOne as a   ==</p>  '==  Numeric if both pass isNumeric, if not  ==</p>  '==  returns sOne as a string.               ==</p>  '==------------------------------------------==</p><p>    if (isNumeric(Trim(sOne)) AND isNumeric(Trim(sTwo))) then</p>        FormatCompare = CDbl(Trim(sOne))</p>    else</p>        FormatCompare = Trim(sOne)</p>    end if</p>end function</p><p>Sub PrintArray(vec,loRow,hiRow,markCol)</p>  '==------------------------------------------==</p>  '== Print out an array  Highlight the column ==</p>  '==  whose number matches param markCol      ==</p>  '==------------------------------------------==</p><p>  Dim ColNmbr,RowNmbr</p>  Response.Write &quot;&lt;table border=&quot;&quot;1&quot;&quot; cellspacing=&quot;&quot;0&quot;&quot;&gt;&quot;</p>  For RowNmbr = loRow to hiRow</p>    Response.Write &quot;&lt;tr&gt;&quot;</p>    For ColNmbr = 0 to (Ubound(vec,2) - 1)</p>      If ColNmbr = markCol then</p>        Response.Write &quot;&lt;td bgcolor=&quot;&quot;FFFFCC&quot;&quot;&gt;&quot;</p>      Else</p>        Response.Write &quot;&lt;td&gt;&quot;</p>      End If</p>      Response.Write vec(RowNmbr,ColNmbr) &amp; &quot;&lt;/td&gt;&quot;</p>    Next</p>    Response.Write &quot;&lt;/tr&gt;&quot;</p>  Next</p>  Response.Write &quot;&lt;/table&gt;&quot;</p>End Sub  'PrintArray</p></pre></p><p><h2>***Quick Sort v2 ADO***</h2></p><p><pre></p>''' ADO Array Sort</p><p>Sub QuickSortADO(vec,loBound,hiBound,SortField,SortDir)</p>  '==--------------------------------------------------------==</p>  '== Sort a multi dimensional array on SortField            ==</p>  '==                                                        ==</p>  '== This procedure is adapted from the algorithm given in: ==</p>  '==    ~ Data Abstractions &amp; Structures using C++ by ~     ==</p>  '==    ~ Mark Headington and David Riley, pg. 586    ~     ==</p>  '== Quicksort is the fastest array sorting routine for     ==</p>  '== unordered arrays.  Its big O is n log n                ==</p>  '==                                                        ==</p>  '== Parameters:                                            ==</p>  '== vec       - array to be sorted                         ==</p>  '== SortField - The field to sort on (1st dimension value) ==</p>  '== loBound and hiBound are simply the upper and lower     ==</p>  '==   bounds of the array's &quot;row&quot; dimension. It's probably ==</p>  '==   easiest to use the LBound and UBound functions to    ==</p>  '==   set these.                                           ==</p>  '== SortDir   - ASC, ascending; DESC, Descending           ==</p>  '==--------------------------------------------------------==</p><p>  if not (hiBound - loBound = 0) then</p>      Dim pivot(),loSwap,hiSwap,temp,counter</p>      Redim pivot (Ubound(vec,1))</p>      SortDir = UCase(SortDir)</p><p>      '== Two items to sort</p>      if hiBound - loBound = 1 then</p>        if (SortDir = &quot;ASC&quot;) then</p>            if FormatCompare(vec(SortField,loBound),vec(SortField,hiBound)) &gt; FormatCompare(vec(SortField,hiBound),vec(SortField,loBound)) then Call SwapRowsADO(vec,hiBound,loBound)</p>        else</p>            if FormatCompare(vec(SortField,loBound),vec(SortField,hiBound)) &lt; FormatCompare(vec(SortField,hiBound),vec(SortField,loBound)) then Call SwapRowsADO(vec,hiBound,loBound)</p>        end if</p>      End If</p><p>      '== Three or more items to sort</p>      For counter = 0 to Ubound(vec,1)</p>        pivot(counter) = vec(counter,int((loBound + hiBound) / 2))</p>        vec(counter,int((loBound + hiBound) / 2)) = vec(counter,loBound)</p>        vec(counter,loBound) = pivot(counter)</p>      Next</p><p>      loSwap = loBound + 1</p>      hiSwap = hiBound</p><p>      do</p>        '== Find the right loSwap</p>        if (SortDir = &quot;ASC&quot;) then</p>            while loSwap &lt; hiSwap and FormatCompare(vec(SortField,loSwap),pivot(SortField)) &lt;= FormatCompare(pivot(SortField),vec(SortField,loSwap))</p>              loSwap = loSwap + 1</p>            wend</p>        else</p>            while loSwap &lt; hiSwap and FormatCompare(vec(SortField,loSwap),pivot(SortField)) &gt;= FormatCompare(pivot(SortField),vec(SortField,loSwap))</p>              loSwap = loSwap + 1</p>            wend</p>        end if</p>        '== Find the right hiSwap</p>        if (SortDir = &quot;ASC&quot;) then</p>            while FormatCompare(vec(SortField,hiSwap),pivot(SortField)) &gt; FormatCompare(pivot(SortField),vec(SortField,hiSwap))</p>              hiSwap = hiSwap - 1</p>            wend</p>        else</p>            while FormatCompare(vec(SortField,hiSwap),pivot(SortField)) &lt; FormatCompare(pivot(SortField),vec(SortField,hiSwap))</p>              hiSwap = hiSwap - 1</p>            wend</p>        end if</p>        '== Swap values if loSwap is less then hiSwap</p>        if loSwap &lt; hiSwap then Call SwapRowsADO(vec,loSwap,hiSwap)</p>      loop while loSwap &lt; hiSwap</p><p>      For counter = 0 to Ubound(vec,1)</p>        vec(counter,loBound) = vec(counter,hiSwap)</p>        vec(counter,hiSwap) = pivot(counter)</p>      Next</p><p>      '== Recursively call function .. the beauty of Quicksort</p>        '== 2 or more items in first section</p>        if loBound &lt; (hiSwap - 1) then Call QuickSortADO(vec,loBound,hiSwap-1,SortField,SortDir)</p>        '== 2 or more items in second section</p>        if hiSwap + 1 &lt; hibound then Call QuickSortADO(vec,hiSwap+1,hiBound,SortField,SortDir)</p>  end if</p>End Sub  'QuickSortADO</p><p>Sub SwapRowsADO(ary,row1,row2)</p>  '==------------------------------------------==</p>  '== This proc swaps two rows of an array     ==</p>  '==------------------------------------------==</p><p>  Dim x,tempvar</p>  For x = 0 to Ubound(ary,1)</p>    tempvar = ary(x,row1)</p>    ary(x,row1) = ary(x,row2)</p>    ary(x,row2) = tempvar</p>  Next</p>End Sub  'SwapRowsADO</p><p></p>function FormatCompare(sOne,sTwo)</p>  '==------------------------------------------==</p>  '==  Checks sOne &amp; sTwo, returns sOne as a   ==</p>  '==  Numeric if both pass isNumeric, if not  ==</p>  '==  returns sOne as a string.               ==</p>  '==------------------------------------------==</p><p>    if (isNumeric(Trim(sOne)) AND isNumeric(Trim(sTwo))) then</p>        FormatCompare = CDbl(Trim(sOne))</p>    else</p>        FormatCompare = Trim(sOne)</p>    end if</p>end function</p><p>Sub PrintArrayADO(vec,loRow,hiRow,markCol)</p>  '==------------------------------------------==</p>  '== Print out an array  Highlight the column ==</p>  '==  whose number matches param markCol      ==</p>  '==------------------------------------------==</p><p>  Dim ColNmbr,RowNmbr</p>  Response.Write &quot;&lt;table border=&quot;&quot;1&quot;&quot; cellspacing=&quot;&quot;0&quot;&quot;&gt;&quot;</p>  For RowNmbr = loRow to hiRow</p>    Response.Write &quot;&lt;tr&gt;&quot;</p>    For ColNmbr = 0 to Ubound(vec,1)</p>      If ColNmbr = markCol then</p>        Response.Write &quot;&lt;td bgcolor=&quot;&quot;FFFFCC&quot;&quot;&gt;&quot;</p>      Else</p>        Response.Write &quot;&lt;td&gt;&quot;</p>      End If</p>      Response.Write vec(ColNmbr,RowNmbr) &amp; &quot;&lt;/td&gt;&quot;</p>    Next</p>    Response.Write &quot;&lt;/tr&gt;&quot;</p>  Next</p>  Response.Write &quot;&lt;/table&gt;&quot;</p>End Sub  'PrintArray</p></pre>