---
layout: post
permalink: writing_smart_web-based_forms
ratings: 34
avgrate: 4.5588
category: Code
user: mwarden
real_name: "Matt Warden"
user_biog: "<p>
Matt Warden spends his spare time writing up author bios for his accounts on various websites... er... you know what? <a href=\"http://mattwarden.com\" rel=\"nofollow\" target=\"_new\">It\'s all here</a> somewhere anyways. No use repeating myself...
</p>"
user_since: 18 May 1999
avatar: "/images/pictures/picture-65.gif"
article_count: 7
excerpt: "Validating and processing form data is a common job for a Web programmer. This article takes out the guesswork."
---
<p></p>Forms are used frequently in dynamic web applications. As a consequence, </p>almost all web programmers have to deal with form data validation at some </p>point in their careers. The technique described in this article will help </p>you help the user submit correct information. </p></p></p><p><p></p>So, what's the technique? Building smart forms... well, smart validation, </p>actually. You <em>are</em> validating your forms on the server side, aren't </p>you? You don't want to <a href="http://www.ester.com/order.htm" </p>target="_new" title="an example of client-side validation only">validate </p>only on the client side</a>.</p></p></p><p><p></p>I can't tell you how many web sites I've visited that don't handle input errors</p>correctly. They either have forms that simply refresh with a generic "Your input </p>has errors" message or they <a href="http://www.cayenta.com/contact/index.html" </p>target="_new">only report the first input error</a> the validation script </p>encounters (you'll have to turn off client-side scripting to view this gem).</p></p></p><p><p></p>An <a </p>href="http://www.powerasp.com/content/hintstips/server-side-form-validation.asp" </p>target="_new">example on PowerASP.com</a> has the beginnings of TheRightIdea&trade; </p>and is worth a once-over. However, they miss the logical way of form validation and</p>processing. The article details how to process forms and report one or more input </p>errors using a form handler script and a redirect back to the form if there are </p>input errors. Other than the fact that this method isn't the most logical way of </p>doing things, there is also a loss of all of the users input unless they are also</p>passed along in the querystring. Wasn't this supposed to be easy?</p></p></p><p><p></p>Writing smart forms <em>can</em> be easy if you want it to be. I'm going to use ASP</p>in the actual <a href="/writing_smart_web-based_forms#examples">examples</a>, but the general </p><a href="/writing_smart_web-based_forms#concept">concept</a> can be applied using any language &#151;</p>except ColdFusion; you just can't do ANYTHING good with that (direct flames to </p><a href="mailto:flames@mattwarden.com">flames@mattwarden.com</a>).</p></p></p><p><h4><a name="concept">The Basic Concept</a></h4></p><p><p></p>There are a number of benefits gained by displaying and handling a form in the same </p>file. First, we have all of the code related to that form in a single location (with </p>the exception of code in include files). Second, we have available to our script every </p>submitted form variable. The general flow of our form processing is as follows:</p></p></p><p><p></p><img src="/images/65/10199/formflow.gif" alt="Form Processing Flow"></p></p></p><p><p></p>As you can see, we are validating the form before redirecting to any other page. In other </p>words, the form is submitting to itself. Within this script, there is logic which determines</p>whether it should display the form or process submitted form information. We are only moving </p>from our script if the submitted form passes our validation. If the information does not pass</p>validation, we re-display the form. We also pre-fill the form fields with the information already </p>submitted and mark the fields that didn't pass our validation. This makes it easier for the user</p>to supply the correct information.</p></p></p><p><p></p>So, let's say Joe User fills out the following form:</p></p></p><p><p></p><img src="/images/65/10199/form1.gif" alt="Form"></p></p></p><p><p></p>We don't like some of his input and our validation methods rejected it. Joe didn't even fill in his last name. </p>He didn't even try with his email address. And that zip code is not the zip code for Evoltageddon, NH.</p></p></p><p><p></p>How do we present these issues to Joe User? Should we just tell him he screwed up and have him </p>doing the work trying to figure out what is wrong (even though we've already figured out what's </p>wrong)? No. We indicate to him that there is a problem with his submission with some generic </p>text and highlight the fields that need to be corrected. The important part here is that both </p>his correct and incorrect data is preseved so he doesn't have to re-type the correct information </p>and he can also see what was wrong with his other information. So, we show Joe something like this:</p></p></p><p><p></p><img src="/images/65/10199/form2.gif" alt="Form With Input Errors"></p></p></p><p><p></p>You could take it a step further and display what was wrong with each field, but that is overkill </p>for most situations. In this example, the only field that could warrant an explanation is the zip code </p>field. However, the marked fields should do fine and there is only a very small chance that Joe will </p>get confused.</p></p></p><p><p></p>What does this mean? Well, when you're building forms (and form handlers) you should:</p></p></p><p><ul></p>	<li>Make the form self-submitting</li></p>	<li>Add logic to either show or process the form</li></p>	<li>Validate submitted information on the server-side</li></p>	<li>Redirect to the next page if information validates</li></p>	<li>If the submission does not validate, re-display the form pre-filled with submitted info and problem fields highlighted</li></p></ul></p><p><h4><a name="examples">The Basic Code</a></h4></p><p><p></p><strong>How can we determine whether to display or process the form?</strong></p></p></p><p><p></p>Some people like to pick a form field and test it for a value. For instance:</p></p></p><p></p><p><pre></p>if isEmpty(trim(request.form(&quot;firstname&quot;))) then</p>	' display the form</p>else</p>	' process the form</p>end if</p></pre></p><p></p><p><p></p>This method isn't the best way to do things. If I fill in every field but the first name field, </p>the form is simply re-displayed, with no error notification (because the code doesn't know there's </p>an error).</p></p></p><p><p></p>Another method is to pick the name of the submit button as the field to test:</p></p></p><p><pre></p>if isEmpty(trim(request.form(&quot;submitButton&quot;))) then</p>	Call displayForm()</p>else</p>	Call processForm()</p>end if</p></pre></p><p><p></p>The above code simply checks if request.form("submitButton") has a value. If it doesn't, it calls </p>a subroutine called displayForm(). This subroutine simply writes the HTML for the form. If it</p>does have a value, it calls processForm(), a subroutine that validates the form input. You could </p>also skip the subroutines (but, it's so much cleaner looking, eh?) and slop all the code for each </p>condition within the <code>if</code> test itself. However, when you scroll halfway down your script </p>and see an <code>else</code> and you don't know what expression the corresponding <code>if</code> tested, </p>you'll understand why I did it this way ;-)</p></p></p><p></p><p><p></p>Still, I don't like this method much. If the value attribute of the submit button tag is omitted, </p>isEmpty(trim(request.form("submitButton"))) will always be true. This is an easy thing to catch, but why </p>bother when there are easier ways of doing things?</p></p></p><p><p></p>The method I prefer uses the server variable REQUEST_METHOD. Most likely, when Joe User first </p>visits your form page, his browser will use the GET method. When the form is submitted, the browser </p>will use the POST method (you <em>are</em> using <code>method="POST"</code> when writing forms, </p>aren't you?). So, an easy way to check to see if the form has been submitted it to check the </p>REQUEST_METHOD:</p></p></p><p></p><p><pre></p>if ucase(trim(request.ServerVariables(&quot;REQUEST_METHOD&quot;)))=&quot;GET&quot; then</p>	Call displayForm()</p>elseif ucase(trim(request.ServerVariables(&quot;REQUEST_METHOD&quot;)))=&quot;POST&quot; then</p>	Call processForm()</p>else</p>	' are you supporting any other request methods?</p>end if</p><p></pre></p><p></p><p><p></p><p><strong>What is an easy way to make a form self-submitting?</strong></p><p></p></p><p><p></p>Simple. Another server variable available is SCRIPT_NAME. This holds the root-relative path</p>as well as the filename of the current script.</p></p></p><p></p><p><pre></p>&lt;!-- expanded tag for readability --&gt;</p>&lt;form </p>	method=&quot;POST&quot; </p>	name=&quot;userdetails&quot; </p>	action=&quot;&lt;%Response.Write request.ServerVariables(&quot;SCRIPT_NAME&quot;)%&gt;&quot;</p>&gt;</p></pre></p><p></p><p><p></p><p><strong>How can I pre-fill fields with submitted data after an input error has been found?</strong></p><p></p></p><p><p></p><p>Also fairly simple. Because the form is self-submitting, you have all the submitted form information </p>at your disposal.</p><p></p></p><p></p><p><pre></p>&lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;&lt;%Response.Write request.form(&quot;firstname&quot;)%&gt;&quot;&gt;&lt;br&gt;</p>&lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;&lt;%Response.Write request.form(&quot;lastname&quot;)%&gt;&quot;&gt;&lt;br&gt;</p></pre></p><p></p><p><p></p><p>Note that if you already have these form values stored in variables (which you should if you've </p>already run the submitted values through validation), you should use those values rather than </p>accessing them from the request object. <a href="/asp_coding_tricks#stuffing">More</a></p><p></p></p><p><p></p><p>It gets a little complicated if the form's purpose is to edit saved data in the database. The form </p>will already have data in it before the user inputs anything. So, if they change something and there's </p>an error with what they've changed, do you show the data from the database and let them re-edit that, or </p>do you display what they've just entered? Truthfully, it's a mix. Here, we're going to give importance to </p>the form data just submitted:</p><p></p></p><p></p><p><pre></p><p>&lt;%</p><p>function getValue(byval sImportant, byval sPassive)</p>	' notice that we aren't checking for</p>	' a valid value, just *any* value</p>	if not isEmpty(sImportant) then</p>		getValue = sImportant</p>	else</p>		getValue = sPassive</p>	end if</p>end function</p><p>%&gt;</p><p>&lt;!-- tags expanded for readability --&gt;</p>&lt;input type=&quot;text&quot; name=&quot;firstname&quot; </p>	value=&quot;&lt;%Response.Write getValue(request.form(&quot;firstname&quot;),Recordset(&quot;firstname&quot;))%&gt;&quot;</p>&gt;&lt;br&gt;</p><p>&lt;input type=&quot;text&quot; name=&quot;lastname&quot; </p>	value=&quot;&lt;%Response.Write getValue(request.form(&quot;lastname&quot;),Recordset(&quot;lastname&quot;))%&gt;&quot;</p>&gt;&lt;br&gt;</p></pre></p><p></p><p><p></p><p>The function <code>getValue(...)</code> above simply takes two values. The first value </p>is the value that should be returned if it has a value. If it does not have a value, we use</p>the second value. If the second value is simply an emptry string, then an empty string will be </p>returned. Since our first value is from the submitted form (if there <em>is</em> a submitted </p>form), then we are using the form input if it exists. Otherwise, we're using the data from the </p>database.</p><p></p></p><p></p><p><p></p><p><strong>So, how do I do this validation?</strong></p><p></p></p><p><p></p>Well, it obviously depends on the information you're validating. However, in my experience, </p>there are a few things that makes everything go a lot easier.</p></p></p><p><p></p><p>We need to know two things. First, we need to know if all the data validated. We also need to </p>know which bits of data validated and which did not.</p><p></p></p><p></p><p><pre></p><p>&lt;%</p><p>' general true/false for </p>' validation of entire submission</p>Dim bGoodPost</p><p>' specific true/false for </p>' validatin of each bit of data</p>Dim bGoodFname, bGoodLname, bGoodEmail</p><p>' data vars</p>Dim sFname, sLname, sEmail, sReferringFriend</p><p>sFname = trim(request.form(&quot;firstname&quot;))</p>sLname = trim(request.form(&quot;lastname&quot;))</p>sEmail = trim(request.form(&quot;emailaddr&quot;))</p>sReferringFriend = trim(request.form(&quot;referrer&quot;))</p><p>if isEmpty(sFname) then bGoodFname=false else bGoodFname=true</p>if isEmpty(sLname) then bGoodLname=false else bGoodLname=true</p>if not isValidEmail(sEmail) then bGoodEmail=false else bGoodEmail=true</p><p>bGoodPost = (bGoodFname and bGoodLname and bGoodEmail)</p><p>if bGoodPost then</p>	' validates!!!</p>else</p>	' re-display the form with values pre-filled </p>	' and problem fields highlighted</p>end if</p>%&gt;</p></pre></p><p></p><p><p></p><p>Here we have four variables. The first, <code>bGoodPost</code> stores whether</p>the entire form submission passes validation. This value is determined by the </p>required fields in the submitted form. In this example, firstname, lastname, </p>emailaddr are all required. referrer is not required and therefore we don't </p>care whether it has a value (though you may still want to validate </p>it if it does have a value, depending on the situation). So, we need to validate</p>these required fields. <code>bGoodFname</code>, <code>bGoodLname</code>, </p><code>bGoodEmail</code> will hold whether each of these values are valid. For </p><code>sFname</code> and <code>sLname</code>, all we do is check for a value.</p>For <code>sEmail</code>, we run it through our own email-validating function </p>(not shown here, use your imagination ;-). Like I said in the beginning, </p><code>bGoodPost</code> is true only if all of the required bits of information </p>pass our validation. An easy way to check for this is to use the line:</p><p></p></p><p></p><p><p></p><p><code>bGoodPost = (bGoodFname and bGoodLname and bGoodEmail)</code><br></p><p></p></p><p></p><p><p></p><p>Here, <code>bGoodPost</code> will only be true if <code>bGoodFname</code>, </p><code>bGoodLname</code>, and <code>bGoodEmail</code> are all true. This is </p>exactly what we want.</p><p></p></p><p></p><p><p></p><p>Also note that <code>if&nbsp;bGoodPost&nbsp;then</code> is the same as </p><code>if&nbsp;bGoodPost=true&nbsp;then</code>.</p><p></p></p><p></p><p><p></p><p><strong>After I've validated, how do I mark problem fields?</strong></p><p></p></p><p></p><p><p></p><p>The easiest way to do this is to use the same subroutine you used to display </p>the form in the first place. In this example, it was called displayForm().</p>Now we have to add the highlighting functionality so that the user knows </p>which fields had errors. Ok, at this point (assuming the form has already </p>been submitted), we know whether the first name, last name, and email address </p>are valid. The variables <code>bGoodFname</code>, <code>bGoodLname</code>, </p><code>bGoodEmail</code> tell us which values are valid and which are not. So, </p>depending on how you want to go, you can use one of the following methods to </p>highlight the fields with errors:</p><p></p></p><p></p><p><pre></p><p>&lt;!-- method 1 --&gt;</p>...</p>&lt;tr&gt;</p>&lt;td&gt;&lt;font </p>	face=&quot;arial&quot;</p>	&lt;%if not bGoodFname then response.write &quot; color=&quot;&quot;#ff0000&quot;&quot;%&gt;</p>&gt;First Name&lt;/font&gt;</p>&lt;input </p>	type=&quot;text&quot; </p>	name=&quot;firstname&quot;</p>	value=&quot;&lt;%Response.Write request.form(&quot;firstname&quot;)%&gt;&quot;</p>&gt;&lt;/td&gt;</p><p>&lt;!-- method 2, the cleaner method --&gt;</p>&lt;td&lt;%if not bGoodFname then response.write &quot; class=&quot;&quot;error&quot;&quot;%&gt;&gt;</p>First Name</p>&lt;input </p>	type=&quot;text&quot; </p>	name=&quot;firstname&quot;</p>	value=&quot;&lt;%Response.Write request.form(&quot;firstname&quot;)%&gt;&quot;</p>&gt;&lt;/td&gt;</p></pre></p><p></p><p><p></p><p>Now, we run into a problem when the form is first viewed (before submission).</p>All of those variables are going to be false. So, up where we're doing validation,</p>we need to account for this case:</p><p></p></p><p></p><p><pre></p>function isValidEmail(byval sEmail)</p>	' very simple email validation function.</p>	returnVal = false</p>	if not isEmpty(sEmail) then</p>		if instr(sEmail, &quot;@&quot;) &gt; 0 and instr(sEmail, &quot;.&quot;) &gt; 0 then</p>			returnVal = true</p>		end if</p>	end if</p>	isValidEmail = returnVal</p>end function</p><p>if isEmpty(sFname) then bGoodFname=false else bGoodFname=true</p>if isEmpty(sLname) then bGoodLname=false else bGoodLname=true</p>if not isValidEmail(sEmail) then bGoodEmail=false else bGoodEmail=true</p><p>bGoodPost = (bGoodFname and bGoodLname and bGoodEmail)</p><p>if ucase(trim(request.ServerVariables(&quot;REQUEST_METHOD&quot;)))=&quot;GET&quot; then</p>	bGoodFname=true</p>	bGoodLname=true</p>	bGoodEmail=true</p>end if</p></pre></p><p></p><p><p>And I'm sure you can think up some nice ways of getting around checking </p>the REQUEST_METHOD twice in the same script ;-)</p></p><p><p>Cool?</p></p><p><p>&nbsp;</p></p><p><h4>A Caveat</h4></p><p><p></p><p>Sending a response.redirect (or equivalent in your language of choice) generates </p>a HTTP response code of 302 (the requested file has been found but it is in a </p>different location). Rather than it executing the redirection by requesting </p>the new location, in very old browsers an &quot;Object Moved&quot; page might be </p>displayed. This is obviously not something we want. In ASP, there is a method of </p>the <code>Server</code> object called <code>Transfer()</code>. </p><code>Server.Transfer()</code> is a server-side redirect, rather than a client-side </p>redirect.  If this is available to you (ASP3/IIS5 and probably in other languages), </p>you will want to consider using that rather than sending a 302 header.</p><p></p></p><p><p>&nbsp;</p></p><p><p></p><p>--<br></p><p><a href="mailto:evolt@mattwarden.com">mattwarden</a><br></p><p><a href="http://www.mattwarden.com" target="_new">mattwarden.com</a><br></p><p></p>