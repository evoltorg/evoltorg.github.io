---
layout: post
permalink: node/25000
ratings: 18
avgrate: 3.7778
rating: 3.8
categories: [Code]
user: teradome
real_name: "Noah Mittman"
user_biog: "Noah Mittman [teradome] rode out his dot com dream at sputnik7.com for three years to the (unfortunately predictable) end, picking up a Webby Award with his colleagues along the way. He is currently applying his previous agency experience as the Senior Creative Technologist for <a href=\"http://www.merkleyandpartners.com\" rel=\"nofollow\">Merkley + Partners</a> where he spends most of his time on client-side development and advocating better user interfaces, and <em>not</em> updating his accessibility-oriented weblog at <a href=\"http://www.teradome.com\" rel=\"nofollow\">teradome.com</a>"
user_since: 08 Feb 2001
avatar: /images/pictures/picture-5578.jpg
article_count: 1
excerpt: "XSLT may just be the tool you've been looking for&#8212;get a jump start in here."
---
<h2>What is it?</h2></p><p><p></p>XSLT is short for eXtensible Stylesheet Language Transformations. It's an open standard originally for turning XML documents into different XML documents. But taking it further for web authoring, you can output almost any structured document you want, like HTML, PDF or SVG, on the fly. And since you are separating content from style on an even more extreme level than HTML &amp; CSS, you can create completely independent workflows between those who write content and those who build pages.</p></p></p><p><p></p>And it's not just a back-end, middleware solution. Mozilla/Netscape 6 and Internet Explorer both have basic XSLT support built-in. So you won't even need to install any servers to start trying it out (but you'll probably want to hold off before sending XML directly to the browser from your live sites).</p></p></p><p><h2>Let's dive in, shall we?</h2></p><p><p></p>So what does it look like? Let's start with a traditional Hello, World! "example.xml" document that looks like this:</p></p></p><p><pre></p>&lt;?xml version="1.0"?&gt;</p>&lt;?xml-stylesheet href="example.xsl" type="text/xsl"?&gt;</p>&lt;root&gt;</p>	&lt;message&gt;Hello, World!&lt;/message&gt;</p>&lt;/root&gt;</p></pre></p><p><p></p>By adding <code>&lt;?xml-stylesheet href="example.xsl" type="text/xsl"?&gt;</code> between the XML declaration and the root element of the document, you will tell your XML parser that this page will use an XSL stylesheet.</p></p></p><p><p></p>Now here's a basic XSLT stylesheet to use for "example.xsl":</p></p></p><p><p></p>[Since XSL is XML, you'll note the requirement for declaring the XSL namespace. The use of namespaces is similar to the way modern browsers now <a href="http://www.alistapart.com/stories/doctype/">switch between standards and quirks mode based on the DOCTYPE value</a> in that it is a unique system identifier for what those tags mean and how to operate on them. As you can see, the XSL namespace announces that you will be using transformations as per the W3C recommendation&#8212;It won't work without it.]</p></p></p><p><pre></p>&lt;?xml version="1.0"?&gt;</p>&lt;xsl:stylesheet</p>	version="1.0"</p>	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</p>&gt;</p>	&lt;xsl:output method="html"/&gt;</p>	&lt;xsl:template match="root"&gt;</p>		&lt;html&gt;</p>			&lt;head&gt;</p>				&lt;title&gt;XSL Test&lt;/title&gt;</p>			&lt;/head&gt;</p>			&lt;body bgcolor="white" text="black"&gt;</p>				&lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;</p>			&lt;/body&gt;</p>		&lt;/html&gt;</p>	&lt;/xsl:template&gt;</p>&lt;/xsl:stylesheet&gt;</p></pre></p><p><h2>So what did we just make?</h2></p><p><p></p>Putting it simply, XSL is a kind of find-and-replace script, which is executed as the XML parser walks through the document tree.</p></p></p><p><p>What you'll get when you view the example is a stream like this:</p></p><p><pre></p>&lt;html&gt;</p>	&lt;head&gt;</p>		&lt;title&gt;XSL Test&lt;/title&gt;</p>	&lt;/head&gt;</p>	&lt;body bgcolor="white" text="black"&gt;</p>		&lt;h1&gt;Hello, World!&lt;/h1&gt;</p>	&lt;/body&gt;</p>&lt;/html&gt;</p></pre></p><p><p></p>When the parser reaches the <code>&lt;root/&gt;</code> node in our example, the XSLT system will look for a match in the stylesheet and output that tag's contents. The match here is <code>&lt;xsl:template match="root"/&gt;</code>. But it could as well have been <code>&lt;xsl:template match="/"/&gt;</code>&#8212;the logic for this is based on XPath, which is the foundation for XSL (see the bottom of the article for a link to a tutorial).</p></p></p><p><p></p>You'll notice we didn't specify a match for <code>&lt;message/&gt;</code>, even though "Hello, World!" was placed inside the <code>&lt;h1/&gt;</code>. This is because of two particular concepts of XSL and XML.</p></p></p><p><h2>Tags &amp; Text: Picking vs Processing</h2></p><p><p></p>The first concept is the <code>&lt;xsl:apply-templates/&gt;</code> command&#8212;it tells the parser to continue processing children nodes contained in that particular match. Without this, the XSLT system will simply output the fragment of HTML that we've created for <code>&lt;root/&gt;</code> and move on, skipping any other tags contained inside of it.</p></p></p><p><p></p>The second concept is the difference between the tag/attribute node and the text node in a document&#8212;because there was no match for <code>&lt;message/&gt;</code> when the apply-templates command was called, the tag node was skipped... but the <em>text</em> node itself was processed and output into the new document.</p></p></p><p><p></p>We could have asked for a behavior like this by using another xsl command called value-of. Change <code>&lt;xsl:apply-templates/&gt;</code> to <code>&lt;xsl:value-of select="message"/&gt;</code> and you get an explicit command to include the node value of <code>&lt;message/&gt;</code> (again, "Hello, World!").</p></p></p><p><p></p>So let's change our XML to look like this:</p></p></p><p><pre></p>&lt;root&gt;</p>	&lt;message&gt;Hello, World!&lt;/message&gt;</p>	&lt;reply&gt;Hey, Programming Exercise!&lt;/reply&gt;</p>&lt;/root&gt;</p></pre></p><p><p></p>Now our modified stylesheet would ignore the reply value entirely, since without <code>&lt;xsl:apply-templates/&gt;</code>, the parser never walks down the document tree to the child nodes of <code>&lt;root/&gt;</code>.</p></p></p><p><p></p>If we had used the original stylesheet, it would create run-on of both elements in the same <code>&lt;h1/&gt;</code>:</p></p><p><pre></p>&lt;html&gt;</p>	&lt;head&gt;</p>		&lt;title&gt;XSL Test&lt;/title&gt;</p>	&lt;/head&gt;</p>	&lt;body bgcolor="white" text="black"&gt;</p>		&lt;h1&gt;Hello, World!Hey, Programming Exercise!&lt;/h1&gt;</p>	&lt;/body&gt;</p>&lt;/html&gt;</p></pre></p><p><p></p>The unmatched tag nodes are thrown out, and both text nodes are returned.</p></p></p><p><h2>Making it flexible</h2></p><p><p></p>Our stylesheet should then look more like this:</p></p></p><p><pre></p>&lt;?xml version="1.0"?&gt;</p>&lt;xsl:stylesheet</p>	version="1.0"</p>	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</p>&gt;</p>	&lt;xsl:output method="html"/&gt;</p>	&lt;xsl:template match="root"&gt;</p>		&lt;html&gt;</p>			&lt;head&gt;</p>				&lt;title&gt;XSL Test&lt;/title&gt;</p>			&lt;/head&gt;</p>			&lt;body bgcolor="white" text="black"&gt;</p>				&lt;xsl:apply-templates/&gt;</p>			&lt;/body&gt;</p>		&lt;/html&gt;</p>	&lt;/xsl:template&gt;</p>	&lt;xsl:template match="message"&gt;</p>		&lt;h1&gt;&lt;xsl:value-of select="."/&gt;&lt;/h1&gt;</p>	&lt;/xsl:template&gt;</p>	&lt;xsl:template match="reply"&gt;</p>		&lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;</p>	&lt;/xsl:template&gt;</p>&lt;/xsl:stylesheet&gt;</p></pre></p><p><p></p>And by now, you can guess that select="." is a shortcut for the text node of the current node. This would work for a document with any number of message or reply tags in them since it doesn't pretend to know the order or number of the items&#8212;it simply specifies how they should be transformed when encountered.</p></p></p><p><p></p>Of course, there are plenty of ways to go from here, from processing tag attributes, to setting priorities when a tag fits into more than one match, to filtering based on tag or text node contents. You may not find an immediate use for XSLT, but you won't be disappointed with it's possibilities.</p></p></p><p><p></p>I highly recommend the <a href="http://zvon.org/o_html/keyword_XSLT.html">resources and tutorials at Zvon.org</a> for more information, especially the <a href="http://zvon.org/xxl/XSLTutorial/Output/index.html">XSLT</a> and <a href="http://zvon.org/xxl/XPathTutorial/General/examples.html">XPath</a> tutorials.</p></p></p><p>And for those looking for server-side solutions for dynamic XML publishing, you can check out the Apache group's <a href="http://axkit.org" target="_blank">AxKit</a> (for Perl) and <a href="http://xml.apache.org/cocoon/" target="_blank">Cocoon</a> (for Java) projects.