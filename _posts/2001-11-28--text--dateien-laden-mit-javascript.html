---
layout: post
permalink: node/17537
ratings: 8
avgrate: 3.5000
categories: [Site Development]
user: janwinkler
real_name: "Jan Winkler"
user_biog: ""
user_since: 10 Nov 2001
avatar: 
article_count: 1
excerpt: "The article describes (in German) the possibilities which exist for JavaScript writers to dynamically load external text or data files."
---
<div language="de"></p><p>Wer selbst eine Homepage hat, und diese durch <em>interaktive</em> Elemente beleben will, kam oder kommt bestimmt einmal auch an JavaScript vorbei. Wer dann noch nach Höherem, wie etwa einer Datenbank oder derartigen Funktionen, strebt kommt allerdings bei JavaScript schnell an seine Grenzen. Das Laden (~ Einlesen) von Text- und anderen Dateien mit JavaScript bzw. JScript ist schon seit den Urzeiten der beiden Sprachen ein Thema für sich. Da JavaScript wie auch JScript keinen direkten Zugang zum Dateisystem haben, muss nach anderen Möglichkeiten oder Tricks gesucht werden. Im folgenden sollen nun einige Lösungsansätze für dieses Problem gegeben und behandelt werden.</p></p><p>Das Ziel besteht dann darin (<em>dynamisch</em>) einen Text (<strong>quelle.***</strong>) in das Dokument (<strong>ziel.***</strong>) einzubinden und das Ergebnis für den Besucher sichtbar zu machen.</p></p><p>Als Grundstock wird dabei jeweils nach einer Möglichkeit gesucht, Daten in eine Variable zu <em>laden</em>. Diese Variable soll dann einfach nur noch in das Dokument geschrieben werden.</p></p><p><h3>Die einfache Script-Variante</h3></p><p>Eine der ältesten und zugleich einfachsten Ideen Daten in eine Variable zu laden besteht darin, die Daten einfach schon in einer Variablen zu haben und diese zu Laden. Dieser Weg ist für die meisten Anwendungen völlig ausreichend und zudem noch sehr unkompliziert.</p></p><p>Die Idee ist, die Daten, die später geladen werden sollen, als Werte von definierten Variablen in einer <strong>.js</strong>-Datei abzuspeichern und diese dann - sofern sie benütigt werden - in die <acronym title="Hypertext Markup Language">HTML</acronym>-Datei zu laden. Benütigt werden dazu also 2 Dateien: Wir nennen sie mal quelle.js und ziel.htm</p></p><p>Beispiel:</p></p><p>In <strong>quelle.js</strong>:</p></p><pre></p>var Quelle = '...'</p></pre></p><p>In <strong>ziel.htm</strong>:</p></p><pre></p><script src=&quot;quelle.js&quot;></script></p><script></p><!--</p>&nbsp;document.writeln(Quelle);</p>//--></p></script></p></pre></p><p><h3>Die dynamische Script-Variante</h3></p><p>Um das Laden von Dateien nun noch etwas <em>freier</em> zu gestallten, ist es z.B. möglich, die jeweilige JavaScript-Datei dynamisch einzubinden. Dies greift auch wieder auf die erste Idee zurück, mit dem Unterschied, dass hierbei die gesamte Datei dynamisch eingebunden wird und nicht nur der Text aus einer Datei. Im folgenden Beispiel wird angenommen, dass die Text-Variable <code>Quelle</code> in der Datei quelle.js gespeichert ist. In der Datei wird als zusätzlicher Eintrag <code>document.writeln(Quelle);</code> am Ende eingefägt. Die dazugehürige <acronym title="Hypertext Markup Language">HTML</acronym>-Datei läd die Datei als Script ein. Durch das Laden wird auch der darin enthaltene Code ausgefährt und somit der Text geschrieben. Somit ist es quasi möglich <em>beliebige</em> (vorpreparierte) Dateien zu laden.</p></p><p>Beispiel:</p></p><p>In <strong>quelle.js</strong>:</p></p><pre></p>var text = '...'</p>document.writeln(text);</p></pre></p><p>In <strong>ziel.htm</strong>:</p></p><pre></p>&nbsp;document.writeln('<script src=&quot;quelle.js&quot;></script>');</p></pre></p><p><h3>Die Fenster-Variante</h3></p><p>Eine weitere Idee, Daten in JavaScript einzulesen ist die Fenster-Variante. Die überlegung besteht darin, die einzulesende Datei in ein neues Browser-Fenster zu öffnen und dieses dann auszulesen. Das öffnen dürfte dabei kein größeres Problem darstellen. Einzig zu beachten ist, dass die Datei möglichst mit einer Dateiendung gekennzeichnet ist, die vom Browser nicht ausgefährt oder als Download herunter geladen wird. Es sollte also sichergestellt sein, dass die Datei vom Browser angezeigt wird.</p><br /></p>Als weitaus größeres Problem stellt sich dann das Auslesen des Fensters dar. Mit <strong>Microsofts Internet Explorer</strong> geht dies relativ einfach:</p><br /></p>Von dem geöffneten Fenster wird das <code>document</code> abgefragt und von diesem wiederum mit <code>body.innerHTML</code> oder <code>documentElement.innerHTML</code> der Inhalt ausgelesen. Der Unterschied der beiden liegt darin, dass mit <code>body</code> wirklich nur der Inhalt des Bodys ausgefragt wird, wogegen <code>documentElement</code> das Root-Element der Datei ausgibt. Wird beispielsweise der zu lesende Text in eine Datei mit der Endung .htm oder .html gespeichert, so bekommt er normalerweise - auch wenn er keine <acronym title="Hypertext Markup Language">HTML</acronym>-Formatierungen enthält - eine gewisse Grundstruktur vom Browser verliehen (wozu z.B. ein <code>head</code> oder ein <code>body</code> gehören). Diese kann man <em>ausschalten</em> indem nur der Body ausgefragt wird - der abgefragte Text ist jedoch (nach einigen Umwandlungen) der gleiche.</p></p><p>Was den Netscape Navigator oder andere Browser betrifft, so ist diese Idee weniger leicht umzusetzten.</p><br /></p>Der <strong>Netscape Navigator</strong> bietet vor der Version 6.0 eigentlich keine Möglichkeiten den Inhalt eines Elementes oder des Dokumentes auszulesen. Ab 6.0 kann - ähnlich wie beim Internet Explorer - mit <code>document.documentElement.innerHTML</code> der Inhalt des Root-Elements ausgelesen werden. Den Text mit <code>document.body.innerHTML</code> einzulesen scheint hierbei jedoch nicht zu funktionieren.</p></p><p><strong>Opera und andere Browser</strong> sind dagegen nicht wirklich dazu zu bewegen, den Inhalt auszuspucken.</p></p><p>Sind die Daten jedoch ersteinmal ausgeladen, müssen sie nur noch verarbeitet und das Browser-Fenster kann wieder geschlossen werden.</p></p><p></p><p>Beispiel :</p></p><p>In <strong>quelle.txt</strong>:</p></p><pre></p>...</p></pre></p><p>In <strong>ziel.htm</strong>:</p></p><pre></p>b = 'quelle.txt'</p>c = window.open(b);</p>d = c.document.documentElement.innerHTML;</p>c.close();</p>if(d.toLowerCase().search('<body') != -1)</p>{</p> d = d.substr(d.toLowerCase().search('<body')+5,d.length);</p> d = d.substr(d.search('>')+1,d.length);</p>}</p>if(d.toLowerCase().search('</body') != -1)</p>{</p> d = d.substr(0,d.toLowerCase().search('</body')-1);</p>}</p>document.writeln(d);</p></pre></p><p>Ein weiteres Problem dabei ist, dass, sobald der Ladevorgang des Fensters zu lang andauert, das Ausfragen des Fensters vielleicht keine Resultate oder einen Fehler hervorruft. Dazu empfiehlt es sich, mit Ereignissen zu arbeiten (z.B. <code>onLoad</code>).</p></p><p><h3>Die ActiveX-Variante</h3></p><p>Neben zahlreichen anderen Dingen - die andere Browser nicht beherrschen - hat der Internet Explorer auch die Möglichkeit auf ActiveX-Objekte zuzugreifen. Die Idee ist nun, einfach das zuständige ActiveX-Objekt <a title="Microsoft Scripting" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/js56jslrfjscriptlanguagereference.asp">FileSystemObject</a>  zu verwenden um eine Datei zu öffnen, zu lesen und den Text auszugeben.</p></p><p>Auch hierbei entsteht wiederum ein größeres Problem: Wird das Script beim Clienten ausgefährt, so wird eine Datei im Internet nicht gefunden und kann demnach nicht geöffnet werden. Dazu kommt noch, dass 1. der MS Internet Explorer verwendet werden muss und 2. ActiveX eingeschaltet sein muss.</p></p><p>Diese Variante ist eher für serverseitiges Einfägen interessant (z.B. bei <acronym title="Active Server Pages">ASP</acronym>) - zur Anwendung im eigenen Intranet (etc.) wäre sie allerdings auch in <em>normalen</em> Internet-Seiten zu gebrauchen.</p></p><p>Beispiel:</p></p><p>In <strong>quelle.txt</strong>:</p></p><pre></p>...</p></pre></p><p>In <strong>ziel.htm</strong>:</p></p><pre></p>var a = new ActiveXObject('Scripting.FileSystemObject');</p>c = 'quelle.txt'</p>d = window.location.href;</p>d = d.substr(0,d.lastIndexOf('/')+1);</p>if(d.search('file:///') != -1) {d = d.substr(d.search('file:///')+8,d.length)}</p>e = a.OpenTextFile(d+c, 1, false);</p>f = e.ReadAll();</p>while(f.search('\u000A') != -1){f = f.replace('\u000A','<br>');}</p>document.writeln(f);</p></pre></p><p><h3>Die Data-Binding-Variante (ActiveX Nr.2)</h3></p><p>Eine weitere auf ActiveX basierende Idee ist Microsofts Data-Binding oder Data-Bind. Dabei werden im Internet Explorer bzw. Windows integierte ActiveX-Steuerelemente verwendet. Diese können mit dem <acronym title="Hypertext Markup Language">HTML</acronym>-Element <code>object</code> eingebunden und durch <code>param</code> gesteuert werden. Um Daten einzubinden wird die <code>classid</code> '<code>CLSID:333C7BC4-460F-11D0-BC04-0080C7055A83</code>' verwendet. Als Parameter können dazu unter anderem folgende übergeben werden:</p></p><ul></p> <li><code>DataURL</code> - die zu öffnende Datei</li></p> <li><code>TextQualifier</code> - zu verwendende Trennzeichen</li></p></ul></p><p>Dem Objekt wird eine <code>id</code> gegeben. Innerhalb der Seite kann dann über diese <code>id</code> ein <code>div</code>-Element</a> eingefägt werden, welches auf dieses Objekt (per <code>datascr</code>-Attribut) verweist. Handelt es sich bei den Daten um Text, sollte zusätzlich <code>datafld=&quot;Text&quot;</code> angegeben werden. Ausserdem kann mit <code>dataformatas=&quot;HTML&quot;</code> die Formatierung der Daten als <acronym title="Hypertext Markup Language">HTML</acronym> definiert werden.</p></p><p>Die zu öffnende Datei muss zusätzlich noch (um-)formatiert werden. Die erste Zeile sollte '<code>$Text:String$</code>' lauten, wobei <code>$</code> gegen die benannten Trennzeichen (<code>TextQualifier</code>-Attribut) ausgetauscht werden können. Zusätzlich muss jede weitere Zeile mit diesem Trennzeichen anfangen und beendet werden.</p></p><p>Beispiel:</p></p><p>In <strong>quelle.txt</strong>:</p></p><pre></p>$Text:String$</p>$...$</p></pre></p><p>In <strong>ziel.htm</strong>:</p></p><pre></p>b = 'quelle.txt'</p>c = '<OBJECT ID=&quot;meinObj&quot; WIDTH=&quot;0&quot; HEIGHT=&quot;0&quot; '+</p>    'CLASSID=&quot;CLSID:333C7BC4-460F-11D0-BC04-0080C7055A83&quot;></p>' +</p>    ' <PARAM NAME=&quot;DataURL&quot; VALUE=&quot;' + b + '&quot;></p>' +</p>    ' <PARAM NAME=&quot;TextQualifier&quot; VALUE=&quot;$&quot;></p>' +</p>    ' <PARAM NAME=&quot;FieldDelim&quot; VALUE=&quot; &quot;></p>' +</p>    ' <PARAM NAME=&quot;UseHeader&quot; VALUE=&quot;true&quot;></p>' +</p>    '</OBJECT></p>' +</p>    '<div datasrc=&quot;#meinObj&quot; datafld=&quot;Text&quot; dataformatas=&quot;HTML&quot;></div></p>'</p>document.write(c);</p></pre></p><!-- Beispiel nach Vorlage von Andreas Zierhut (http://www.dhtml-now.de / http://www.dhtml-now.de/javascr/sonstiges/externedatei.asp). --></p><p><h3>Die Java-Variante</h3></p><p>Ein weitere Idee besteht darin, auf Java zum Lesen der Datei zurück zu greifen. Da der Netscape Navigator in der Lage ist zwischen Java und JavaScript Kommunikation zu betreiben, können hierbei die Daten also auch mit JavaScript weiter verarbeitet werden. Der Internet Explorer unterstützt dies leider nicht - für ihn müsste der Java-Code daher in ein Applet verpackt werden. Auch hier wird die Datei vorher mit Trennzeichen und Formatierungen ausgestattet, sodass die Dateien aus der Data-Bining-Variante genutzt werden können. Folgender Code eignet sich für das auslesen von Dateien mit Java.</p></p><p>Beispiel:</p></p><p>In <strong>quelle.txt</strong>:</p></p><pre></p>$Text:String$</p>$...$</p></pre></p><p>In <strong>ziel.htm</strong>:</p></p><pre></p>function Einlesen(FileName, Trennzeichen)</p>{</p> a = self.location.pathname;</p> a = a.substring(0, a.lastIndexOf('/')+1);</p> b = new java.net.URL(self.location.protocol.split(':').join(''), self.location.host, a + FileName);</p> c = new java.io.BufferedReader(new java.io.InputStreamReader(b.openStream()));</p> d = c.readLine();</p> while((d = c.readLine()) != null)</p> {e += d + ' '}</p> c.close();</p> e = e.split(Trennzeichen).join('');</p>return(e);</p>}</p>if (document.layers && navigator.javaEnabled())</p>{</p> document.writeln(Einlesen('quelle.txt', '$'));</p>}</p></pre></p><!-- Beispiel nach Vorlage von Andreas Zierhut (http://www.dhtml-now.de / http://www.dhtml-now.de/javascr/sonstiges/externedatei.asp). --></p><p><h3>Alternativen zu JavaScript</h3></p><p>Zwar werden die beschriebenen Ideen für die meisten einfachen JavaScript-/Homepage-Bastler völlig ausreichend sein, dennoch ist keine wirklich professionelle Lösung mit JavaScript bzw. Jscript zu erreichen. Für die meisten Anwender wird sich demnach das Augenmerk eher auf eine andere Sprache richten.</p><br /></p>Nützlich dafür sind serverseitige Sprachen wie <acronym title="Hypertext Processor">PHP</acronym> oder <acronym title="Active Server Page">ASP</acronym>. Der Vorteil liegt dabei klar auf der Hand: Da der Client vom Server nur die Resultate des Einbindens bekommt, ist es egal, was für einen Browser er hat und es funktioniert immer. Eine mögliche <acronym title="Hypertext Processor">PHP</acronym>-Umsetzung zum Einbinden einer Textdatei wäre zum Beispiel:</p></p><p>In <strong>quelle.txt</strong>:</p></p><pre></p>...</p></pre></p><p>In <strong>ziel.php</strong>:</p></p><pre></p><script language=&quot;PHP&quot;></p>include &quot;quelle.txt&quot;;</p></script></p></pre></p><p><h3>Fazit</h3></p><p>Letztlich sollte jeder selbst sehen, was für seine Bed�rfnisse am Besten und ausreichend professionell genug ist. <acronym title="Hypertext Processor">PHP</acronym> oder <acronym title="Active Server Page">ASP</acronym> bieten sicherlich die beste Möglichkeit, wobei - je nach Anwendung - auch einfache JavaScript-Varianten durchaus ihren Dienst tun können.</p></p><p>PS: Dank an Andreas Zierhut (<a href="http://www.dhtml-now.de">http://www.dhtml-now.de</a> / <a href="http://www.dhtml-now.de/javascr/sonstiges/externedatei.asp">http://www.dhtml-now.de/javascr/sonstiges/externedatei.asp</a>) .</p></p></div>