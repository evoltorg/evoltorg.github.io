---
layout: post
permalink: How_to_create_a_hierarchical_navigation_menu
---
<h2>Introduction</h2>\n<p>Want to create a hierarchical navigation menu for your site &#8212; you think that's hard, read on and I'll show you it's not. The great thing about it is the section you're in will be expanded while the others collapsed to represent relation of the pages.\n</p></p><p><p><em>Why would one want hierarchical navigation links ah?</em> &#8212; well this really improves organisation as a whole, eases finding of information and access to related information.\n</p></p><p><h2>What's required</h2></p><p><p>\nFirst of all your site will have to use a hierarchical structure or have some special way of representing it, using canonical URIs is recommended, you won't get the result wanted otherwise.\n</p></p><p><p>\nMy site uses uses some remapping techniques so that more friendly URIs are presented to the user( and robots of course). If you want to know more about that a good start is to read\n<a href="http://evolt.org/article/Search_Engine_Friendly_URLs_with_PHP_and_Apache/17/15049/index.html" target="_new" title="Search Engine Friendly URLs Article (Opens in a New Window)">Search Engine Friendly URLs</a>,\n<a href="http://www.alistapart.com/stories/urls/index.html" target="_new" title="URLs! URLs! URLs! Article on A List Apart (Opens in a New Window)">URLs! URLs! URLs!</a> or\n<a href="http://www.alistapart.com/stories/succeed/index.html" target="_new" title="How to Succeed with URLs Article on A List Apart (Opens in a New Window)">How to Succeed with URLs</a>. Apache's documentation also has many examples of the use of mod_rewrite.\n</p></p><p><p>\nI'm using PHP for the code but there's no problem to use any given language that's used embedded in HTML or as a CGI, just some little adjustments need to be done.\n</p></p><p><h2>Configuration</h2></p><p><p>\nA good starting point is adding some configuration to your <code>.htaccess</code> or <code>httpd.conf</code> file.\n</p></p><p><pre>\nDirectoryIndex site index.php\n&lt;Files "site"&gt;\n	ForceType application/x-httpd-php\n&lt;/Files&gt;\n</pre></p><p><p>\n<code>DirectoryIndex</code> sets the file to be served when Apache receives a request for a directory. The next declaration forces the &quot;site&quot; file (without the quotes) to be treated as PHP code, even though it doesn't have the php extension.\n</p></p><p><pre>\nAction handle_my_php_pages /shaggy/site\nAddHandlet handle_my_php_pages .php\n</pre></p><p><p>\nThese two lines can ensure that your global page handler will also be called when a direct request for a php file is made. This is <em>optional</em> and may require some modifications to the code.\n</p></p><p><h2 id="style">Style rules to use</h2></p><p><pre>\nul.links {\n	margin-left : 0;\n	padding-left : 0;\n}</p><p>ul.links li {\n        margin-left : 0;\n        list-style : none;\n}</p><p>ul.links li ul {\n	padding-left : 2em;\n	margin-left : 0;\n}\n</pre></p><p><p>\nThis will prevent the default rendering of the unordered list items that browsers do and change it into something that's more likely to look appropriate for navigation links.\n</p></p><p><h2>The core of it</h2></p><p><p>\nI have all PHP code that is shown below saved in a file named <code>site</code>.\n</p></p><p><pre>\n$pages = array(\n	'Home' => 'home',\n	'News' => array(\n		0 => 'news/',\n		'Europe' => 'news/europe',\n		'USA' => 'news/usa',\n		'Asia' => 'news/asia'),\n	'Contact' => 'contact');\n$root = 'shaggy';\n$handler = 'site';\n</pre></p><p><p>\nThe <code>pages</code> array will hold the labels and their mapping to the URIs. Note the index value 0 used within the News subcategory, it maps to the section index. I used 0 because it evaluates to false in PHP, you will see why a bit later.\n</p></p><p><p>\nThe other two variables are set to the root of your site, and to the page that will handle file includes.\n</p></p><p><pre>\n$params = explode('/', $HTTP_SERVER_VARS['REQUEST_URI']);\narray_shift($params);\nforeach ( $params as $i => $value ) {\n	if ( $value == $root or $value == $handler )\n		array_shift($params);\n}</p><p>$include_file = implode('/', $params);\nif ( sizeof($params) &lt; 2 ) {\n	$include_file = 'root/' . $include_file;\n	$params[0] = 'root';\n}</p><p>$include_file = explode('?', $include_file);\n$include_file = $include_file[0];</p><p>if ( $params[sizeof($params)-1] == '' ) {\n	$include_file .= 'index';\n}</p><p>$include_file .= '.php';</p><p>if ( ! file_exists($include_file) ) {\n	$include_file = "$params[0]/index.php";\n}\ninclude($include_file);\n</pre></p><p><p>\nFirst explode the URI on <code>/</code>es (\n<code>track_vars</code> must be set to <code>on</code> in php.ini or a .htaccess file, else just use <code>$REQUEST_URI</code>) and get rid of the first empty value &#8212; that's because webservers process only absolute requests and they start with a slash. Next remove the other unnecessary info &#8212; namely the root and the global page handler for your site.\n</p></p><p><p>\n<code>$include_file = implode('/', $params)</code> does the same thing backwards, this time without the site global info to get the filename to be <code>include</code>d. A check is performed to find if the request is for a page in no category, I have all of them in a directory called <code>root</code>. You're maybe wondering why I have <code>$params[0] = 'root'</code> &#8212; this is because of the <code>file_exist</code> later on. Next remove the query string if present, that is usually done by the webserver for you but this time you want to include the files yourself and that's needed.\n</p></p><p><p>\nDirectory indexed end with &quot;/&quot;(a slash) so append <code>index</code> if this is the case, otherwise you will have to store your directory indexes in files called <code>.php</code> and that may be quite confusing.\n</p></p><p><p>\nFinally, perform a check if the file exists, if not forward to the section index (this code may need some improvements if you think this is likely to happen often). <code>include</code> the file that's requested.\n</p></p><p><p>\nThe <code>create_nav_links</code> does the <em>hard</em> work, it will traverse a given array and display the appropriate links, if it finds another array it will call itself with it as a parameter.\n</p></p><p><pre>\nfunction create_nav_links( $section, $level ) {\n	global $params;\n	if ( ! $level ) {\n		$markup = '&lt;ul class="links"&gt;' . "\n";\n	} else {\n		$markup = "&lt;ul&gt;\n";\n	}\n	foreach ( $section as $desc =&gt; $filename ) {\n		if ( ! is_array($filename) ) {\n			if ( $desc )\n				$markup .= '&lt;li&gt;&lt;a href="' . $handler . '/' . $filename . '"&gt;' . $desc . "&lt;/a&gt;&lt;/li&gt;\n";\n		} else {\n			if ( $params[$level] . '/' == $filename[0] ) {\n				$markup .= '&lt;li&gt;&lt;a href="' . $handler . '/' . $filename[0] . '"&gt;' . $desc . "&lt;/a&gt;\n";\n				$markup .= create_nav_links($filename, $level +1);\n				$markup .= "&lt;/li&gt;\n";\n			} else {\n				$markup .= '&lt;li&gt;&lt;a href="' . $handler . '/' . $filename[0] . '"&gt;' . $desc . "&lt;/a&gt;&lt;/li&gt;\n";\n			}\n		}\n	}\n	return ( $markup . "&lt;/ul&gt;\n" );\n}</p><p>echo create_nav_links($pages, 0);\n</pre></p><p><p>\nFirst check if we are at level 0, the topmost, if so add a class of <code>links</code> to the unordered list (see the <a href="/How_to_create_a_hierarchical_navigation_menu#style" title="Style Sheet">style sheet</a> given above). All new lines are optional and are added just to make the output HTML look nicer.\n</p></p><p><p>\nThe man loop traverses the array passed as a parameter, first we check to see if we're dealing with a normal file &#8212; i.e. not a section (which is represented as an array in our <code>pages</code> structure. Then a simple check if we have a description for this element &#8212; remember the 0 index used for the section URI in <code>pages</code>. If this was not checked you would have end up with categories listed again within themselves.\n</p></p><p><p>\nIn the other case &#8212; a category check (<code>if ( $params[$level] . '/' == $filename[0] )</code> if this is what we're within, we don't want to mess up the navigation menu with tons of links. If it is indeed our category, display a link to the index and add the output of <code>create_nav_links</code>, this time called with the section array and a level deeper.\n</p></p><p><p>\nIf this is some other category, the visitor is probably not interested in, just display a links to its index &#8212; <code>$markup .= '&lt;li&gt;&lt;a href="' . $handler . '/' . $filename[0] . '"&gt;' . $desc . "&lt;/a&gt;&lt;/li&gt;\n"</code>\n</p></p><p><p>\nFinally <code>echo</code> out the navigation to the browser, you should take care that it is printed where appropriate.\n</p></p><p><p>\nA little something that has to be added to the <code>head</code> of your pages:\n</p></p><p><pre>\n&lt;?php\n$base = 'http://' . $HTTP_SERVER_VARS['SERVER_NAME'] . $HTTP_SERVER_VARS['SCRIPT_NAME'];\n?&gt;\n&lt;base href="&lt;?php echo $base?&gt;" /&gt;\n</pre></p><p><p>\nThat ensures the consistency of your links generated by the <code>create_nav_links</code> function. Again this one requires <code>track_vars = on</code> in PHP's configuration.\n</p></p><p><h2>What else</h2></p><p><p>\nYou noticed that last note about the links, right?  Well, it ensures that these links are okay but when you begin using anchors in your documents you <em>can't</em> use anchor names relative to the current page, you'll have to make them relative to your document root.\n</p></p><p><p>\n<cite>You smarty, why don't you fix your function</cite> &#8212; well it will be not a problem to fix <em>this</em> function but what about any global style sheets or images referenced from your pages &#8212; you'll have to modify them for every page.\n</p></p><p><p>\nA better solution to this problem would be to use a function for creating links that are absolute (for the site) and get rid of the <code>base href</code>. Such a function would take as a parameter for example <code>news/europe</code> and return <code>/shaggy/site/news/europe</code>, the <code>$root</code> and <code>$handler</code> variables can be used for this transformation.\n</p></p><p><p>\nThis way to hold the navigation menu, as an PHP array, is good only if you want to update it into the source everytime you change something. A better solution would be to use a database to hold that data, even you may want to get the contents of the pages from a database source.\n</p>