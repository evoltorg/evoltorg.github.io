---
layout: post
permalink: node/758
ratings: 4
avgrate: 4.7500
category: Code
user: dwayne
real_name: "dwayne h"
user_since: 26 Apr 1999
avatar: ""
article_count: 3
excerpt: " It's a common thing - you've got some text files lying around with data in them, and you want to get it into some kind of reasonable order. Say, alphabetical, rather than whatever order your form script dumped the data into them. It's a simple enough task, and doing it is going to give us a couple "
---
<p> It's a common thing - you've got some text files lying around with data in them, and you want to get it into some kind of reasonable order. Say, alphabetical, rather than whatever order your form script dumped the data into them. </p></p></p><p></p> It's a simple enough task, and doing it is going to give us a couple of techniques that should come in handy in any number of situations. </p></p></p><p></p> We just need two tools to accomplish this - the <code>sort</code> function and references. </p></p></p><p></p> First, sorting. Perl has a handy <code>sort</code> function that you can use as simply as: </p></p></p><p></p> <code>     @sorted_names = sort @names; </code> </p></p></p><p></p> which will give you an alphabetically sorted array of the words contained in <code>@words</code>. As usual, perl makes some assumptions about what you want done if you're not explicit about it. Unless you tell it otherwise, sort will return the list that you gave it, sorted in standard string comparison order, ie, 'a' before 'b', and 'A' before 'a'. You may recognize this as the order ASCII runs in. </p></p></p><p></p> This is all well and good, but it's not quite what we want. What if someone like <a href="http://www.interlog.com/~r937/">rudy</a> enters their last name in lowercase - we want 'limeback' to come before 'Lombardo'. So when time comes for us to sort the data, we're going to want to make sure that all the last names are compared as if they were the same case. Well use <code>lc</code> to lowercase everything we sort. </p></p></p><p></p> Back to <code>sort</code>. When we say: </p></p></p><p></p> <code>     @sorted_names = sort @names; </code> </p></p></p><p></p> what perl actually thinks is: </p></p></p><p></p> <code>     @sorted_names = { $a cmp $b } @names; </code> </p></p></p><p></p> That <code>{ $a cmp $b }</code> is the key to the whole thing. It's a block of code that describes <b>how</b> we want things sorted. For each element in the list that we pass to <code>sort</code>, it runs this code and keeps track of whether <code>$a</code> or <code>$b</code> comes first. If <code>$a</code> should come first, the block should return a negative number, if <code>$b</code> should come first, it should return a positive number. If they're the same and their order doesn't matter, the block should return 0. The <code>cmp</code> and <code><=></code> operators are perfect for this, 'cause that just happens to be what they do. If you use something like the above, you'll get your list sorted in ascending alphabetical order. If you want descending order, you use <code>$b cmp $a</code>. </p></p></p><p></p> Right about now you're probably wondering where the hell <code>$a</code> and <code>$b</code> came from. I'm going to cop out and say they're magic. Just think about what you want to happen to any two values in your list, and imagine <code>$a</code> and <code>$b</code> being assigned their values. (This is roughly what happens anyway). </p></p></p><p></p> Combining <code>sort</code> and <code>lc</code>, we find that we can do something like: </p></p></p><p></p> <code>     @sorted_names = { lc($a) cmp lc($b) } @names; </code> </p></p></p><p></p> So now we have our sorting dealt with. Next we need to think about our data structure. </p></p></p><p></p> Let's say we have a tab delimitted file that looks something like this: </p></p></p><p></p><code></p>lombardo \t<br></p><p> guy \t</p><br></p> Las Vegas \t</p><br></p> Caesar's \t</p><br></p>guy@caesars.com \t</p><br></p>Mullholloch \t</p><br></p>Big Ed \t</p><br></p>Boondocks \t</p><br></p>Zippy Corp \t</p><br></p>biged@boonies.com Arban \t</p><br></p>Louis \t</p><br></p>Green River \t</p><br></p>Eviltoys \t</p><br></p>al@somewhere.com </code> </p></p></p><p></p> Essentially, what we have is a list of records, each record having a bunch of fields for each persons' last name, first name, location, employer and email address. If we only had one record to deal with, we might use a hash to keep track of it's values, and key the hash on the type of value we were keeping track of. Then when we wanted to find out Big Ed Mullholoch's email, for example, we could say: </p></p></p><p></p> <code>     print $big_ed{email}; </code> </p></p></p><p></p> which is great if we only have one person to keep track of. But we have a bunch. </p></p></p><p></p> The usual way to keep track of a bunch of individual things in perl is an array. So the natural thing to do seems to be to put each person's information into a hash, and put each of these hashes into an array. Then we'll have (surprise!) an array of hashes. We can then do all kinds of things like iterate through the array and pick out everyone's email address. Or, more germane to our problem, pick out their last name so we can sort on it. </p></p></p><p></p> Arrays in perl are fabulous. You can put any kind of scalar value into an element of an array. You can even put a <b>reference</b> to another array or a hash into them. This is the basis for all complex data structures, and this is exactly what we're going to do. We're going to read through our flat file, split up each persons' information into a hash, then put a reference to that hash into an element of an array. What we'll end up with is an array of hashes where each element of the array is refers to one persons information, and each key/value pair of the hash is a particular bit of data about that person. </p></p></p><p></p> Let's start with Big Ed. We've already got his data in the hash <code>%big_ed</code>. It has keys for his first and last name, email, etc. To put his information into an element of an array, we could say: </p></p></p><p></p> <code>     $people[0] = \%big_ed; </code> </p></p></p><p></p> The backslash indicates that what we're assigning to the first element of <code>@people</code> is a reference to the hash <code>%big_ed</code>. (this is important. if you use: </p></p></p><p></p> <code>     $people[0] = %big_ed; </code> </p></p></p><p></p> perl works with <code>%big_ed</code> in scalar context, and you'll get something weird like '5/8' assigned to <code>$people[0]</code>. This number doesn't mean much of anything to anyone except perl). </p></p></p><p></p> (For more on references, check out the perlref documentation in your perl installation (type 'perldoc perlref' at the command line, or look for it in the html directory of your perl installation). <a href="http://www.plover.com/~mjd/perl/FAQs/references.html">This</a> is also a good tutorial). </p></p></p><p></p> Now that we have Big Ed's data in <code>@people</code>, how do we get it out? The syntax is actually pretty intuitive if you're used to working with arrays and hashes anyway. To get at an element of an array, you use <code>$array[0]</code>. To get at an element of a hash, you use <code>$hash{key}</code>. Perl knows by the kind of brackets you use whether you're talking about an array or a hash. Same with references. The only thing you have to remember is that you need to add another <code>$</code> in front to tell perl that you want the value that <code>$people[0]</code> <b>points</b> to, not the actual value in <code>$people[0]</code>. The value in <code>$people[0]</code> is something like 'HASH(0x82d01fc)'. This value tells perl what's being pointed to (a hash) and where to find it. To get Big Ed's email, now we can say: </p></p></p><p></p> <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print $$people[0]{email}; </code> </p></p></p><p></p> and the output will be 'biged@boonies.com'. </p></p></p><p></p> Now we've got all the tools we need to make a data structure containing everybody's information, sort it, and spit it back out again. Probably the easiest way to see this is just to give you the code. Hopefully I've been clear enough that with a few comments you can figure out what's going on. If I've been completely murky, you can find me on <a href="http://lists.evolt.org/mailman/listinfo/thelist">thelist</a> and I'll try to clarify. </p></p></p><p></p> There's just one last expansion to the above description of getting Big Ed's data into <code>@people</code>. We don't actually have to put his info into a hash first. If we assign a piece of data to an element of a hash in an array, the necessary data strucutre will just pop into existence. If we say: </p></p></p><p></p> <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$people[0]{firstname} = 'Big Ed'; </code> </p></p></p><p></p> perl knows you want to put a hash with the key 'firstname' and the value 'Big Ed' into the first element of <code>@people</code>. This is immensely useful in things like while loops, as we'll soon see. </p></p></p><p></p> Below is a stripped down script that reads in a file like the one above into an array of hashes and prints it out again. I've written it as if it was an offline script just to make it easier to read. </p></p></p><p></p> <code></p><pre></p>#!/usr/bin/perl</p><p># always use strict, at least in development.</p># It makes you keep good habits.</p>use strict;</p><p>open (FH, &quot;data.txt&quot;);</p><p># the array where we'll keep everyone's data</p>my @people;</p><p># counter</p># we'll use this to keep track of which</p># array element we're assigning to </p>my $i = 0;</p><p># iterate through each line in data.txt</p>while (&lt;FH&gt;) {</p><p># hashes popping into existence and getting</p># stored in @people</p>  ($people[$i]{lastname},</p>    $people[$i]{firstname},</p>    $people[$i]{location},</p>    $people[$i]{employer},</p>    $people[$i]{email}</p>  ) = split(/\t/);</p><p># $_ is implicit</p><p># increment our counter by one so we can assign the</p># next person's data to the next element of @people</p>  $i++;</p>}</p><p># sort @people according to the value of 'lastname' in each element's hash</p>my @sorted_people = sort(</p>  {</p>    lc( $$a{lastname} )</p>    cmp lc( $$b{lastname} )</p>    }</p>  @people</p>);</p><p># now we iterate through @sorted_people, assigning each hash</p># in it to $person. Remember that we need two '$'s because</p># $person is a reference to a hash. If we just have one '$', perl</p># will think we're looking for the values of '%person', which</p># doesn't exist </p>for my $person(@sorted_people) {</p>  print &quot;$$person{lastname},</p>  $$person{firstname},</p>  $$person{location},</p>  $$person{employer},</p>  $$person{email}</p>&quot;;</p>}</p></pre></p> </code> </p> </p>