---
layout: post
permalink: Boolean_Fulltext_Searching_with_PHP_and_MySQL
ratings: 19
avgrate: 4.4737
rating: 4.35
categories: [Backend]
user: altherda
real_name: "David Altherr"
user_biog: "<a href=\"http://www.davidaltherr.net/\" rel=\"nofollow\">www.davidaltherr.net</a>"
user_since: 08 Aug 2001
avatar: 
article_count: 1
excerpt: "If you have search functionality based on PHP and MySQL but don't have the luxury of waiting for Boolean support with the release of MySQL 4.0, then this PHP hack may be of use to you."
---
<!-- article title: Boolean Fulltext Searching with PHP and MySQL --></p><!-- article author: David A Altherr altherda@email.uc.edu www.davidaltherr.net --></p><p><!-- Body --></p><p><h2>The Problem</h2></p><p><p></p>So you've finished two-thirds of an application when your project manager comes to you with a great idea (soon to be requirement), "I was thinking, it would be nice if we could add Boolean support to our search functionality... what do you think?"  Now, if the content data is stored in a MySQL database and accessed from a PHP framework, here are  a few canned responses to choose from:</p></p></p><p><ul></p><li> Would you like some cheese with that whine?</li></p><li> Well, it is 'possible', but we may have to wait for the release of MySQL 4.0.</li></p><li> Not a problem, I'll have it implemented by tomorrow.</li></p></ul></p><p><p></p>Unfortunately, most of us have settled on like variations of the second response; this is functionality that MySQL has promised with its next full version release.  The fact remains, the more web savvy users have come to expect a few options when searching:</p></p></p><p><ul></p><li> Search results sorted by relevance</li></p><li> Boolean statement support</li></p></ul></p><p><p></p>Support for such options are doubly important when we are dealing with large datasets like knowledge bases and news sites.  Fortunately, these are two areas in which MySQL already excels, just not both at the same time.  However, there is at least one PHP hack for those of us that can't wait for the 4.0 release.</p></p></p><p><h2>A Solution</h2></p><p><h3>Interactive Example</h3></p><p></p>Before we get into the explanation of how to use it and how it works, why don't we get straight to the point and see what this thing is capable of.  Here is a script that lets you test drive this functionality on a small sample database:</p><a href='http://davidaltherr.net/web/php_functions/boolean/form.mysql.boolean.php' target='_blank'>form.mysql.boolean.php</a></p></p></p><p><h3>The Code</h3></p><p></p>The functions:</p><a href='http://davidaltherr.net/web/php_functions/boolean/funcs.mysql.boolean.txt' target='_blank'>funcs.mysql.boolean.php</a><br/></p><p><pre></p>&lt;?php</p><p>/* * * * funcs.mysql.boolean.php * * * * * * * * * * * * * * * * * * * * *</p> *</p> *	The following file contains functions for transforming search</p> *	strings into boolean SQL.  To download the sample script and</p> *	dataset that use these functions, reference:</p> *	http://davidaltherr.net/web/php_functions/</p> *		boolean/example.mysql.boolean.txt</p> *</p> * 	Copyright 2001 David Altherr</p> *		altherda@email.uc.edu</p> *		www.davidaltherr.net</p> *</p> *	All material granted free for use under MIT general public license</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p><p></p><p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: get_fulltext_key($table) ::</p> *	retrieves the fulltext key from a table as a comma delimited</p> *	list of values. requires:</p> *		a. $mysqldb (selected database)</p> *		 OR</p> *		b. $table argument in the form 'db.table'</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function get_fulltext_key($table,$db_connect){</p>	global $mysqldb;</p>	mysql_select_db($mysqldb,$db_connect);</p><p>	/* grab all keys of db.table */</p>	$indices=mysql_query(&quot;SHOW INDEX FROM $table&quot;,$db_connect)</p>		 or die(mysql_error());</p>	$indices_rows=mysql_num_rows($indices);</p><p>	/* grab only fulltext keys */</p>	for($nth=0;$nth&lt;$indices_rows;$nth++){</p>		$nth_index=mysql_result($indices,$nth,'Comment');</p>		if($nth_index=='FULLTEXT'){</p>			$match_a[].=mysql_result($indices,$nth,'Column_name');</p>		}</p>	}</p><p>	/* delimit with commas */</p>	$match=implode(',',$match_a);</p><p>	return $match;</p>}</p><p></p><p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_mark_atoms($string) ::</p> * 	used to identify all word atoms; works using simple</p> *	string replacement process:</p> *    		1. strip whitespace</p> *    		2. apply an arbitrary function to subject words</p> *    		3. represent remaining characters as boolean operators:</p> *       		a. ' '[space] -&gt; AND</p> *       		b. ','[comma] -&gt; OR</p> *       		c. '-'[minus] -&gt; NOT</p> *    		4. replace arbitrary function with actual sql syntax</p> *    		5. return sql string</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function boolean_mark_atoms($string){</p>	$result=trim($string);</p>	$result=preg_replace(&quot;/([[:space:]]{2,})/&quot;,' ',$result);</p><p>	/* convert normal boolean operators to shortened syntax */</p>	$result=eregi_replace(' not ',' -',$result);</p>	$result=eregi_replace(' and ',' ',$result);</p>	$result=eregi_replace(' or ',',',$result);</p><p>	/* strip excessive whitespace */</p>	$result=str_replace('( ','(',$result);</p>	$result=str_replace(' )',')',$result);</p>	$result=str_replace(', ',',',$result);</p>	$result=str_replace(' ,',',',$result);</p>	$result=str_replace('- ','-',$result);</p><p>	/* apply arbitrary function to all 'word' atoms */</p>	$result=preg_replace(</p>		&quot;/([A-Za-z0-9]{1,}[A-Za-z0-9\.\_-]{0,})/&quot;,</p>		&quot;foo[('$0')]bar&quot;,</p>		$result);</p><p>	/* strip empty or erroneous atoms */</p>	$result=str_replace(&quot;foo[('')]bar&quot;,'',$result);</p>	$result=str_replace(&quot;foo[('-')]bar&quot;,'-',$result);</p><p>	/* add needed space */</p>	$result=str_replace(')foo[(',') foo[(',$result);</p>	$result=str_replace(')]bar(',')]bar (',$result);</p><p>	/* dispatch ' ' to ' AND ' */</p>	$result=str_replace(' ',' AND ',$result);</p><p>	/* dispatch ',' to ' OR ' */</p>	$result=str_replace(',',' OR ',$result);</p><p>	/* dispatch '-' to ' NOT ' */</p>	$result=str_replace(' -',' NOT ',$result);</p><p>	return $result;</p>}</p><p></p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_sql_where($string,$match) ::</p> * 	function used to transform identified atoms into mysql</p> *	parseable boolean fulltext sql string; allows for</p> *	nesting by letting the mysql boolean parser evaluate</p> *	grouped statements</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function boolean_sql_where($string,$match){</p>	$result = boolean_mark_atoms($string);</p><p>	/* dispatch 'foo[(#)]bar to actual sql involving (#) */</p>	$result=preg_replace(</p>		&quot;/foo\[\('([^\)]{4,})'\)\]bar/&quot;,</p>		&quot; match ($match) against ('$1')&gt;0 &quot;,</p>		$result);</p>	$result=preg_replace(</p>		&quot;/foo\[\('([^\)]{1,3})'\)\]bar/e&quot;,</p>		&quot; '('.boolean_sql_where_short(\&quot;$1\&quot;,\&quot;$match\&quot;).')' &quot;,</p>		$result);</p><p>	return $result;</p>}</p><p></p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_sql_where_short($string,$match) ::</p> *	parses short words &lt;4 chars into proper SQL: special adaptive</p> *	case to force return of records without using fulltext index</p> *	keep in mind that allowing this functionality may have serious</p> *	performance issues, especially with large datasets</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function boolean_sql_where_short($string,$match){</p>	$match_a = explode(',',$match);</p>	for($ith=0;$ith&lt;count($match_a);$ith++){</p>		$like_a[$ith] = &quot; $match_a[$ith] LIKE '%$string%' &quot;;</p>	}</p>	$like = implode(&quot; OR &quot;,$like_a);</p><p>	return $like;</p>}</p><p></p><p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_sql_select($string,$match) ::</p> *	function used to transform a boolean search string into a</p> *	mysql parseable fulltext sql string used to determine the</p> *	relevance of each record;</p> *	1. put all subject words into array</p> *	2. enumerate array elements into scoring sql syntax</p> *	3. return sql string</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function  boolean_sql_select($string,$match){</p>	/* build sql for determining score for each record */</p>	preg_match_all(</p>		&quot;([A-Za-z0-9]{1,}[A-Za-z0-9\-\.\_]{0,})&quot;,</p>		$string,</p>		$result);</p>	$result = $result[0];</p>	for($cth=0;$cth&lt;count($result);$cth++){</p>		if(strlen($result[$cth])&gt;=4){</p>			$stringsum_long .=</p>				&quot; $result[$cth] &quot;;</p>		}else{</p>			$stringsum_a[] =</p>				' '.boolean_sql_select_short($result[$cth],$match).' ';</p>		}</p>	}</p>	if(strlen($stringsum_long)&gt;0){</p>			$stringsum_a[] = &quot; match ($match) against ('$stringsum_long') &quot;;</p>	}</p>	$stringsum .= implode(&quot;+&quot;,$stringsum_a);</p>	return $stringsum;</p>}</p><p></p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_sql_select_short($string,$match) ::</p> *	parses short words &lt;4 chars into proper SQL: special adaptive</p> *	case to force 'scoring' of records without using fulltext index</p> *	keep in mind that allowing this functionality may have serious</p> *	performance issues, especially with large datasets</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function boolean_sql_select_short($string,$match){</p>	$match_a = explode(',',$match);</p>	$score_unit_weight = .2;</p>	for($ith=0;$ith&lt;count($match_a);$ith++){</p>		$score_a[$ith] =</p>			&quot; $score_unit_weight*(</p>			LENGTH($match_a[$ith]) -</p>			LENGTH(REPLACE(LOWER($match_a[$ith]),LOWER('$string'),'')))</p>			/LENGTH('$string') &quot;;</p>	}</p>	$score = implode(&quot; + &quot;,$score_a);</p><p>	return $score;</p>}</p><p></p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_inclusive_atoms($string) ::</p> *	returns only inclusive atoms within boolean statement</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function boolean_inclusive_atoms($string){</p><p>	$result=trim($string);</p>	$result=preg_replace(&quot;/([[:space:]]{2,})/&quot;,' ',$result);</p><p>	/* convert normal boolean operators to shortened syntax */</p>	$result=eregi_replace(' not ',' -',$result);</p>	$result=eregi_replace(' and ',' ',$result);</p>	$result=eregi_replace(' or ',',',$result);</p><p>	/* drop unnecessary spaces */</p>	$result=str_replace(' ,',',',$result);</p>	$result=str_replace(', ',',',$result);</p>	$result=str_replace('- ','-',$result);</p><p>	/* strip exlusive atoms */</p>	$result=preg_replace(</p>		&quot;(\-\([A-Za-z0-9]{1,}[A-Za-z0-9\-\.\_\,]{0,}\))&quot;,</p>		'',</p>		$result);</p>	$result=preg_replace(</p>		&quot;(\-[A-Za-z0-9]{1,}[A-Za-z0-9\-\.\_]{0,})&quot;,</p>		'',</p>		$result);</p>	$result=str_replace('(',' ',$result);</p>	$result=str_replace(')',' ',$result);</p>	$result=str_replace(',',' ',$result);</p><p>	return $result;</p>}</p><p></p>/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</p> *	:: boolean_parsed_as($string) ::</p> *	returns the equivalent boolean statement in user readable form</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p>function boolean_parsed_as($string){</p>	$result = boolean_mark_atoms($string);</p><p>	/* dispatch 'foo[(%)]bar' to empty string */</p>	$result=str_replace(&quot;foo[('&quot;,&quot;&quot;,$result);</p>	$result=str_replace(&quot;')]bar&quot;,&quot;&quot;,$result);</p><p>	return $result;</p>}</p><p></p><p>?&gt;</p><p></pre><br/><br/></p><p>The code of a simple example implementation complete with sample data:</p><a href='http://davidaltherr.net/web/php_functions/boolean/example.mysql.boolean.txt' target='_blank'>example.mysql.boolean.php</a><br/></p><p><pre></p>&lt;?php</p><p>/* * * * example.mysql.boolean.php * * * * * * * * * * * * * * * * * * * * *</p> *</p> *	The following file contains sample data to demonstrate the</p> *	capability of the functions contained in funcs.mysql.boolean.php:</p> *	http://davidaltherr.net/web/php_functions/</p> *		boolean/funcs.mysql.boolean.txt</p> *	To see the example, load the data into MySQL then run this script</p> *</p> * 	Copyright 2001 David Altherr</p> *		altherda@email.uc.edu</p> *		www.davidaltherr.net</p> *</p> *	All material granted free for use under MIT general public license</p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p><p></p><p>/* * * * Example Implementation * * * * * * * * * * * * * * * * * * * * *</p><p>   // MySQL Database //</p><p>	// architecture //</p>	CREATE DATABASE news;</p>	USE news;</p><p>	CREATE TABLE quotes (</p>		id int(9) NOT NULL auto_increment,</p>		author varchar(255),</p>		content text,</p>		PRIMARY KEY  (id),</p>		UNIQUE KEY id (id),</p>		FULLTEXT KEY author (author,content)</p>	) TYPE=MyISAM;</p><p>	// data //</p>	INSERT INTO quotes VALUES(</p>		10000,'George Stephanopolous',</p>		'The President has kept all the promises he intended to keep.');</p>	INSERT INTO quotes VALUES(</p>		10001,'Dan Quayle',</p>		'It is wonderful to be here in the great state of Chicago.');</p>	INSERT INTO quotes VALUES(</p>		10002,'Marion Barry',</p>		'Outside of the killings, Washington has one of the lowest crime rates in the country.');</p>	INSERT INTO quotes VALUES(</p>		10003,'David Dinkins',</p>		'I haven't committed a crime. What I did was fail to comply with the law.');</p>	INSERT INTO quotes VALUES(</p>		10004,'Dan Quayle',</p>		'It isn't pollution that's harming the environment. It's the impurities in our air and water that are doing it.');</p>	INSERT INTO quotes VALUES(</p>		10005,'George Dubya',</p>		'One word sums up probably the responsibility of any Governor, and that one word is ' to be prepared '.');</p>	INSERT INTO quotes VALUES(</p>		10006,'George Dubya',</p>		'The most important job is not to be Governor, or First Lady in my case.');</p><p></p> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</p><p></p>    // PHP Script //</p><p>	// form input //</p>	$table_name = 'news.quotes';</p>	$search_string = 'george (governor,president) -responsibility';</p><p>	// database connection //</p>	$db_host = 'localhost';</p>	$db_user = 'username';</p>	$db_pwd = 'password';</p>	$db_connect = mysql_connect($db_host,$db_user,$db_pwd) or die(mysql_error());</p><p>	// sql construction //</p>	require_once('funcs.mysql.boolean.php');</p>	$fulltext_key = get_fulltext_key($table_name,$db_connect);</p>	$sql =  &quot;SELECT id, author, content, </p>&quot;</p>		.boolean_sql_select(</p>			boolean_inclusive_atoms($search_string),</p>			$fulltext_key).&quot; as relevance </p>&quot;</p>		.&quot;FROM $table_name </p>&quot;</p>		.&quot;WHERE </p>&quot;</p>		.boolean_sql_where($search_string,$fulltext_key).&quot; </p>&quot;</p>		.&quot;HAVING relevance&gt;0 </p>&quot;</p>		.&quot;ORDER BY relevance DESC </p>&quot;;</p><p>	// data query //</p>	$result = mysql_query($sql,$db_connect) or die(mysql_error());</p>	$result_rows = mysql_num_rows($result);</p><p>	// get results //</p>	$output = &quot;</p>		&lt;table border=1&gt;</p>		 &lt;thead&gt;</p>		  &lt;tr&gt;</p>		   &lt;th&gt;id&lt;/th&gt;</p>		   &lt;th&gt;author&lt;/th&gt;</p>		   &lt;th&gt;content&lt;/th&gt;</p>		   &lt;th&gt;relevance&lt;/th&gt;</p>		  &lt;/tr&gt;</p>		 &lt;/thead&gt;</p>		 &lt;tbody&gt;&quot;;</p>	for($ith=0;$ith&lt;$result_rows;$ith++){</p>		$ir=mysql_fetch_row($result);</p>		$output .= &quot;</p>			&lt;tr&gt;</p>			 &lt;td&gt;$ir[0] &lt;/td&gt;</p>			 &lt;td&gt; $ir[1] &lt;/td&gt;</p>			 &lt;td&gt; $ir[2] &lt;/td&gt;</p>			 &lt;td&gt; $ir[3]&lt;/td&gt;</p>			&lt;/tr&gt;</p>&quot;;</p>	}</p>	$output .= &quot;</p>		 &lt;/tbody&gt;</p>		&lt;/table&gt;</p>&quot;;</p><p>	// get user readable statement //</p>	$parsed_as = boolean_parsed_as($search_string);</p><p>	// display process //</p>	echo 	&quot;&lt;h5&gt;Input Statement&lt;/h5&gt;</p>&quot;</p>		.&quot;&lt;p&gt;$search_string&lt;/p&gt;</p>&quot;</p>		.&quot;&lt;h5&gt;Parsed As&lt;/h5&gt;</p>&quot;</p>		.&quot;&lt;p&gt;$parsed_as&lt;/p&gt;</p>&quot;</p>		.&quot;&lt;h5&gt;SQL Generated&lt;/h5&gt;</p>&quot;</p>		.&quot;&lt;p&gt;&quot;.nl2br($sql).&quot;&lt;/p&gt;</p>&quot;</p>		.&quot;&lt;h5&gt;Query Results&lt;/h5&gt;</p>&quot;</p>		.&quot;&lt;p&gt;$output&lt;/p&gt;</p>&quot;;</p><p>?&gt;</p><p></pre></p></p></p><p><h3>Script Implementation</h3></p><p><p></p>The provided functions are mainly used to generate SQL elements of the <code>SELECT</code> and <code>WHERE</code> clauses as follows.  First, we must retrieve the <code>FULLTEXT KEY</code> column names from our table, <code>$table_name</code>, via our database connection, <code>$db_connect</code>:</p></p></p><p><code></p>&nbsp;&nbsp; $fulltext_key = get_fulltext_key($table_name,$db_connect);<br/></p></code></p><p><p></p>And then we build the SQL statement using <code>$fulltext_key</code> and the user input, <code>$search_string</code>:</p></p></p><p><code></p>&nbsp;&nbsp; $sql =  "SELECT id, author, content, </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; .boolean_sql_select(<br/></p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean_inclusive_atoms($search_string),<br/></p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $fulltext_key)." </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; ."as relevance </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; ."FROM $table_name </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; ."WHERE </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; .boolean_sql_where($search_string,$fulltext_key)." </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; ."HAVING relevance>0 </p>"<br/></p>&nbsp;&nbsp;&nbsp;&nbsp; ."ORDER BY relevance DESC </p>";<br/></p></code></p><p></p><h3>Supported Input</h3></p><p><dl></p><p> <dt><strong>Fundamental Operators</strong></dt></p> <dd></p>   The code supports five basic operators:</p>  <ul></p>   <li> <code>AND</code></li></p>   <li> <code>OR</code></li></p>   <li> <code>NOT</code></li></p>   <li> <code>(</code></li></p>   <li> <code>)</code></li></p>  </ul><br/></p> </dd></p><p> <dt><strong>Shorthand Operators</strong></dt></p> <dd></p>   The code also supports a shorthand syntax similar to ebay's boolean syntax; the two syntaxes can be intermixed at the users discretion:</p>  <ul></p>   <li> ' ' [space] represents <code>AND</code></li></p>   <li> ',' [comma] represents <code>OR</code></li></p>   <li> '-' [hyphen] represents <code>NOT</code></li></p>  </ul><br/></p> </dd></p><p> <dt><strong>Nesting, Grouping, Logical Precedence</strong></dt></p> <dd></p>  The code is also capable of nested Boolean statements to any plausible depth (that which MySQL can handle) via the use of parentheses.  These characters can also be used to force the order of evaluation of any given statement.  Remember that the <code>AND</code> operator has precedence over the <code>OR</code> operator.<br/><br/></p> </dd></p><p> <dt><strong>Allowed Characters</strong></dt></p> <dd></p>   As it exists, the code allows alphanumeric characters as well as the special characters '.', '_', and '-', providing they are not used as the first character in a subject word.  Regardless of the characters allowed in the code, there are certain limitations imposed by MySQL when it runs the fulltext searches.<br/><br/></p> </dd></p><p> <dt><strong>Minimum Word Length</strong></dt></p> <dd></p>  The actual minimum word length is defined when MySQL is compiled in the <code>myisam/ftdefs.h</code> file:<br/><br/></p><p>  <code>&nbsp;&nbsp; #define MIN_WORD_LEN 4</code><br/><br/></p><p>  If you need more functionality and don't want to go through the trouble of recompiling MySQL, no worry: the code is currently written to be adaptive to words of three or less characters.  For a given word, the SQL element in the <code>SELECT</code> clause will switch to a simple scoring algorithm that does a case insensitive count of the subject word in all of the <code>FULLTEXT KEY</code> columns without the use of the fulltext index; the SQL element in the <code>WHERE</code> clause will switch to a <code>LIKE</code> string comparison of the subject word with all of the <code>FULLTEXT KEY</code> columns.  Note that enabling this additional functionality may create some performance issues with larger datasets as it runs significantly slower than the fulltext system used for words of 4+ characters, perhaps because it does not use a compiled algorithm or the fulltext index.</p>  <br/><br/></p> </dd></p><p> <dt><strong>Stop Words</strong></dt></p> <dd></p>  Restrictions on stop words (common words) when using the fulltext search are still dictated by MySQL once compiled.  Remember that stop words are not excluded from the search, they simply generate a zero value for their individual relevance score.  However, if the adaptive functions are enabled then the generated SQL will return records with stop words of three or less characters.  Again, keep in mind that this functionality does not use the fullext index and is typically quite slow.</p>  <br/><br/></p> </dd></p><p> <dt><strong>Fundamental Constructs</strong></dt></p> <dd></p>   Some basic input:</p>  <ul></p>   <li> <code>atom1 AND atom2</code></li></p>   <li> <code>atom1 OR atom2</code></li></p>   <li> <code>atom1 NOT atom2</code></li></p>  </ul></p>   <br/></p> </dd></p><p> <dt><strong>Advanced Constructs</strong></dt></p> <dd></p>  Some more advanced input (based on the shorthand syntax):</p>  <ul></p>   <li> <code>atom1 (atom2,atom3) -atom4</code></li></p>   <li> <code>(atom1,atom2) -(atom1 atom2)</code> [construct for <code>atom1 XOR atom2</code>]</li></p>   <li> <code>atom1 (atom2,(atom3 -atom4)) -atom5</code></li></p>  </ul></p>   <br/></p> </dd></p><p></dl></p><p></p><h3>The Concept</h3></p><p><dl></p> <dt><strong>The <code>WHERE</code> Clause</strong></dt></p> <dd></p>  Assuming we have a table with columns <code>title,content</code> indexed on the <code>FULLTEXT KEY</code>, the typical syntax for implementing a fulltext search on said table might be:<br/><br/></p><p>  <code>&nbsp;&nbsp; MATCH (title,content) AGAINST ('george')</code><br/><br/></p><p>  If the fulltext index contains the word <code>george</code>, the above will return a floating point number, typically between 0.0 (exclusive) and 5.0 for any given record.  If the fulltext index does not contain the word <code>george</code>, the above will return 0.0 for any given record.  Thus, we can make the above statement evaluate to TRUE or FALSE with the following syntax:<br/><br/></p><p>  <code>&nbsp;&nbsp; MATCH (title,content) AGAINST ('george') > 0</code><br/><br/></p><p>  In order to facilitate boolean capability for an expression like<br/><br/></p><p>  <code>&nbsp;&nbsp; george AND dubya</code><br/><br/></p><p>  the corresponding SQL code in the <code>WHERE</code> clause will be<br/><br/></p><p>  <code></p>  &nbsp;&nbsp; MATCH (title,content) AGAINST ('george') > 0<br/></p>  &nbsp;&nbsp; AND<br/></p>  &nbsp;&nbsp; MATCH (title,content) AGAINST ('dubya') > 0<br/><br/></p>  </code></p> </dd></p><p> <dt><strong>The <code>SELECT</code> Clause</strong></dt></p> <dd></p>  The SQL in the <code>SELECT</code> clause can be used to calculate the total relevance as declared by the <code>relevance</code> alias for the above example like so:<br/><br/></p><p>  <code></p>  &nbsp;&nbsp; MATCH (title,content) AGAINST ('george')<br/></p>  &nbsp;&nbsp; +<br/></p>  &nbsp;&nbsp; MATCH (title,content) AGAINST ('dubya')<br/></p>  &nbsp;&nbsp; as relevance<br/><br/></p>  </code></p><p>  but the code utilizes a simplification which produces a numerical equivalent:<br/><br/></p><p>  <code></p>  &nbsp;&nbsp; MATCH (title,content) AGAINST ('george dubya')<br/></p>  &nbsp;&nbsp; as relevance<br/><br/></p>  </code></p> </dd></p><p> <dt><strong>The <code>HAVING</code> Clause</strong></dt></p> <dd></p>  We can also add a condition to the <code>HAVING</code> clause which will ensure that the query only returns records with a non-zero relevance:<br/><br/></p><p>  <code>&nbsp;&nbsp; relevance > 0</code><br/><br/></p><p>  While this may seem redundant considering the SQL in the <code>WHERE</code> clause which already deals which the inclusion and exclusion of records, this allows the developer to impose a minimum relevance restriction on the result set.<br/><br/></p><p>  <code>&nbsp;&nbsp; relevance > 0.2</code><br/><br/></p> </dd></p><p> <dt><strong>The <code>ORDER BY</code> Clause</strong></dt></p> <dd></p>  This clause sorts the results by our calculated relevance starting with the records with the highest relevance:<br/><br/></p><p>  <code>&nbsp;&nbsp; relevance DESC</code><br/><br/></p> </dd></p></dl></p><p><h3>Other Issues</h3></p><p><dl></p> <dt><strong>Performance</strong></dt></p> <dd></p>  I've implemented these functions in a knowledge base with 16,000+ records, and they have been running wonderfully since June 2001.  The largest table on this system is about 7,000+ records containing 77.1 MB of data with an 8.5 MB fulltext index.  Query times for a typical two to four atom statement on this table average about 0.25 seconds providing they use the fulltext index.  However, if the SQL is forced to adapt to a three or less character word, query times jump to over 5.0 seconds in some cases.  Query times on smaller tables with 1 MB of data and a 300 KB fulltext index are almost negligible, averaging 0.005 seconds with the fulltext index and 0.02 seconds without. <br/><br/></p> </dd></p><p> <dt><strong>Security</strong></dt></p> <dd></p>  The string replacements in the functions are only utilized to properly manage whitespace in the input string, they do not check for malicious user input.  Such checks should be made prior to passing the user input to these functions.</p> </dd></p></dl><br/></p><p><p></p>Keep in mind that some of the parameters in these functions are arbitrary or may be specific to the context in which they are used.  However, I do encourage you to email me with any general comments or improvements.  For more information on this topic:</p><a href='http://www.mysql.com/doc/F/u/Fulltext_Search.html' target='_blank'>MySQL Full-text Search</a>.</p></p></p><p>-- David Altherr