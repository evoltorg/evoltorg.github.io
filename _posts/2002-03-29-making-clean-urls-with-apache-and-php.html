---
layout: post
permalink: Making_clean_URLs_with_Apache_and_PHP
ratings: 15
avgrate: 4.1333
category: Backend
user: notabene
real_name: "Stephane Deschamps"
user_biog: "<p><a href=\"http://www.nota-bene.org/\" title=\"Stephane (personal site)\" hreflang=\"fr\" rel=\"nofollow\">St&eacute;phane</a> was a member of evolt.org\'s content working group for several years. He also belongs to <a href=\"http://pompage.net/\" hreflang=\"fr\" title=\"pompage.net: french-speaking site\" rel=\"nofollow\">Pompage.net</a>, a French initiative dedicated to translating prominent web-related articles to French, and founded <a href=\"http://www.paris-web.fr/\" hreflang=\"fr\" title=\"Paris-web.fr: french-speaking site\" rel=\"nofollow\">Paris-web.fr</a>, a non-profit organising seminars about web accessibility and quality.</p>

<p>He has worked on the web since 1999 and is working for one of the largest phone companies in France as a client-side web expert, evangelising for accessibility and standards.</p>

<p>His notion of being cool involves red wine, sunglasses and <a href=\"http://www.cafeshops.com/evoltgear\" title=\"&lt;head&gt; baseball caps and other cool evolt stuff: buy them and help support the community that supports you\" rel=\"nofollow\">&lt;head&gt; baseball caps</a>. These days he\'s busy raising kids and pretending he manages the little devils.</p>
"
user_since: 19 Mar 2002
avatar: /images/pictures/picture-22696.jpg
article_count: 4
excerpt: "Get rid of those query-string-filled URLs! With a few tricks using Apache and PHP, aim at permanent URLs..."
---
<p></p>Nowadays we almost systematically create database-generated websites. <acronym title="Universal Resource Locators">URLs</acronym>  are thus written on-the-fly and we usually call pages through query string, like:<br></p><code title="http://example.com/index.php?type=article&amp;id=25&amp;date_written=20020322">http://example.com/index.php?type=article&amp;id=25&amp;date_written=20020322</code>.</p></p></p><p><p></p>What I call &quot;clean&quot; URLs is what you can see on <a href="http://evolt.org/" target="_blank" title="you are here - opens in a new window">evolt.org</a>, for instance. In my example the URL would be:<br></p><code title="http://example.com/article/200203226">http://example.com/article/200203226</code>. </p><p></p><p><p></p>Let us assume that this article was the 6th written on the 22nd of march, 2002 and that we store this info in our database, see below, <a href="#structuring_your_data" title="internal link">Structuring your data</a>). The purpose of this article is to show you how to switch from the former to the latter with <a href="http://httpd.apache.org/" target="_blank" title="World-leading web server - opens in a new window">Apache</a> and <a href="http://www.php.net/" target="_blank" title="server-side language - opens in a new window">PHP</a> through a simple example.</p></p></p><p><p></p>Note: there's nothing polemic about this &quot;clean&quot; qualification. Anybody who finds a better name is welcome to use it instead...</p></p></p><p><h2>What's the use of switching from query strings to &quot;clean&quot; URLs?</h2></p><p><p></p>Dropping query strings and using these so-called &quot;clean&quot; URLs:</p></p></p><p><ul></p>  <li><strong>Enables indexing by search engines</strong>. As you probably know, </p>    when a search engine spiders your site and finds a query string it stops. </p>    After all, how on earth can the robot know that all the pages are not the </p>    same with just a different parameter passed to the page: what's the difference </p>    between <code>index.php?type=article&amp;id=25</code> and <code>index.php?style=red</code>? </p>    How can one expect a search engine to <em>know</em> the difference?</li></p>  <li><strong>Makes for more perennial URLs</strong>. As Tim Berners-Lee himself </p>    explained in <a href="http://www.w3.org/Provider/Style/URI.html" target="_blank" title="opens in a new window">Cool </p>    URIs don't change</a>, <cite>&quot;It is the duty of a Webmaster to allocate </p>    URIs which you will be able to stand by in 2 years, in 20 years, in 200 years&quot;.</cite> </p>    You can see where we're aiming at.</li></p>  <li><strong>Doesn't expose the server-side language</strong> in which you developed </p>    the site: No extension is provided, thus enabling you to switch from one server-side </p>    technology to another without generating multiple <dfn title="document not found">404 </p>    errors</dfn>. Moreover, as a side note, it's a bit more secure because it </p>    will take potential attackers more time to know what language you're using </p>    (but don't have too many illusions about that, the solution will eventually </p>    be found...)</li></p></ul></p><p><p></p>Need we say more?</p></p></p><p><h2><a name="structuring_your_data"></a>Structuring your data: creating unique identifiers</h2></p><p><p></p>First and foremost, think of the data stored. You have to be able to give a unique identifier to each article. So instead of (or in addition to) using an incremental <code>id</code> you must think of a unique, not-to-be-changed-in-the-future identifier.</p></p></p><p><p></p>My method in our example is this: create a field <code>uniqid</code> and give it the date concatenated with the rank of creation within the day. In my example my article's <code>uniqid</code> is <code>200203226</code> (the article was the 6th created on the 22nd of March, 2002). Of course one can imagine a situation where only one article is written per day. Thus maybe this <code>uniqid</code> field is redundant if you store the date the article was written. Or it can be YYYYMMDDHHmmss to have the whole date and no rank. [insert here any other naming method you like].</p></p></p><p><p></p>Note: there are many other ways to store your articles. Maybe they're each in their own text file in a dedicated <code>includes</code> directory and then you call them through an inclusion, maybe they're extracted from an XML file, etc. That's why I'm not too specific on the storage of data here.</p></p></p><p><h2>The 'article' file: parsing the URL</h2></p><p><p></p>Now we will create the <code>article</code> file using standard PHP code, even if, as you noticed, the file has no <code>.php</code> extension. We'll come back to this issue below, in <a href="#apache_forcetype" title="internal link">Using Apache's ForceType</a>. Here's the code for our <code>article</code> file:</p></p></p><p><pre>&lt;?php</p>    /* 1. parse the URL */</p>    $expl = explode(&quot;/&quot;,$HTTP_SERVER_VARS[&quot;REQUEST_URI&quot;]);</p>    $article_id = $expl[count($expl)-1];</p><p>    /* 2 security check */</p>    [omitted for the sake of simplicity]</p><p>    /* 3 populate the page with uniqid's content */</p>    [omitted for the sake of simplicity]</p>?&gt;</pre></p><p><p>Here's how it works:</p></p><p><ol></p>  <li>Parse the URL (<code>REQUEST_URI</code>) by <a href="http://www.php.net/manual/en/function.explode.php" target="_blank" title="explode() - opens in a new window">exploding</a> </p>    it, fetch the results in an array (<code>$expl</code>) and assing to <code>$article_id</code> </p>    the last occurence of the explosed array.</li></p>  <li>Check any security needed and stop the code on error. There's no reason </p>    to parse the page any further if what's passed to <code>$article_id</code> </p>    is not correct. In particular we'll check the following: </p>    <ul></p>      <li>Is <code>$article_id</code> valid? Does it really correspond to the </p>        format I'm looking for? For instance if I'm looking for a number of the </p>        form 'YYYYMMDDr' ('r' is the 'rank' in my example, remember?) and <code>$article_id</code> </p>        is a string (ie. 'foobarwhatever'), then there's something rotten in the </p>        kingdom of URLs.</li></p>      <li>Does <code>$article_id</code> compare to an existing value of <code>uniqid</code>?</li></p>      <li>In the case of a database-driven site: is there any database code passed </p>        through <code>$article_id</code> that could damage the database? Think </p>        of <code>drop table</code> instructions, for example.</li></p>      <li>[insert here any other security check you find necessary]</li></p>    </ul></p>  </li></p>  <li>Populate the page with the content corresponding to the <code>uniqid</code> </p>    equal to <code>$article_id</code>.</li></p></ol></p><p><h2><a name="apache_forcetype"></a>Using Apache's ForceType</h2></p><p><p></p>At first I tried creating &quot;clean&quot; URLs and redirecting them through 404 errors to the index.php, for example, which would then parse the URL and write the page accordingly. I ran into unsuspected trouble checking my system with <a href="http://browsers.evolt.org/?lynx/" target="_blank" title="Lynx is a text-based browser - opens in a new window">Lynx</a>: a 404 error is an error (yeah, right). So I guessed search engines would stop on this error. Damn. My world domination (&copy; <a href="http://www.glassdog.com/" target="_blank" title="nothing to do with the subject at hand but clever person, this Lance - opens in a new window">glassdog</a>) scheme goes down the drain.</p></p></p><p><p></p>Enter <code>ForceType</code>. This Apache directive forces the server to consider a file as being of another type than what is expected by default (see Apache's documentation on <a href="http://httpd.apache.org/docs/mod/mod_mime.html#forcetype" target="_blank" title="opens in a new window">ForceType</a>).</p></p></p><p><p></p>We will now use the <code>&lt;FilesMatch&gt;</code> directive to specify which file is to be considered as a PHP file and not a plain ol' text file, which is the default on most servers (see Apache's documentation on <a href="http://httpd.apache.org/docs/mod/core.html#filesmatch" target="_blank" title="opens in a new window">&lt;FilesMatch&gt;</a>).</p></p></p><p><p></p>Don't worry: even if you can't configure Apache directly because your hosting provider doesn't allow it, I've got good news: you can do it through a <code>.htaccess</code> file.</p></p></p><p><p></p>Here's a sample <code>.htaccess</code> I wrote in my root directory:</p></p></p><p><pre>&lt;FilesMatch &quot;^article$&quot;&gt;</p>    ForceType application/x-httpd-php</p>&lt;/FilesMatch&gt;</pre></p><p><p></p>The result is: Accessing <code>http://www.example.com/article/200203226</code> tells the server to consider <code>article</code> as PHP, then parse the URL, and push the content whose <code>uniqid</code> is <code>200203226</code> into the template. And voil&agrave;. We're done.</p></p></p><p><h2>Conclusion</h2></p><p><p></p>To sum up this very simple example:</p></p></p><p><ol></p>  <li>Call &quot;clean&quot; URLs when writing your code</li></p>  <li>Create as many templates as needed for each type of parsing</li></p>  <li>Specify their type in <code>.htaccess</code></li></p></ol></p><p><p></p>Your URLs now have a chance to be as permanent as their domain name.</p></p></p><p><p></p>For more server-side fun, you can include the same template in all the <code>ForceType</code>'d pages so that all the formatting will be written only once. You can also, like often in evolt.org, create longer URLs and parse them as a set of several parameter/value pairs. Be careful with that, though, because you may force search engines to index too many occurences of pages. Oh, well, maybe that's what you want after all...</p></p>