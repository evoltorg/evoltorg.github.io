<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Your First Xslt Page</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Your First Xslt Page</h2>
<p class="meta">19 Apr 2002</p>

<div class="post">
<h2>What is it?</h2></p><p><p>\nXSLT is short for eXtensible Stylesheet Language Transformations. It's an open standard originally for turning XML documents into different XML documents. But taking it further for web authoring, you can output almost any structured document you want, like HTML, PDF or SVG, on the fly. And since you are separating content from style on an even more extreme level than HTML &amp; CSS, you can create completely independent workflows between those who write content and those who build pages.\n</p></p><p><p>\nAnd it's not just a back-end, middleware solution. Mozilla/Netscape 6 and Internet Explorer both have basic XSLT support built-in. So you won't even need to install any servers to start trying it out (but you'll probably want to hold off before sending XML directly to the browser from your live sites).\n</p></p><p><h2>Let's dive in, shall we?</h2></p><p><p>\nSo what does it look like? Let's start with a traditional Hello, World! "example.xml" document that looks like this:\n</p></p><p><pre>\n&lt;?xml version="1.0"?&gt;\n&lt;?xml-stylesheet href="example.xsl" type="text/xsl"?&gt;\n&lt;root&gt;\n	&lt;message&gt;Hello, World!&lt;/message&gt;\n&lt;/root&gt;\n</pre></p><p><p>\nBy adding <code>&lt;?xml-stylesheet href="example.xsl" type="text/xsl"?&gt;</code> between the XML declaration and the root element of the document, you will tell your XML parser that this page will use an XSL stylesheet.\n</p></p><p><p>\nNow here's a basic XSLT stylesheet to use for "example.xsl":\n</p></p><p><p>\n[Since XSL is XML, you'll note the requirement for declaring the XSL namespace. The use of namespaces is similar to the way modern browsers now <a href="http://www.alistapart.com/stories/doctype/">switch between standards and quirks mode based on the DOCTYPE value</a> in that it is a unique system identifier for what those tags mean and how to operate on them. As you can see, the XSL namespace announces that you will be using transformations as per the W3C recommendation&#8212;It won't work without it.]\n</p></p><p><pre>\n&lt;?xml version="1.0"?&gt;\n&lt;xsl:stylesheet\n	version="1.0"\n	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"\n&gt;\n	&lt;xsl:output method="html"/&gt;\n	&lt;xsl:template match="root"&gt;\n		&lt;html&gt;\n			&lt;head&gt;\n				&lt;title&gt;XSL Test&lt;/title&gt;\n			&lt;/head&gt;\n			&lt;body bgcolor="white" text="black"&gt;\n				&lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;\n			&lt;/body&gt;\n		&lt;/html&gt;\n	&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</pre></p><p><h2>So what did we just make?</h2></p><p><p>\nPutting it simply, XSL is a kind of find-and-replace script, which is executed as the XML parser walks through the document tree.\n</p></p><p><p>What you'll get when you view the example is a stream like this:</p></p><p><pre>\n&lt;html&gt;\n	&lt;head&gt;\n		&lt;title&gt;XSL Test&lt;/title&gt;\n	&lt;/head&gt;\n	&lt;body bgcolor="white" text="black"&gt;\n		&lt;h1&gt;Hello, World!&lt;/h1&gt;\n	&lt;/body&gt;\n&lt;/html&gt;\n</pre></p><p><p>\nWhen the parser reaches the <code>&lt;root/&gt;</code> node in our example, the XSLT system will look for a match in the stylesheet and output that tag's contents. The match here is <code>&lt;xsl:template match="root"/&gt;</code>. But it could as well have been <code>&lt;xsl:template match="/"/&gt;</code>&#8212;the logic for this is based on XPath, which is the foundation for XSL (see the bottom of the article for a link to a tutorial).\n</p></p><p><p>\nYou'll notice we didn't specify a match for <code>&lt;message/&gt;</code>, even though "Hello, World!" was placed inside the <code>&lt;h1/&gt;</code>. This is because of two particular concepts of XSL and XML.\n</p></p><p><h2>Tags &amp; Text: Picking vs Processing</h2></p><p><p>\nThe first concept is the <code>&lt;xsl:apply-templates/&gt;</code> command&#8212;it tells the parser to continue processing children nodes contained in that particular match. Without this, the XSLT system will simply output the fragment of HTML that we've created for <code>&lt;root/&gt;</code> and move on, skipping any other tags contained inside of it.\n</p></p><p><p>\nThe second concept is the difference between the tag/attribute node and the text node in a document&#8212;because there was no match for <code>&lt;message/&gt;</code> when the apply-templates command was called, the tag node was skipped... but the <em>text</em> node itself was processed and output into the new document.\n</p></p><p><p>\nWe could have asked for a behavior like this by using another xsl command called value-of. Change <code>&lt;xsl:apply-templates/&gt;</code> to <code>&lt;xsl:value-of select="message"/&gt;</code> and you get an explicit command to include the node value of <code>&lt;message/&gt;</code> (again, "Hello, World!").\n</p></p><p><p>\nSo let's change our XML to look like this:\n</p></p><p><pre>\n&lt;root&gt;\n	&lt;message&gt;Hello, World!&lt;/message&gt;\n	&lt;reply&gt;Hey, Programming Exercise!&lt;/reply&gt;\n&lt;/root&gt;\n</pre></p><p><p>\nNow our modified stylesheet would ignore the reply value entirely, since without <code>&lt;xsl:apply-templates/&gt;</code>, the parser never walks down the document tree to the child nodes of <code>&lt;root/&gt;</code>.\n</p></p><p><p>\nIf we had used the original stylesheet, it would create run-on of both elements in the same <code>&lt;h1/&gt;</code>:</p></p><p><pre>\n&lt;html&gt;\n	&lt;head&gt;\n		&lt;title&gt;XSL Test&lt;/title&gt;\n	&lt;/head&gt;\n	&lt;body bgcolor="white" text="black"&gt;\n		&lt;h1&gt;Hello, World!Hey, Programming Exercise!&lt;/h1&gt;\n	&lt;/body&gt;\n&lt;/html&gt;\n</pre></p><p><p>\nThe unmatched tag nodes are thrown out, and both text nodes are returned.\n</p></p><p><h2>Making it flexible</h2></p><p><p>\nOur stylesheet should then look more like this:\n</p></p><p><pre>\n&lt;?xml version="1.0"?&gt;\n&lt;xsl:stylesheet\n	version="1.0"\n	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"\n&gt;\n	&lt;xsl:output method="html"/&gt;\n	&lt;xsl:template match="root"&gt;\n		&lt;html&gt;\n			&lt;head&gt;\n				&lt;title&gt;XSL Test&lt;/title&gt;\n			&lt;/head&gt;\n			&lt;body bgcolor="white" text="black"&gt;\n				&lt;xsl:apply-templates/&gt;\n			&lt;/body&gt;\n		&lt;/html&gt;\n	&lt;/xsl:template&gt;\n	&lt;xsl:template match="message"&gt;\n		&lt;h1&gt;&lt;xsl:value-of select="."/&gt;&lt;/h1&gt;\n	&lt;/xsl:template&gt;\n	&lt;xsl:template match="reply"&gt;\n		&lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;\n	&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</pre></p><p><p>\nAnd by now, you can guess that select="." is a shortcut for the text node of the current node. This would work for a document with any number of message or reply tags in them since it doesn't pretend to know the order or number of the items&#8212;it simply specifies how they should be transformed when encountered.\n</p></p><p><p>\nOf course, there are plenty of ways to go from here, from processing tag attributes, to setting priorities when a tag fits into more than one match, to filtering based on tag or text node contents. You may not find an immediate use for XSLT, but you won't be disappointed with it's possibilities.\n</p></p><p><p>\nI highly recommend the <a href="http://zvon.org/o_html/keyword_XSLT.html">resources and tutorials at Zvon.org</a> for more information, especially the <a href="http://zvon.org/xxl/XSLTutorial/Output/index.html">XSLT</a> and <a href="http://zvon.org/xxl/XPathTutorial/General/examples.html">XPath</a> tutorials.\n</p></p><p>And for those looking for server-side solutions for dynamic XML publishing, you can check out the Apache group's <a href="http://axkit.org" target="_blank">AxKit</a> (for Perl) and <a href="http://xml.apache.org/cocoon/" target="_blank">Cocoon</a> (for Java) projects.
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
