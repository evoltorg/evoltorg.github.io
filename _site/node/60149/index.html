<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Effectively Implementing Sql Phrasebooks</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Effectively Implementing Sql Phrasebooks</h2>
<p class="meta">20 May 2003</p>

<div class="post">
<p>This article describes effective and portable implementations of \nSQL Phrasebooks, using formatted constants as opposed to the currently accepted methods\nwhich call for XML Configuration files and dynamic general SQL Query generation\nroutines.  Formatting is a very old and standardized method of making\nstrings dynamic, and although there are currently numerous implementations\nthat vary depending on language, the formatted strings we will use are completely\nportable and standardized among all popular languages today.</p></p><p><p>Why not use XML?  Well, there is an argument (taken from \n<a href="http://www.Perl.com/pub/a/2002/10/22/Phrasebook.html" target="_blank"\n title="opens in new window">The Phrasebook Design Pattern</a>) \nthat mixing languages is bad. My feeling is that mixing SQL and\nXML, with library specific scalars intended to be parsed by the current \napplication, is hardly better than mixing SQL with Perl, PHP, or any other programming\nlanguage.  So our response is to isolate the SQL.  This keeps us from having\na statement for any one table more than once, ever.  We do this\nby only using completely constant values where we don't need variations of the\nsame query, and otherwise using strict prototyping.  This gives three distinct\nadvantages when writing Phrasebooks as libraries.</p>\n<p>The first is the obvious\nspeed advantage, resulting from not having to parse the XML file.  The second is\nthat string formatting is extremely standard among today's modern languages, which\nmeans our formatted queries are quite portable, and porting the Phrasebooks\nthemselves to different languages can be done with minimal effort.  </p>\n<p>The third advantage is that it helps reduce repetition.\nReducing repetition is the main focus behind Phrasebook design.  Repeating\nyourself in the code is quite possibly the worst thing you can do, especially\nwhen your repetition is large chunks of an alternate language within your\nprogram.  Why worry about repetition?  Well, repetition makes maintaining code\nquite difficult, especially with SQL, since if you change your database, you\nhave to remember to search all your programs that access the specific tables\nyou have changed, for whatever unanticipated reason you changed them, and\nchange the queries contained in them.  If you have all of your queries in a single\nlocation, and even then only once, this makes this process much less painful.</p>\n<p>When I first began discussing this in a public forum, the first question I\nreceived was, "Well, then won't we need a bunch of extra sprintfs?  I think that\nis kind of annoying."  Of course, my response was "Yes, but you don't have to see\nthem."  The way we get around this is by writing our own extremely mild wrappers\nto whichever DBI we are using.  The wrappers are quite simple; for instance,\nin PHP we simply make a class to wrap around the long, ugly mysql_* functions\nthat PHP's mysql DBI provides:</p>\n<pre>\n/* Simple DBI Wrapper */\nclass EasyMySQL {\nvar $Result;\nvar $Link;</p><p>function EasyMySQL ($User,$Pass,$Data,$Host = "localhost") {\n&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;Link = mysql_connect($Host,$User,$Pass);\n&nbsp;&nbsp;&nbsp;&nbsp;mysql_select_db($Data,$this-&gt;Link);\n}\nfunction rqueryf () {\n&nbsp;&nbsp;&nbsp;&nbsp;$args = func_get_args();\n&nbsp;&nbsp;&nbsp;&nbsp;return mysql_fetch_object(mysql_query\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( call_user_func_array( 'sprintf', $args ), $this-&gt;Link));\n}\nfunction queryf () {\n&nbsp;&nbsp;&nbsp;&nbsp;$args = func_get_args();\n&nbsp;&nbsp;&nbsp;&nbsp;return mysql_query(call_user_func_array( 'sprintf', $args ));\n}\nfunction rquery ($Query) {\n&nbsp;&nbsp;&nbsp;&nbsp;return mysql_fetch_object(mysql_query($Query, $this-&gt;Link));\n}\nfunction query ($Query) {\n&nbsp;&nbsp;&nbsp;&nbsp;return $this-&gt;Result = mysql_query($Query, $this-&gt;Link);\n}\nfunction next ($Handle="") {\n&nbsp;&nbsp;&nbsp;&nbsp;return mysql_fetch_object($Handle ? $Handle : $this-&gt;Result);\n}</p><p>/* Destruction Function [ php has no destructor, call explicitly ] */\nfunction close () {\n&nbsp;&nbsp;&nbsp;&nbsp;mysql_close($this-&gt;Link);\n&nbsp;&nbsp;&nbsp;&nbsp;return NULL;\n}\n}\n</pre>\n<p>This specific class may leave you with a few questions.  It provides more\nthan just a simple wrapper around sprintf and the query at hand. It also provides\nslightly enhanced syntax for iterations, formatted and nonformatted\nfunctions, and an internal Link and Result reference.  I used these because in\nthe particularprogram I wrote this class for, my module API left the global\nmysql link available to extensions, without interference.  Why did we fetch our\nrows as objects, instead of arrays or associative arrays?  That's a matter of\npersonal preference.  You can use whichever methods you want.</p>\n<p>So, when does the Phrasebook come in?  It comes in now.  Personally, my\nfavorite way to design Phrasebooks in PHP is as a class that inherits my DBI\nwrapper.  Here is a simple example:</p>\n<pre>\nclass Phrasebook extends EasyMySQL {\nfunction Q ($Query) {\n&nbsp;&nbsp;&nbsp;&nbsp;switch ($Query):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ACCOUNT:\nreturn &lt;&lt;&lt;SQL\nSELECT  id,\n&nbsp;&nbsp;&nbsp;&nbsp;name,\n&nbsp;&nbsp;&nbsp;&nbsp;address,\n&nbsp;&nbsp;&nbsp;&nbsp;city,\n&nbsp;&nbsp;&nbsp;&nbsp;state,\n&nbsp;&nbsp;&nbsp;&nbsp;zip\nFROM&nbsp;&nbsp;&nbsp;&nbsp;accounts\nWHERE   id = %d\nSQL;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case HITS:\nreturn &lt;&lt;&lt;SQL\nSELECT  sum(raw) as raw,\n&nbsp;&nbsp;&nbsp;&nbsp;sum(uni) as uni,\n&nbsp;&nbsp;&nbsp;&nbsp;date\nFROM&nbsp;&nbsp;&nbsp;&nbsp;stats\nWHERE   id = %d\nAND date &gt;= %d\nAND date &lt;= %d\nSQL;\n&nbsp;&nbsp;&nbsp;&nbsp;endswitch;\n}\n}\n</pre>\n<p>Here is an example of how we would use this:</p>\n<pre>\n/* Was like this... */\nmysql_connect($User, $Pass);\nmysql_select_db($Database);</p><p>$result = mysql_query("SELECT id, name, address, city, state, zip\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM accounts WHERE id = $id");\nwhile ($Data = mysql_fetch_object($result)) {\n...\n}</p><p>/* Now it's like this */\n$Database = new Phrasebook ($User, $Pass, $Database);</p><p>$Database-&gt;queryf($Database-&gt;Q("ACCOUNTS"), $id);\nwhile ($Data = $Database-&gt;next()) {\n...\n}\n</pre>\n<p>Obviously, the end result is a lot less code, especially for very large\nqueries, and looks much nicer, with all of the advantages discussed earlier.</p>\n<p>So what about Perl?  Well, Perl actually has specific advantages in\nPhrasebooks over PHP, mostly, that we can contain our SQL Phrasebook in a \npackage with constant, null prototyped definitions (when possible) and this\nincreases the speed of the Phrasebook access exponentially (not that it isn't\nalready very fast in the example above).  One rule to keep in mind with Perl\nis that if you only use a table once, you should use a null prototype for that\nquery.  Why?  Well if we're not doing anything dynamic, we don't need to pass\nparameters.  If we use a null prototype, the Perl compiler flags that method\nas a constant, and compiles it as if it were a single quoted string into our\ncode.  So it has absolutely no runtime loss over single quoted, static string\nformatting.  That's pretty impressive, abstracting the code without slowing it\ndown whatsoever.</p>\n<p>Here is an example Phrasebook package in Perl that executes the same\nqueries as the above PHP example:</p>\n<pre>\npackage Phrase;</p><p>sub ACCOUNT () { \n&lt;&lt;SQL;\nSELECT  id,\n&nbsp;&nbsp;&nbsp;&nbsp;name,\n&nbsp;&nbsp;&nbsp;&nbsp;address,\n&nbsp;&nbsp;&nbsp;&nbsp;city,\n&nbsp;&nbsp;&nbsp;&nbsp;state,\n&nbsp;&nbsp;&nbsp;&nbsp;zip\nFROM&nbsp;&nbsp;&nbsp;&nbsp;accounts\nWHERE   id = %d\nSQL\n}</p><p>sub HITS&nbsp;&nbsp;&nbsp;&nbsp;() {\n&lt;&lt;SQL;\nSELECT  sum(raw) as raw,\n&nbsp;&nbsp;&nbsp;&nbsp;sum(uni) as uni,\n&nbsp;&nbsp;&nbsp;&nbsp;date\nFROM&nbsp;&nbsp;&nbsp;&nbsp;stats\nWHERE   id = %d\nAND date &gt;= %d\nAND date &lt;= %d\nSQL\n}\n</pre>\n<p>\nHere is an example of how we would use this:</p>\n<pre>\n# What was this\n$sth = $dbh-&gt;prepare\n("SELECT id, name, address, city, state, zip FROM accounts WHERE id = $id");</p><p># Now becomes this\n$sth = $dbh-&gt;prepare(sprintf(Phrase-&gt;ACCOUNT, $id));\n</pre>\n<p>\nThis is obviously not only more pleasant to have in your code if you're not \ncurrently worrying about the SQL, but also has all the advantages mentioned\nearlier.</p>\n<p>As you can see here, we didn't exercise the database abstraction as in the\nPHP example mentioned, because the robustness of Perl's DBI doesn't\nreally require it.  If you wanted, however, to rid your code of the\nextra sprintfs, considering that Perl's DBI already offers the other conveniences our\nPHP wrapper had, write a simple object to inherit a DBI object and call\nprepare with a sprintf.  Here is an extremely simple example:</p>\n<pre>\npackage FormatDBI;\nuse DBI;\nuse Data::Dumper;</p><p>@FormatDBI::ISA = qw(DBI);</p><p>package FormatDBI::db;\n@FormatDBI::db::ISA = qw(DBI::db);</p><p>sub preparef {\nreturn $_[0]-&gt;prepare(sprintf($_[1], @_[2..$#_]));\n}</p><p>package FormatDBI::st;\n@FormatDBI::st::ISA = qw(DBI::st);</p><p>package main;\nuse strict;\nuse warnings FATAL =&gt; qw( all );</p><p>use Phrase;</p><p>my $dsn = "DBI:mysql:database=aff;host=localhost";\nmy $dbh = FormatDBI-&gt;connect($dsn, "username", "password");</p><p>my ($Data,$sth);</p><p>$sth = $dbh-&gt;preparef(Phrase-&gt;ACCOUNT, 40);\n...etc...\n</pre>\n<p>Hope you find this useful.</p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
