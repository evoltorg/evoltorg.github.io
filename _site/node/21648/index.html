<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Using Custom Tags To Ease Content Management</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Using Custom Tags To Ease Content Management</h2>
<p class="meta">02 Mar 2002</p>

<div class="post">
<p>\nSome typical questions from customers who want a website developed are...\n</p></p><p><ul>\n <li>I want to manage the content myself. Will you have a system for it?</li>\n <li>I don't know HTML or programming. Can I still manage my content?</li>\n <li>I can't understand these HTML tags? Is there an easier way out?</li>\n</ul></p><p><p>\nSo to address these questions what I decided to do was to come up with a simpler tagging scheme than HTML which even a layman could understand, which could be easily parsed into a HTML tag, and which the browser could understand. I will try to illustrate this with a simple example.\n</p></p><p><p>\nThe  main advantages to this method would be:\n</p></p><p><ul>\n <li>A layuser can manage content/layout features very easily with very little knowledge of HTML.</li>\n <li>Managing the content becomes much easier.</li>\n <li>The same concept can be reused and replicated in other website projects.</li>\n</ul></p><p><h2>Recreating the &lt;img&gt; Tag</h2></p><p><p>\nLet's take up the simple example of the image tag:<br>\n<code>&lt;img src=&quot;xyz001.jpg&quot; alt=&quot;xyz image&quot; align=&quot;right&quot;&gt;</code><br>\nThis is a typical way the image tag would be found. In a page-length article on a website, typically images come within the text, so it makes sense to allow the user to place the image where they want and to place as many images as they want.\n</p></p><p><p>\nSo what I did was reduce the image tag to:<br>\n<code>&lt;g n=&quot;index&quot;&gt;l&lt;/g&gt;</code>\n</p></p><p><p>\nThe tag, <code>&lt;g&gt;</code>, is not an HTML tag, but is our very own tag that our server-side script recognises.\n</p></p><p><p>\nLet's examine the various parts of our tag for this example:\n</p></p><p><dl>\n <dt><strong><code>&lt;g&gt; &lt;/g&gt;</code></strong></dt>\n <dd>This just indicates to our parsing program the beginning and ending of our tag.</dd>\n</dl>\n<dl>\n <dt><strong><code>n=&quot;index&quot;</code></strong></dt>\n <dd>This attribute indicates to the parser which image the user has requested, but the index need not be the image name. We will come to that later.</dd>\n</dl>\n<dl>\n <dt><code>&lt;g n=&quot;index&quot;&gt;<strong>l</strong>&lt;/g&gt;</code></dt>\n <dd>The <code>'l'</code> between the <code>&lt;g&gt;&lt;/g&gt;</code> is an alignment indicator which asks the image to align left (<code>'l'</code>) or right (<code>'r'</code>).</dd>\n</dl></p><p><p>\nIf you notice the "alt" attribute is not part of our tag, we shall come to that (again) later. Otherwise, this is definitely easier than entering a complete <code>&lt;img&gt;</code> tag.\n</p></p><p><p>Just a small clarification here, that i decided to add after reading some of \n  the comments below :<br>\n  I have used a tag called <code>&lt;g&gt;</code> in this example, some people \n  might consider that too cryptic, I could have very well used something like \n  <code>&lt;image name=&quot;x&quot;&gt;left&lt;/image&gt;</code>, The parser \n  described below will handle something like that by just changing the input parameters</p></p><p><h2>Applying our Custom Tag</h2></p><p><p>\nSo the content entry users have a form (I don't know what most people use&#8230; probably VB forms, Access forms or HTML forms like evolt.org) where they enter the content. In the case where I used this technique, the data store was a Domino database, so I used Domino forms (pretty rare&#8230;huh&#8230;!). The same technique can be easily duplicated on other systems. Some typical content entered by the user would be:\n</p></p><p><blockquote>\nX company reached IPO on Feb 14th , but the CEO was disbarred from attending the conference by the police as he had 6 arms <br><code>&lt;g n=&quot;CEO&quot;&gt;l&lt;/g&gt;</code>. But federal investigator Mr. Mulder came up with an alternate theory&#8230;. Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; Blah&#8230; blah&#8230;which conclusively <br><code>&lt;g n=&quot;Mulder&quot;&gt;r&lt;/g&gt;</code> proved that the CEO was an alien.\n</blockquote></p><p><p>\nThe parsing program goes through this and transforms the <code>&lt;g&gt;</code> tags to meaningful HTML <code>&lt;img&gt;</code> tags with the correct image name, which is then rendered in the browser, so the converted output would be:\n</p></p><p><blockquote>\nX company reached IPO on Feb 14th, but the CEO was disbarred from attending the conference by the police as he had 6 arms <code>&lt;img src=&quot;path/ceo.180x100.jpg&quot; align=&quot;left&quot; alt=&quot;CEOs at Lunch&quot;&gt;</code>. But federal investigator Mr. Mulder came up with an alternate theory&#8230;. Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; Blah&#8230; blah&#8230; which conclusively <code>&lt;img src=&quot;path/mulder.jpg&quot; align=&quot;right&quot; alt=&quot;Agent Mulder&quot;&gt;</code> proved that the CEO was an alien.\n</blockquote></p><p>\n<p>\nThe two main components that accomplish this are:\n</p></p><p><ul>\n <li>A centralized image storage system.</li>\n <li>An image parser.</li>\n</ul></p><p>\n<h2>A Centralized Image Store</h2></p><p>\n<p>\nI have a database table and form system (let's call it an image store&#8230;) which is managed by the content entry users where they upload the image in a user-friendly form and enter the image attributes there, which gets stored in the backend database. The parser uses the n=&quot;index&quot; attribute to locate the requested image from this table.\n</p></p><p>\n<h3>The image entry form</h3></p><p>\n<p>\nA typical procedure for entering the image would be like this:\n</p></p><p><ol>\n <li><strong> Add the image&#8230;</strong><br>\n  The image can be put in a database or in a file system, though in the case of a file system, we would also store the path information. (In my case, it was in a database for the sake of ease of management and the database had to be replicated as well - 2 birds with 1 stone). Typically the image has an unfriendly name, like img001_180x100.jpg. Users find these names very difficult to remember or to search for.</li>\n <li><strong>Specify an index name for the image&#8230;</strong><br>\n  This is a simple human understandable name which will be used by the content entry in our custom tag to identify the image: <code>&lt;g n='indexname'&gt;</code>.</li>\n <li><strong>Specify an "alt" text for the image&#8230;</strong><br>\n  This eases things for the user as they do not have to manually enter &quot;alt=&quot; text every time they put an image tag in the content. The parser automatically picks it up. There is an additional advantage, since alt texts are stored centrally.  In the case of images which are used in many places on a website, changing alt texts globally for an image would just imply a change in one place.</li>\n <li><strong>Enter a short description about the image&#8230;</strong><br>\n  I found this, along with alt text, very useful, since it allows building of an intuitive image search on a website.</li>\n</ol></p><p><p>\nThis is what my form would look like for entering images:<br>\n<img src="images/20519/21648/form.jpg" width="350" height="250" border="0" alt="Picture of sample Form"> \n</p></p><p>\n<h3>The image store table</h3></p><p>\n<p>\nMy table structure for the image manager would look like this:\n</p></p><p><table cellspacing="0" class="data">\n<thead>\n<tr valign="top">\n  <th>Img_index</th>\n  <th>Image</th>\n  <th>Image_AltText</th>\n  <th>Image_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr valign="top"><td>Fishcatch</td><td>8.jpg</td><td>Fish catch at hemingway</td><td>Fishing for sailfish at hemingways in the bay of biscay</td></tr>\n<tr valign="top"><td>Ceo</td><td>Ceo180x100.jpg</td><td>Mr. Ceo Laughing</td><td>CEO of X corporation, Mr CEO</td></tr>\n</tbody>\n</table></p><p><p>\nI used a global setting for things like &quot;hspacing&quot; and &quot;vspacing&quot; for images, even though this could have been incorporated into the form. I could have calculated things like height and width of the image when the user uploaded it&#8230; but let me leave it as another exercise.\n</p></p><p>\n<h2>The Image Parser</h2></p><p>\n<p>\nRegarding the Parser, I try to make it flexible for my needs.  In reality, I use it not only to handle <code>&lt;g&gt;</code> tags, but also a variety of other custom tags.  I have one for handling links and one for embedded tables. So it is a generic parser in Java which has generic routines from which other specialised parsers were extended.\n</p></p><p>\n<h3>How the parser works together with the Image store</h3></p><p>\n<ul>\n <li>Get the whole content to be displayed in a string.</li>\n <li>The string has all the text content with the embedded custom tags.</li>\n <li>The parser then scans through the string, and when it locates a <code>&lt;g&gt;</code> tag, it extracts the tag attributes.</li>\n <li>The parser then uses the index specified in <code>n=&quot;&quot;</code> to locate the image name in the image store.</li>\n <li>From the image store, it extracts all the associated info for the image, such as the "alt" attribute text.</li>\n <li>The information between the <code>&lt;g&gt;</code> and <code>&lt;/g&gt;</code>  (the "l" or "r") is used to set the <code>align=&quot;right&quot;</code> or <code>align=&quot;left&quot;</code> attributes for the <code>&lt;img&gt;</code> tag.</li>\n <li>With all this information, the <code>&lt;img&gt;</code> tag is finally built.</li>\n <li>Lastly, the parser replaces the <code>&lt;g&gt;&lt;/g&gt;</code> tags in the content string with the <code>&lt;img&gt;</code> tag.</li>\n <li>The content string is then further scanned for <code>&lt;g&gt;&lt;/g&gt;</code> tags and the same process happens again.</li>\n <li>Finally the transformed content string is outputted to the browser</li>\n</ul></p><p>\n<h3>Parser structure</h3></p><p><ul>\n <li>There is a generic parser called the baseParser which has generic routines for scanning for a specified tag in a content string.</li>\n <li>There is a task specific parser, in this case an image parser called imgParser, which uses the iterative routines of the baseParser to extract its tags from a string. The task specific parser also has a function to output a custom tag in a particular way (in this case it's as an <code>&lt;img&gt;</code> tag).</li>\n</ul></p><p><p>\nImage, below: structure of parsers<br>\n<img src="images/20519/21648/parsers.gif" width="320" height="100" alt="Picture of Parser Structure">\n</p></p><p>\n<h3>Source Code Listings</h3></p><p><h4>Source Code for baseParser</h4></p><p>\n<p>\nThis is a stripped out version of the baseParser. I removed a lot of application specific stuff to reduce the size of the parser as much as possible.  There are descriptive comments along with source code.\n</p></p><p><pre>\npublic class baseParser\n{\nprivate int nPreParseLength =0 ;\nprivate String strBeginp;\nprivate String strEndp;\nprivate String strRefp;\nprivate String str;\nprivate int lnkBeginLength;\nprivate int lnkRefLength;\nprivate int lnkEndLength;\n//these 2 variables are used to keep track of tag position in the content string\n//during an iterative scan through the content string\nprivate int m_nLastIndex=0;\nprivate int m_nPrevIndex=0;\npublic baseParser()\n{\nstrBeginp=&quot;&quot;;\nstrEndp=&quot;&quot;;\nstrRefp=&quot;&quot;;\nstr=&quot;&quot;;\nlnkBeginLength=0;\nlnkRefLength=0;\nlnkEndLength=0;\n}\n//String toBeParsed - string with content+custom tags which requires parsing\n//beginP - beginning tag e.g. &lt;g\n//endP - ending tag e.g. &lt;/g&gt;\n//refP - ref.attribute tag n=&quot;\npublic baseParser(String toBeParsed, String beginP, String endP, String refP)\n{\nstr = toBeParsed;\nstrBeginp = beginP;\nstrEndp = endP;\nstrRefp = refP;\nlnkBeginLength = strBeginp.length();\nlnkRefLength = strRefp.length();\nlnkEndLength = strEndp.length();\n}\n \n//iterator function which scans for tags sequentially\npublic String parseUnit(int nBeginIndex)\n{\n//look for beginning\nint nPrevIndex = str.indexOf(strBeginp,nBeginIndex);\n//beginining tag not found..so end it\nif (nPrevIndex == -1)\nreturn &quot;&quot;;\n//look for ending\nm_nPrevIndex = nPrevIndex;\nint nLastIndex = str.indexOf(strEndp,nPrevIndex);\nm_nLastIndex = nLastIndex+lnkEndLength;\nreturn str.substring(nPrevIndex, nLastIndex+lnkEndLength);\n}\n  \n//helper function for iterator \npublic String parseUnit()\n{\nreturn parseUnit(lastUnit());\n} //parses out the reference attribute of the tag\n// in &lt;tag ref=&quot;refattrib&quot;&gt;prop&lt;/tag&gt;\n//this parses out refattrib...\npublic String parseRef(String strCur)\n{\nint nRefBegin=0;\nint nRefEnd = 0;\nnRefBegin=strCur.indexOf(strRefp);\nnRefEnd = strCur.indexOf('&quot;', nRefBegin+lnkRefLength);\nreturn strCur.substring(nRefBegin+lnkRefLength,nRefEnd);\n} \n  \n//parses out the property of the tag \n// in &lt;tag ref=&quot;refattrib&quot;&gt;prop&lt;/tag&gt;\n//this parses out prop...\npublic String parseProp(String strCur)\n{ \nint nLnkEnd = 0;\nint n = 0;\nnLnkEnd = strCur.lastIndexOf(strEndp);\nfor (n=nLnkEnd; strCur.charAt(n) != '&gt;' &amp;&amp; n &gt;= 0; n--);\nif (strCur.charAt(n) != '&gt;')\nreturn &quot;&quot;;\nString strLnk = strCur.substring(n, nLnkEnd);\nnLnkEnd = strLnk.indexOf(&quot;&gt;&quot;);\nstrLnk = strLnk.substring(nLnkEnd+1); \nreturn strLnk;\n} \n  \n//helper function for iterator \npublic int prevUnit()\n{\nreturn m_nPrevIndex; \n}\n//helper function for iterator\npublic int lastUnit()\n{\nif (str.indexOf(strBeginp, m_nLastIndex) == -1)\nreturn -1;\nelse\nreturn m_nLastIndex ;\n}\n};</p><p></pre></p><p><h4>The image parser</h4></p><p><p>\nThe base parser gets used by the imgParser, as shown below. Again, I removed lot of application specific error checking and caching code to reduce size.\n</p></p><p><pre>\nimport java.util.Vector;\npublic class imgParser\n{\nprivate baseParser m_spa; \nprivate String m_strMain=&quot;&quot;;\nprivate String m_strKey=&quot;&quot;;\npublic imgParser()\n{\nm_strMain = &quot;&quot;;\nm_strKey = &quot;&quot;;\n}</p><p>//in reality i was also passing the db connection from the page \n//script to the parser...\n//this allowed me to reuse the connection i made to the db for \n//displaying the page\n//instead of creating new connections for each instance of the parser\npublic imgParser(String toBeParsed)\n{\nm_strMain = toBeParsed;\n//seed the base parser with our required tags\nm_spa = new baseParser(toBeParsed,&quot;&lt;g&quot;,&quot;&lt;/g&gt;&quot;,&quot;n=\&quot;&quot;);\n}</p><p>  private Vector lookupImageDb(String sImageNo )\n  {\n  \n  // this was a lotus domino routine which looked up the\n  // index name in the database and returned a row of \n  //information as a java Vector\n  //for illustrative purposes...i am just returning a dummy vector\n  //but your routine to query the db would come over here...\n  //this returned a vector with 2 columns\n  // 1st col - image filename\n  // 2nd col - image alt text\n  Vector v = new Vector(2);\n  v.addElement(new String(&quot;image.jpg&quot;));\n  v.addElement(new String(&quot;just a dummy image&quot;));\n  return v; \n  } private String getPath()\n  {\n  //i didnt hard code any paths...\n  //this function simply calculated the path to the image inside the\n  //database...since i was storing the image in the database\n  //you could use it to calculate paths...\n  //for illustrative purposes, i just return a dummy path...\n  return new String(&quot;/images&quot;) ;\n  }\n  \n  private int IMG_FILE_NAME_COL=0;\n  private int IMG_ALT_NAME_COL=1;\n  \n  private String ParseImageTag(String sImageNo, String sAlign)\n  {\n  String sTemp = &quot;&quot;;\n  try{\n    //lookup image info from image store	\n  Vector v = lookupImageDb(sImageNo);\n  //string used to store alt tag\n  String strAltTag=new String(&quot;&quot;);\n 	//string use to store image file name or handle in database\n  String strFileName = new String(&quot;&quot;);\n  //get the alt tage and file name\n  strAltTag = (String)v.elementAt(IMG_ALT_NAME_COL);\n  strFileName = (String)v.elementAt(IMG_FILE_NAME_COL);\n  //build the image tag\n  sTemp+=&quot;&lt;img src=\&quot;&quot;+getPath()+&quot;/&quot;+strFileName +&quot;\&quot;&quot;;\n     //set alignment depending on l or r properties\n  if (sAlign.equals(&quot;l&quot;))\n  sTemp+=&quot; align=\&quot;left\&quot;&quot;;\n  else\n  sTemp+=&quot; align=\&quot;right\&quot;&quot;;\n  //other tags\n  //apply alt tag only if it exists\n  if (strAltTag.length() != 0)\n  sTemp += &quot; alt=\&quot;&quot;+strAltTag+&quot;\&quot;&quot;;\n  sTemp+=&quot; hspace=\&quot;8\&quot; vspace=\&quot;8\&quot; &quot;;\n  sTemp+=&quot;border=0 /&gt;&quot;;\n  }\n  catch(Exception e)\n  {\n  e.printStackTrace();\n  }\n  finally{ \n  return sTemp; \n  }\n  }\n  \n  //the only function called externally for this parser\n  public String ParsedString() \n  {\n  String strTemp=&quot;&quot;;\n  \n  int nBegin=0;\n  int nPrev = 0;\n  int nLast = 0;\n  //call the base parser routine to iteratively scan for &lt;g&gt; tags\n  String sRet = m_spa.parseUnit(nBegin);\n  if (sRet.equals(&quot;&quot;)) //no image tags....so return string as is\n  return m_strMain;\n  //&lt;g&gt; tag found parse out attributes and properties \n  String sRef = m_spa.parseRef(sRet);\n  String sTxt = m_spa.parseProp(sRet);\n  nPrev = m_spa.prevUnit();\n  if (nPrev != -1)\n  {\n  //skip string to position at the end of &lt;g&gt;&lt;/g&gt;\n  strTemp = m_strMain.substring(0,nPrev);\n  //now build the &lt;img&gt; tag from the &lt;g&gt; tag \n  strTemp+=ParseImageTag(sRef, sTxt);\n  }\n  nLast = m_spa.lastUnit(); //check if end\n  while (nLast!=-1)\n  {\n  //parse the next &lt;g&gt; tag set\n  sRet = m_spa.parseUnit();\n  //&lt;g&gt; tag found parse out attributes and properties \n  sRef = m_spa.parseRef(sRet);\n  sTxt = m_spa.parseProp(sRet);\n  nPrev = m_spa.prevUnit();\n  if (nPrev != -1)\n  {\n  //skip string to position at the end of current &lt;g&gt;&lt;/g&gt; \n  strTemp+= m_strMain.substring(nLast,nPrev);\n  //parse out next image tag...\n  strTemp+=ParseImageTag(sRef, sTxt);\n  }\n  nLast = m_spa.lastUnit();\n  } \n  strTemp+=m_strMain.substring(nPrev+sRet.length());\n  return strTemp; \n  }\n  };\n</pre></p><p>\n<h4>Using the parser in script</h4></p><p><p>\nI use the imgParser in my code in this manner:\n</p></p><p>\n<pre>\n//..other code on page\nString strContent;\nString strParsedContent;\nstrContent = get_Content_As_String_From_Content_Table_Field();</p><p>//in reality i pass my database connection handle of the page script \n//to the parser, so i can reuse it\n//create our image parser object and pass the content string to it\nimgParser ipObj = new imgParser(strContent);</p><p>//strParsedContent contains the transformed string now...\nstrParsedContent = ipObj.ParsedString();</p><p>//...output parsed content to page\nprintwriterObj.print(strParsedContent);\n</pre></p><p>\n<h2>Finally&#8230;</h2></p><p>\n<p>\nJust a few thoughts before I finish this&#8230;\n</p></p><p><p>\nI use quite a few parsers built around the base parser.  I use a link parser, which basically uses a custom tag for links, that appends a particular class name and a target=_blank for links external to the site. I use another tag to embed a small table dynamically within the text with a specific alignment.\n</p></p><p><p>\nThere might be performance implications in heavily trafficked sites, since the parser runs every time someone hits the page. What I do for such cases is pre-parse the content periodically on the server and cache it in the database, so when the user accesses the page, instead of parsing every time, they see the cached version.\n</p></p><p><p>\nThe way the parser handles only single attributes (the &quot;n=&quot; in <code>&lt;g n=&quot;&quot;&gt;</code>) was by design. I wanted to make the tags as simple as possible for the user entering content. In almost all the cases where I used the parser, I never had to use more than a single attribute.  Also I never check for incorrect tags. This was because I was checking it at the client side at the point of data entry of the content.\n</p></p><p><p>\nUsing this technique certainly saved time and heartburn for me. Other than dealing with clients, I also had to deal with a copy writer who liked getting acquainted with Gilbey's dry gin more than with &quot;complicated&quot; HTML tags. But, he actually enjoyed entering these custom tags along with his copy, since for the first time he had complete control over where to position images in the copy.\n</p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
