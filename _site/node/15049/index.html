<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Search Engine Friendly Urls With Php And Apache</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Search Engine Friendly Urls With Php And Apache</h2>
<p class="meta">20 Aug 2001</p>

<div class="post">
<h2>Quick 'N' Dirty Intro</h2></p><p>    <p>Anyone who has built template based sites that use query strings to select content will have at some point hit the problem of indexing (or lack of it) by search engines. Search engine spiders won't index dynamic sites, as they are worried about getting stuck in a maze of twisty URLs, all alike.</p></p><p><p>One way round this is to mask the fact that we're using a query string.  Evolt itself uses this system (which you can see if you look at the current URL in your browsers location bar), albeit written in Cold Fusion. I'm going to show you a quick 'n' dirty way to do this in PHP. It's not the most feature complete way by any means, but it should at least provide you with a base to expand on. </p><p><h2>Question Marks Are So 20th Century</h2></p><p><p>We want to turn this</p></p><p><p><code>http://www.somesite.co.uk/site.php?section=books&amp;subsection=architecture</code></p>   \n \n<p>into this</p></p><p><p><code>http://www.somesite.co.uk/site/books/architecture</code></p></p><p><p>which involves masking the file extension for the processing file and then giving the query string a shave and a haircut.</p></p><p><h2>The Science Bit</h2>\n  \n<p>Like all good things in life (Star Wars, cocktails), this little system is based on three ingredients:</p></p><p><ol>\n	<li>Setting up Apache to process a file without an extension as a PHP file.</li>\n	<li>A function to process our URL and produce some variables.</li>\n	<li>Something that uses those variables to provide content.</li>\n</ol>\n    \n \n<p>First, setting up Apache. In your .htaccess file (if you don't have one, go ahead and create it) you want these lines:</p></p><p><pre>\n&lt;Files site&gt;\n	ForceType application/x-httpd-php\n&lt;/Files&gt;\n</pre></p><p><p>This tells Apache that if someone requests the file 'site' then it should be treated as a PHP file. Of course, you don't have to call it 'site'. If you were running a small online shop you might want to call it 'catalog'.</p></p><p><p>Next up, we need something that will take our new url and extract the information out of it. We do that with this function called </em>processURI()</em></p></p><p>\n<pre>\n// processURI(): \n// Takes the query string and extracts the vars by splitting on the '/'\n// Returns an array $url_array containing keys argN for each variable.\nfunction processURI() {\n global $REQUEST_URI;   // Define our global variables\n $array = explode(&quot;/&quot;,$REQUEST_URI);	// Explode the URI using '/'.\n $num = count($array);	// How many items in the array?\n $url_array = array();	// Init our new array	\n	\n for ($i = 1 ; $i &lt; $num ; $i++) {	         \n	$url_array[&quot;arg&quot;.$i] = $array[$i];  \n }\n// Insert each element from the\n// request URI into $url_array\n// with a key of argN. We start $i\n// at 1 because exploding the URI\n// gives us an empty ref in $array[0] \n// It's a hacky way of getting round it\n// *:)\n	\nreturn $url_array;  // return our new shiny array\n}\n</pre></p><p><p>This is a pretty simple function. First up it takes the $REQUEST_URI (everything after the server address basically) and then splits it into an array. After that it builds a new array ($url_array) containing arg1 to argN as keys, with their respective values.</p></p><p><p>The final piece in the puzzle is creating the file 'site' and doing something with all these variables that you've lovingly created. I've done just this up on <a href="http://members.evolt.org/garrett/site/books/factual" target="_new">http://members.evolt.org/garrett/site/books/factual</a></p></p><p><p>This is just a quick example of pulling in content based on the variables extracted from the query string. It's a list of books and CD's in my room. Not very interesting, but it was either that or a list of fruit and vegetables.</p></p><p><p>All the files can be downloaded from <a href="/files/search_urls_php.tar.gz">http://evolt.org/files/search_urls_php.tar.gz</a>. This contains a .htaccess file, 'site' which has the processURI() function plus a roughly cobbled together function displayContent() to show it in action. There is also a directory 'content' which holds the files for inclusion.</p></p><p><h2>That's A Wrap!</h2></p><p><p> It's a very handy trick, and you only have to use evolts <a href="http://lists.evolt.org" title="thelist archives - Opens new window" target="_new">archive search</a> to see how effective it can be (evolt uses Googles database to search its archives). As I said, this is a very quick approach and it could be improved in a number of ways but hopefully it's given you some ideas for your own site.</p></p><p><p><em>G.</em></p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
