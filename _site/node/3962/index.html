<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Bbs Style Recursion How To</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Bbs Style Recursion How To</h2>
<p class="meta">01 Dec 2000</p>

<div class="post">
<p>\n    A moderately common programming task is to write a script to \n    create an indented, hierarchical list. It's something that I've \n    had to do several times and each time I've forgotten the basic technique.\n    Having spent too many hours recently puzzling the technique out again, \n    I thought I would write an article about it to share the message and \n    to ensure that I have a copy of my code somewhere where I can't delete \n    it :-)\n</p>\n<p>\n    Because I've been programming in PHP a lot lately, the code is PHP and the database \n    is mySQL, but I'll try and explain the technique so that you can implement it in \n    your language of choice.\n</p>\n<p>\n    The first thing you need is some information in a database table. \n    I'm using a table called Categories with the following fields:\n</p>\n<table border="1" cellspacing="0">\n    <tr>\n        <td >Field</td>\n        <td >Type</td>\n        <td >Null</td>\n        <td >Key</td>\n        <td >Default</td>\n        <td >Extra</td>\n        <td >Comment</td>\n    </tr>\n    <tr>\n        <td >CatID</td>\n        <td >bigint(21)</td>\n        <td >&nbsp;</td>\n        <td >PRI</td>\n        <td >0</td>\n        <td >auto_increment</td>\n        <td >- individual key</td>\n    </tr>\n    <tr>\n        <td >CatName</td>\n        <td >varchar(32)</td>\n        <td >&nbsp;</td>\n        <td >&nbsp;</td>\n        <td >&nbsp;</td>\n        <td >&nbsp;</td>\n        <td >- Text field containing my category name</td>\n    </tr>\n    <tr>\n        <td >CatParent</td>\n        <td >bigint(21)</td>\n        <td >YES</td>\n        <td >&nbsp;</td>\n        <td >NULL</td>\n        <td >&nbsp;</td>\n        <td >- contains the CatID of the parent record, or NULL for the top level</td>\n    </tr>\n</table>\n<p>\n    Here's an extract of information from the table:\n</p>\n<table>\n    <tr>\n        <td >CatID</td>    <td >CatName</td>    <td >CatParent</td>\n    </tr>\n    <tr>\n        <td >1</td>    <td >Developer</td>    <td >NULL</td>\n    </tr>\n    <tr>\n        <td >7</td>    <td >Tools</td>    <td >1</td>\n    </tr>\n    <tr>\n        <td >8</td>    <td >Reference</td>    <td >1</td>\n    </tr>\n    <tr>\n        <td >9</td>    <td >Tutorials</td>    <td >8</td>\n    </tr>\n    <tr>\n        <td >10</td>    <td >Docs</td>    <td >8</td>\n    </tr>\n    <tr>\n        <td >11</td>    <td >Developers</td>    <td >1</td>\n    </tr>\n    <tr>\n        <td >12</td>    <td >Hardware</td>    <td >11</td>\n    </tr>\n    <tr>\n        <td >13</td>    <td >Software</td>    <td >11</td>\n    </tr>\n</table>\nWhich we want to end up looking like this:\n<dl>\n <dt>Developer\n  	<dd>Tools\n	<dd>Reference\n 	<dl>\n 		<dd>Tutorials\n 		<dd>Docs\n 	</dl>\n 	<dd>Developers\n	<dl>\n 		<dd>Hardware\n 		<dd>Software\n 		<dd>Services\n 	</dl>\n </dl>\n<p>\n    Many of the scripts I have seen around to do this use a set maximum number of levels. \n    One can then use either SQL JOINS or a set number of tables, or an extra field for \n    depth to make the scripting simpler. In my case I don't know how deep the recursion \n    can go, so I need to write something that will handle any level of depth. The magic \n    word here is &quot;recursion&quot;, which basically is a technique for writing short \n    pieces of code which keep running themselves in a controlled loop until the task at \n    hand is completed.\n</p>\n<p>\n    I'll explain the script as it goes along using PHP comments.\n</p>\n<code>\n<small>\n<pre>\n?php\n/*\n    BBS_style_recursion.php\n    Steve Cook december 2000\n    cookie@yoyo.org / sck@biljettpoolen.se\n    Feel free to make use of this code - I\n    would be interested in hearing of any improvements!</p><p>    The script starts by setting up some variables, and\n    creating the database connection.\n*/\n$link = mysql_connect\n    (&quot;localhost&quot;, &quot;username&quot;,\n     &quot;password&quot;)\n     or die\n    (&quot;Could not connect&quot;);\nmysql_select_db(&quot;wapwarp&quot;);\n/*\n    The SELECT statement orders the results\n    so that the categories are placed in\n    groups with the same parent.\n*/\n$result = mysql_query\n   (&quot;SELECT * FROM Categories\n    ORDER BY CatParent, CatID ASC;&quot;)\n    or die\n   (&quot;Invalid query&quot;);\n$i = 0;\n/*\n    The results are placed in a 2d array. In an\n    ASP script I would keep the results in a dynamic\n    resultset and navigate through that, but in PHP\n    we don't have the same result structure \n    and so we need to use an array.\n*/\nwhile ($result_row = mysql_fetch_row($result)) {\n    $result_array[$i] = $result_row;\n    $i++;\n}\n// Here we get some information from the script\n// that we use later to initialise our recursive\n// functions.\n//\n// These are our startup variables for our\n// recursive functions... you'll see!</p><p>$parentID = $result_array[0][0];\n$arr_size = count($result_array);\n$depth = 1;\n$startSeed = 1;\n// Just a tiddly little function to print \n// indentations in front of the results\nfunction depth($depth) {\n    for ($i=1; $i&lt;= $depth; ++$i) {\n        print &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;;\n    }\n}</p><p>?&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;BBS Style recursion&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;?php\n/*\n    Here's where the real meat of the program starts. \n    It's actually the second of two functions that format\n    our results. Because functions are defined before \n    they are called in PHP it comes first in the script.\n    You might want to read the description of find_child first!</p><p>    Okay, step-up is called by the find_child function \n    when it cannot find any more children in a\n    particular branch of categories.\n*/\nfunction step_up ($parentID, $startSeed, $depth) {\n    global $result_array;\n    global $arr_size;\n    // The first thing we'll check is that $start_seed \n    // hasn't gone off the end of our result_array.\n    // If it has, we'll stop execution of this function.\n    if ($startSeed &gt; $arr_size) {\n        return;\n    } else {\n        // if the CatParent of the last category is \n        // equal to the CatParent of the next category\n        // then they are on the same level. We'll move \n        // along to it and check to see if it has children\n        // This was why we chose to order our results by \n        // CatParent first in our SELECT statement.\n        if ($result_array[$startSeed-1][2] == \n           $result_array[$startSeed][2]) {\n              $depth--;\n              return find_child($result_array[$startSeed-1][2],\n                    $startSeed, $depth);\n            \n        // Otherwise, if the last CatParent was NULL and \n        // the current is 1, we stop processing\n        // as we have covered all the top level \n        // (again, we know this thanks to our SELECT \n        // statement ordering)\n        } else {\n            if ($result_array[$startSeed-1][2] == &quot;&quot; &amp;&amp; \n                $result_array[$startSeed][2] == 1) {\n                return;\n            }\n            // If they were unequal, and we haven't reached \n            // the end of the list, we need to \n            // climb back to this category's parent and \n            // restart this checking process. More recursion!\n            for ($j = 0; $j &lt;= $arr_size; ++$j) {\n                if ($result_array[$j][0] ==\n                  $result_array[$startSeed-1][2]) {\n                    $depth--;\n                    return\n                    step_up($result_array[$j+1][0], $j+1, $depth);\n                }\n            }\n            // I've forgotten what this return does, but it's\n            // probably something important!\n            // Best leave it there :-)\n            return;\n        }\n    \n}\n}</p><p>/*\n    The find_child function is the part of our recursive\n    process that steps down the category list.\n    It is fed the CatID of the last category we got \n    from our results. This is the potential &quot;parent&quot;\n    of other categories, so I have called it $parentID. It is \n    also fed a $startSeed, which is the position of the current\n    result we are looking at in $result_array. There's also a \n    $depth variable which is used for formatting purposes.\n*/\nfunction find_child ($parentID, $startSeed, $depth) {\n    global $result_array;\n    global $arr_size;\n    // This for loop starts us where we left off in \n    // $result_array and steps through the results.\n    for ($k = $startSeed; $k &lt;= $arr_size; ++$k) {\n        // If we find a result where the catParent is \n        // equal to the CatID of our current result\n        // then we've found a child.\n        if ($result_array[$k][2] == $parentID) {\n            // We can then do whatever we need to do\n            // with our category.\n            // In this case we'll print it out with some\n            // depth formatting.\n            depth($depth);    \n            print ($result_array[$k][1] . &quot;&lt;br&gt;\n&quot;);\n            // then we need to reset our startup variables - our \n            // current result could now be a parent itself.\n            $parentID = $result_array[$k][0];\n            $startSeed = ++$k;\n            $depth++;\n            // Finally we recall find_child with our new values\n            // to see if this category contains sub-categories.\n            // This is recursion at work!\n            return find_child($parentID, $startSeed, $depth);\n            \n        } elseif ($result_array[$k][2] &gt; $parentID) {\n            // Simply a little code to save some processing time.\n            // We'll break out of the loop if we've gone\n            // past the parent value\n            break;    \n        }\n    }\n    /*\n    If we didn't find a child, then we've gone as far down \n    this particular branch of categories as we can.\n    We need to keep our startup variables the same and \n    use our second function - step_up to either find\n    further results on the same level, or to take us \n    back up the category tree.\n    */\n    \n    step_up ($parentID, $startSeed, $depth);\n}\n/*\n    Okay, we've defined all our recursive functions, all \n    we need to do now is print the first category\n    which we got from the results right at the beginning \n    and then kick the whole operation into action.\n    With any luck, it should run all the way through \n    the results, finding it's way down the lists of categories\n    and climbing back up again to start down new branches \n    until it reaches the end of the results list.\n*/\nprint $result_array[0][1] . &quot;&lt;br&gt;\n&quot;;\nfind_child($parentID, $startSeed, $depth);</p><p>?&gt;</p><p>&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</small>\n</code>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
