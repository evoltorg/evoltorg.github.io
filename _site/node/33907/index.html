<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Image Manipulation With Cfmx And Jai</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Image Manipulation With Cfmx And Jai</h2>
<p class="meta">23 Jul 2002</p>

<div class="post">
<p>One of the most requested extensions to ColdFusion is the ability to do image \nmanipulation. Whether the request is as simple as just getting the rendered \nheight and width of an image or as complex as creating a thumbnail in a different \nformat, the Java Advanced Imaging API (JAI) may well hold the answer. In this \narticle I will explain how to make use of JAI from CFMX to do the following \nfour operations, thumbnail generation, format conversion, cropping, and border \ncreation. Additionally, I will show how to obtain image properties such as \nthe height and width of the rendered image.</p></p><p><p>Before getting started using JAI, it is worth learning a little bit about \nJAI. JAI is a set of interfaces that provide image manipulation for Java. \nJAI is an optional package that does not ship with Java 1.3. Since JAI is \njust a set of interfaces, an implementation of those interfaces is also required \nin order to make use of it. Sun provides a free implementation of the JAI \ninterfaces along with the <a href="http://java.sun.com/products/java-media/jai/" target="_blank">JAI package that you can download here</a>. \nSun does implement all of the interfaces, but may not provide all the functionality \nyou are looking for. For example, the Sun interface can read BMP, JPG, GIF, \nTIF, and PNG image formats, while it can write DMP, JPG, TIF, PNG. If you \nneed the ability to write GIF files than you will have to find another implementation \n(PNG is the generally accepted substitute for GIF).</p></p><p><p>To easily make use of JAI I am going to create a Java class that accesses the JAI APIs and then a CFC that wraps my Java class. The first step is to create a shell class with the correct imports. I am also going to declare some private variables Iï¿½ll make use of later in the methods. The shell class is as follows.</p></p><p><pre>\nimport java.io.*;\nimport java.util.*;\nimport java.awt.image.renderable.*;\nimport javax.media.jai.*;\nimport com.sun.media.jai.codec.*;</p><p>public class ImageUtils\n{\n	private RenderedOp image = null;\n	private RenderedOp result = null;\n	private int height = 0;\n	private int width = 0;\n}\n</pre></p><p><p>After creating the shell class I am ready for my first method. Since all my image manipulation methods will depend on having an image loaded into memory, I will create a load method. Below is my method for loading the image into memory.</p></p><p><pre>\npublic void load(String file) throws IOException\n{\n  FileSeekableStream fss = new FileSeekableStream(file);\n  image = JAI.create(&quot;stream&quot;, fss);\n  height = image.getHeight();\n  width = image.getWidth();\n}\n</pre></p><p><p>As you can see my method take a single parameter indicating the file it should \nload into memory. This parameter needs to be the complete path to the file. \nFirst, I create a new <code>FileSeekableStream</code> instance \nusing the passed in path as a parameter. I then need to create an image stream. \nFor convenience I will be using the provided static JAI factory. The static \n<code>JAI.create</code> method&#8217;s first parameter is the type \nof object I want to create, while all the other parameters depend on what \nobject I want to create. In this case I want to create a stream, so I pass \nit the <code>FileSeekableStream</code> instance I just created. \nThe <code>JAI.create method</code> returns a <code>RenderedOp</code> \nobject. Now that I have my image in memory I am going to go ahead and get \nits height and width using the respective <code>getHeight()</code> and <code>getWidth()</code> methods of RenderedOp.</p></p><p><p>No matter what type of image manipulation I want to do, I will always need \nto write to disk the resulting image. In order to write an image to disk I \nwill need to know what type of encoding to use as well as the name of the \nfile to create. Below is the method I created for writing an image to disk.</p></p><p><pre>\npublic void writeResult(String file, String type) throws IOException\n{\n  FileOutputStream os = new FileOutputStream(file);\n  JAI.create(&quot;encode&quot;, result, os, type, null);\n}\n</pre></p><p><p>With only two lines of code, the <code>writeResult</code> method \nis quite simple. Using the static <code>JAI.create</code> method \nI encode my image by passing it a <code>RenderedOp</code> (the \nimage), the <code>FileOutputStream</code> I just created, and \nthe type of encoding to use. It then calls the encode method on my behalf, \nwhich write the image to disk in the appropriate format. Almost all of the \npopular image encodings are support except for GIF. Check the JAI documentation \nfor a list of what encodings are supported. For the most part PNG is an acceptable \nsubstitute for GIF.</p></p><p><p>Now that I have finished my <code>writeResult</code> method \nI have actually gotten image format conversion for free. This is because I \ncan load an image in any acceptable format and then write it as any of the \nsupported encodings. For example, I could load a BMP image and then write \nit as a JPG thus converting the image from a bitmap to a jpeg.</p></p><p><p>From here I can create new methods for each additional type of image manipulation \noperation I want to support. As stated earlier, I also want to be able to \ngenerate thumbnails, crop images, and create borders. When creating thumbnails \nit is often easy to distort the image by not scaling each dimension according \nthe image&#8217;s aspect ratio. For my thumbnail method I am going to accept a single \nnumber that represents what the longest edge of the resulting image should \nbe. I will then scale the image according to its aspect ratio to the desired \nedge length. The following code is my thumbnail method.</p></p><p><pre>\npublic void thumbnail(float edgeLength)\n{\n  boolean tall = (height &gt; width);\n  float modifier = edgeLength / (float) (tall ? height : width);\n  ParameterBlock params = new ParameterBlock();\n  params.addSource(image);\n  params.add(modifier);//x scale factor\n  params.add(modifier);//y scale factor\n  params.add(0.0F);//x translate\n  params.add(0.0F);//y translate\n  params.add(new InterpolationNearest());//interpolation method\n  result = JAI.create(&quot;scale&quot;, params);\n}\n</pre></p><p><p>My first step is to determine if the image is tall or wide. I do this simply \nby seeing if the height is greater than the width. From there I create a modifier \nvalue based on the desired edge length divided by the longest edge. Now that \nI have my modifier value, I need to create a <code>ParameterBlock</code> to pass to the scale method. My first parameter \nis the image source. From there I add parameters for the x and y scale factor. \nNotice how I use the same x and y scale factor. This keeps the image from \nbeing distorted. The rest of the parameters aren&#8217;t so important for generating \nthumbnails and are more useful for scaling operations. If you are interested \nin different types of scaling operations the JAI documentation will describe \nhow these additional parameters can be useful for you. After creating the \n<code>ParameterBlock</code> I pass it to the static <code>JAI.create</code> method, which calls scale and returns my result.</p>\n<p>For image cropping I decided to have my method crop the same amount for both \nthe height and width of the image. Thus, my method only takes a single parameter, \nhow much edge to crop. The code for the method is below.</p></p><p><pre>\npublic void crop(float edge)\n{\n  ParameterBlock params = new ParameterBlock();\n  params.addSource(image);\n  params.add(edge);//x origin\n  params.add(edge);//y origin\n  params.add((float) width - edge);//width\n  params.add((float) height - edge);//height\n  result = JAI.create(&quot;crop&quot;, params);\n}\n</pre></p><p><p>Again, I need to create a <code>ParameterBlock</code>. My first \nparameter is the image source. From there I need to add the x and y origins. \nThe origin is where the cropping should start. Next, I add the width and height \nof crop. I determine the width and height by subtracting the origin from its \nrespective edge. Since I am cropping the same amount for both the height and \nthe width, I use the same value for x and y and thus for subtracting from \nthe width and height. Finally, I pass the <code>ParameterBlock</code> \nto the static <code>JAI.create</code> method, which calls crop \nand returns my result.</p></p><p><p>Much like the crop method, I decide to have my border method use the same \nsize border for each side of the image. Besides the width of the border, my \nmethod will also allow a color for the border to be specified. Thus, my method \ntakes two parameters; the code is as follows.</p></p><p><pre>\npublic void border(int edge, double edgeColor)\n{\n  ParameterBlock params = new ParameterBlock();\n  params.addSource(image);\n  params.add(edge);//left pad\n  params.add(edge);//right pad\n  params.add(edge);//top pad\n  params.add(edge);//bottom pad\n  double fill[] = {edgeColor};\n  params.add(new BorderExtenderConstant(fill));//type\n  params.add(edgeColor);//fill color\n  result = JAI.create(&quot;border&quot;, params);\n}\n</pre></p><p><p>Again, I create a <code>ParameterBlock</code> and set the image \nsource. From there I add a parameter for each side&#8217;s border width. Since I \nam using the same border width for all sides, this value is the same. Next \nI need to add the border color, which is done with two parameters, a <code>BorderExtenderConstant</code> \nand the color. There are more options for border file than using a single \nconstant color, but that is out of the scope of this article. Again, the JAI \ndocumentation will provide the details of what additional border operations \nare possible and how to make use of them. Having created my <code>ParameterBlock</code>, \nI pass it to the static <code>JAI.create</code> method, which \ncalls border and returns my result.</p></p><p><p>With my Java class complete I can compile it. Make sure you include the JAI \njars in your <code>CLASSPATH</code> before attempting to compile it. Once my Java class \nis compiled I simply place in ColdFusion&#8217;s <code>CLASSPATH</code>, \nso that I can make use of it from my CFC.</p></p><p><p>To get started on my CFC, I am going to declare three variables in my component \nbody, iu, loaded, and result. \nThe code for the three declarations is below.</p></p><p><pre>\n&lt;cfobject type=&quot;java&quot; name=&quot;iu&quot; class=&quot;ImageUtils&quot; action=&quot;create&quot;&gt;\n&lt;cfset loaded = false&gt;\n&lt;cfset result = false&gt;\n</pre></p><p><p>As you can see, I named my Java class <code>&#8220;ImageUtils&#8221;</code> \nand I am using the <code>&lt;cfobject&gt;</code> tag to create \nan instance of it. Since all of my CFC&#8217;s methods will be making use of the \nImageUtils class I created the instance in my component body \ninstead of in an individual method. My two other variables, loaded and result, \nare simply booleans representing the state of my \nCFC.</p></p><p><p>Since all my CFC does is wrap my Java class, all the methods are very straight \nforward. Each one is included below and briefly explained.</p></p><p><pre>\n&lt;cffunction name=&quot;load&quot; access=&quot;public&quot;&gt;\n  &lt;cfargument name=&quot;filename&quot; type=&quot;string&quot; required=&quot;true&quot;&gt;\n  &lt;cfscript&gt;\n    iu.load(arguments.filename);\n    loaded = true;\n  &lt;/cfscript&gt;\n&lt;/cffunction&gt;\n</pre></p><p><p>The above load method simple passes the file to load directly to <code>ImageUtils</code> \nand then sets the boolean loaded to true indicating \nthat an image has been loaded.</p></p><p><pre>\n&lt;cffunction name=&quot;writeResult&quot; access=&quot;public&quot;&gt;\n  &lt;cfargument name=&quot;filename&quot; type=&quot;string&quot; required=&quot;true&quot;&gt;\n  &lt;cfargument name=&quot;type&quot; type=&quot;string&quot; required=&quot;true&quot;&gt;\n  &lt;cfif result&gt;\n    &lt;cfscript&gt;\n      if(result)\n        iu.writeResult(arguments.filename, arguments.type);\n    &lt;/cfscript&gt;\n  &lt;/cfif&gt;\n&lt;/cffunction&gt;\n</pre></p><p><p>The above <code>writeResult</code> method checks to see if a \nresult has been created before calling the <code>ImageUtils writeResult</code> method.</p></p><p><pre>\n&lt;cffunction name=&quot;thumbnail&quot; access=&quot;public&quot;&gt;\n  &lt;cfargument name=&quot;edgeLength&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;\n  &lt;cfif loaded&gt;\n    &lt;cfscript&gt;\n      iu.thumbnail(arguments.edgeLength);\n      result = true;\n    &lt;/cfscript&gt;\n  &lt;/cfif&gt;\n&lt;/cffunction&gt;\n</pre></p><p><p>The above thumbnail method checks to see if an image has been loaded. Then \nit calls the <code>ImageUtils</code> thumbnail method and sets \nthe boolean result to true \nindicating that a result has been created.</p></p><p><pre>\n&lt;cffunction name=&quot;crop&quot; access=&quot;public&quot;&gt;\n  &lt;cfargument name=&quot;edge&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;\n  &lt;cfif loaded&gt;\n    &lt;cfscript&gt;\n      iu.crop(arguments.edge);\n      result = true;\n    &lt;/cfscript&gt;\n  &lt;/cfif&gt;\n&lt;/cffunction&gt;\n</pre></p><p><p>Just like the thumbnail method, the above crop method checks to see if an \nimage has been loaded. Then it calls the <code>ImageUtils</code> \ncrop method and sets the boolean \nresult to true indicating that a result has been created.</p></p><p><pre>\n&lt;cffunction name=&quot;border&quot; access=&quot;public&quot;&gt;\n  &lt;cfargument name=&quot;edge&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;\n  &lt;cfargument name=&quot;edgeColor&quot; type=&quot;numeric&quot; required=&quot;true&quot;&gt;\n  &lt;cfif loaded&gt;\n    &lt;cfscript&gt;\n      iu.border(arguments.edgeLength, arguments.edgeColor);\n      result = true;\n    &lt;/cfscript&gt;\n  &lt;/cfif&gt;\n&lt;/cffunction&gt;\n</pre></p><p><p>Finally, the above border method checks to see if an image has been loaded. \nThen it calls the <code>ImageUtils</code> border method and sets \nthe boolean result to true \nindicating that a result has been created.</p></p><p><p>After creating my Java class and associated wrapper CFC, I am now able to \nperform image manipulation from ColdFusion with ease. Further, both the Java \nclass and the CFC are easily extendible to support additional operations that \nare implemented with JAI. While creating a wrapper CFC may seem like additional \nwork for nothing, further additions to the Java class could prove challenging \nfor ColdFusion to make use of. Since Java is a typed language and ColdFusion \nis typeless, it is often useful to have a wrapper \nclass that can act as an adapter.</p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
