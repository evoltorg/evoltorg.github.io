<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Using Pear S Mimedecode Module</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Using Pear S Mimedecode Module</h2>
<p class="meta">28 Mar 2003</p>

<div class="post">
<p>\nWhile most MIME email is totally useless, it would be better if it was sent as a plain text message, MIME sometimes is useful. When sending attachments, for example. In this article, we will see how we can decode MIME messages with PHP.\n</p>\n<p>\nWe will use the mimeDecode module to do the actual decoding for us. mimeDecode is part of the <a href="http://pear.php.net" target="_new" title="The PEAR website (Opens in a new window)">PEAR</a> library. PEAR is already installed if you have a newer version of PHP, but if you don't it's also easy to install.\n</p></p><p><h2>How to get PEAR and mimeDecode</h2>\n<p>\nBefore trying to install PEAR and the mimeDecode module, you should first make sure that you don't yet have it. If you have a recent version of PHP (&gt; 4.3.0pre1), the PEAR base installation is already installed on your system. Since the mimeDecode module is part of the PEAR core, that's also installed. To check whether you have to install the mimeDecode or not, you can run the following PHP script:\n</p>\n<pre>\n&lt;?php\ninclude('Mail/mimeDecode.php');\n?&gt;\n</pre>\n<p>\nIf this doesn't give an error, you the mimeDecode module is installed on your system. If it does, you'll have to install PEAR (or upgrade your version of PHP). Read the <a href="http://pear.php.net/manual/en/installation.php" target="_new" title="Installing PEAR (Opens in a new window)">PEAR manual</a> for instructions.\n</p></p><p><h2>MIME: an introduction</h2>\n<p>\nBefore you can successfully write a script that decodes MIME email, you'll have to know a little about the anatomy of a MIME message. I'll give you a short introduction to MIME. If you want to read more about the details of MIME, there is a <a href="http://www.oreilly.com/openbook/mh/tocs/intmime.htm" target="_new" title="Chapter 3: Introduction to MIME (Opens in a new window)">chapter</a> available from O'Reilly.\n</p></p><p><h3>A tradition email</h3>\n<p>\nThe source of a basic, non-MIME email looks like this:\n</p>\n<pre>\nFrom: Gijs van Tulder &lt;gvtulder@example.com&gt;\nTo: thelist@lists.evolt.org\nSubject: Decoding MIME mail\nDate: Wed, 12 Mar 2003 10:26:59 +0100</p><p>Hi, this is my message.\n</pre>\n<p>\nThe first lines of this email contain headers, data about this message. These headers consist of a header name, before the colon, and some data, after the colon. (If you are familiar with the HTTP headers, you'll notice that email headers use the same syntax.) There are actually many more possible headers that I didn't include in this example, but all headers are in the form <code>Name: Data</code>. You can see the headers of your email in your email program. (In Microsoft Outlook 2000, for example, right-click on the message and select 'Options'.)\n</p>\n<p>\nThe body of the message, in our example <code>Hi, this is my message.</code> starts after the blank line that follows the headers.\n</p></p><p><h3>A MIME email</h3>\n<p>\nWe'll now see what happens with our message when we add a MIME attachment to it.\n</p>\n<pre>\nFrom: Gijs van Tulder &lt;gvtulder@example.com&gt;\nTo: thelist@lists.evolt.org\nSubject: Decoding MIME mail\nDate: Wed, 12 Mar 2003 10:26:59 +0100\nMIME-Version: 1.0\nContent-Type: multipart/mixed; boundary="MyBoundary"</p><p>This is a multi-part message in MIME format.</p><p>--MyBoundary\nContent-Type: text/plain; charset="iso-8859-1"\nContent-Transfer-Encoding: 7bit</p><p>Hi, this is my message. See the attached image!</p><p>--MyBoundary\nContent-Type: image/gif; name="myimage.gif"\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename="myimage.gif"</p><p>R0lGODlhogBrAPcAAAAAAP///zwKC2UhIrdPUKU0OMmLjagEDJIEDZEmLduztW8HD64YJlUJEXkX\n...omitted many lines like the above...\ngahQUgx4n5kQWQQJ0sqEREAAADs=</p><p>--MyBoundary--\n</pre>\n<p>\nAs you can see, our message now contains two different parts: the message body, <code>Hi...image!</code>, and an encoded form of the image, <code>R01GO...AADs=</code>. We'll take a closer look at these parts in a moment. How does your mail program know where the different parts begin and end? Look at the headers, and you'll see the answer: there is a new header called <code>Content-Type</code>, with a boundary variable. In this example, I've set the boundary to <code>MyBoundary</code>. The MIME parts are separated by a line with two dashes and that boundary string: <code>--MyBoundary</code>. At the end of the message, the boundary is followed by two dashes to indicate the end.\n</p>\n<p>\nNote that this boundary can be set to any possible string. It's fairly obvious that normal mail programs don't use 'MyBoundary' as the boundary string, but take a longer random string. It still has the same effect, though.\n</p></p><p><h3>The MIME parts</h3>\n<p>\nNow, let's take a look at the MIME parts. You'll notice that these parts look a lot like the email message: it starts with a number of headers, followed by an empty line and then there is the body.\n</p>\n<pre>\nContent-Type: image/gif; name="myimage.gif"\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename="myimage.gif"</p><p>R0lGODlhogBrAPcAAAAAAP///zwKC2UhIrdPUKU0OMmLjagEDJIEDZEmLduztW8HD64YJlUJEXkX\n...omitted many lines like the above...\ngahQUgx4n5kQWQQJ0sqEREAAADs=\n</pre>\n<p>\nThis is the MIME part containing the attached image. You see the <code>Content-Type</code> header, that tells us more about the type of this part. In our example, this part is a gif image. The original filename is also included in the headers.\n</p>\n<p>\nThe body of this part looks very strange. Many similar lines followed the first line of characters, but I deleted them except from the last line. What you see here is an encoded version of the original file. Since an email message can only contain normal text, the binary form of the image had to be translated to a text form. This is called MIME encoding. The <code>Content-Transfer-Encoding</code> tells us what type of encoding was used. The PEAR mimeDecode module, and every other MIME compatible email reader, will use this information to decode the file.\n</p></p><p><h2>Decoding the message</h2>\n<p>\nNow that we know a little about MIME email, we can almost start writing the script. But wait, you'll first have to get a message that your script can parse. If you're using Linux/Unix, you can send yourself a MIME email and copy your mbox file to get the source of that message. You can also set up a <a href="http://www.evolt.org/article/Incoming_Mail_and_PHP/18/27914/index.html" tite="Incoming Mail and PHP on evolt.org">email to PHP script</a> to get the message source. If you just want to test the mimeDecode module, you can also just download the source of <a href="http://gvtulder.f2o.org/evolt/mail/mime_test.txt" target="_new" title="A message with attachment (Opens in a new window)">my example message</a>. In this example script, I will assume that the source email is saved as <code>$input</code>.\n</p></p><p><h3>Initialising mimeDecode</h3>\n<p>\nTo load the mimeDecode module, we just have to include <code>mail/mimeDecode</code>. The PEAR path is specified in PHP's include_path, so we don't have to worry about the absolute location of this file.\n</p>\n<pre>\ninclude('mail/mimeDecode');\n</pre></p><p><h3>Setting the parameters</h3>\n<p>\nThe mimeDecode module accepts five parameters. <code>include_bodies</code> determines whether we want the bodies of the MIME parts to be returned. If <code>decode_bodies</code> is set to true, the encoded MIME parts (files etc.) are decoded. If <code>decode_headers</code> is true, mimeDecode decodes the message headers. Since we want the whole message to be decoded, we'll set these three boolean parameters to true.\n</p>\n<p>\nThe fourth parameter, <code>crlf</code>, tells mimeDecode the line ending type. The default is \r\n (carrier return, line feed), which works in most cases. We won't specify this. The last parameter is called <code>input</code> and is used to send the input message to mimeDecode.\n</p>\n<pre>\n$params['include_bodies'] = true;\n$params['decode_bodies'] = true;\n$params['decode_headers'] = true;\n$params['input'] = $input;\n</pre></p><p><h3>Running decode()</h3>\n<p>\nIt's time to run mimeDecode's <code>decode()</code> function, the function that decodes the MIME message and returns a nice structure. The easiest way to run <code>decode()</code> is without creating a new object. That does mean that we have to tell PHP in which class <code>decode()</code> is to be found.\n</p>\n<pre>\n$structure = Mail_mimeDecode::decode($params);\n</pre>\n<p>\nThe decoded message is saved in <code>$structure</code>.\n</p></p><p><h2>The mimeDecode output</h2>\n<p>\nWe've now got the decoded message in the <code>$structure</code> variable. If you run <code>print_r($structure);</code>, you'll get a nice view of the anatomy of that structure.\n</p>\n<ul>\n <li><strong><code>$structure-&gt;headers</code></strong>: An array containing the headers of the message. <code>$structure-&gt;headers['subject']</code> contains the <code>Subject:</code> header and so on. Note that multiple headers with the same name are saved in an array, like: <code>$structure-&gt;headers['received'][0]</code>.</li>\n <li><strong><code>$structure-&gt;ctype_primary</code></strong>: The first part of the message's content type. If the content type is <code>multipart/mixed</code>, this is set to <code>multipart</code>.</li>\n <li><strong><code>$structure-&gt;ctype_secondary</code></strong>: The second part of the message's content type. (<code>multipart/mixed</code> gives a value of <code>mixed</code>.</li>\n <li><strong><code>$structure-&gt;ctype_parameter</code></strong>: An array of the parameters of the content type. In case of a MIME message this includes the <code>boundary=</code> value.</li>\n <li><strong><code>$structure-&gt;content_disposition</code></strong>: Contains the value of the <code>Content-Disposition:</code> header, if set. In case of an attachment, this is set to <code>attachment</code>.</li>\n <li><strong><code>$structure-&gt;d_parameters</code></strong>: As with the <code>Content-Type:</code> header, any parameters of the <code>Content-Disposition:</code> header are returned in this array. Attachments, for instance, bring a <code>filename</code> parameter.</li>\n <li><strong><code>$structure-&gt;body</code></strong>: The body of the message or the MIME part. In general, the main message of a MIME email doesn't have a body value.</li>\n <li><strong><code>$structure-&gt;parts</code></strong>: This is an array of all MIME parts found in the message. Each of these parts has the same properties as the <code>$structure</code> variable described here. Eg. the headers of <code>$structures-&gt;parts[0]</code> can be found in <code>$structures-&gt;parts[0]-&gt;headers</code> etc.</li>\n</ul></p><p><h3>Saving all attached files</h3>\n<p>\nWe can now walk through the <code>$structure-&gt;parts</code> array and save each attachment we find.\n</p>\n<pre>\nforeach ($structure-&gt;parts as $part) {\n    // only save if an attachment\n    if (isset($part-&gt;disposition) and\n        ($part-&gt;disposition=='attachment') {\n        // open file\n        $fp = fopen($part-&gt;ctype_parameters['filename'], 'w');\n        // write body\n        fwrite($fp, $part-&gt;body);\n        // close file\n        fclose($fp);\n    }\n}\n</pre>\n<p>\nFor each part, we check if it has a <code>Content-Disposition:</code> header set to 'attachment'. We open a file with the name given by the <code>filename</code> parameter of the <code>Content-Type:</code> header. We then save the (decoded) body of this part in that file.\n</p></p><p><h3>Listing all images</h3>\n<p>\nIn the same way, we can list all images and their sizes by checking the <code>ctype_primary</code> and <code>body</code> values. We can then send this list to the sender of the original email.\n</p>\n<pre>\n$list = '';\nforeach ($structure-&gt;parts as $part) {\n    // is this an image?\n    if ($part-&gt;ctype_primary=='image') {\n        $list .= $part-&gt;ctype_parameters['filename'].': '.\n                 strlen($part-&gt;body)." bytes\n";\n    }\n}\n// send this list\n$to = $structure-&gt;headers['from'];\n$subject = 'Re: '.$structure-&gt;headers['subject'];\n$body = "You sent us these images:</p><p>$list</p><p>Thank you very much!";\n$headers = 'From: '.$structure-&gt;headers['to'];\nmail($to, $subject, $body, $headers);\n</pre>\n<p>\nIf the <code>ctype_primary</code> is 'image' (from image/gif, image/jpeg etc.), we add the filename and the length of the <code>body</code> string to the list. After we viewed all images, we send the list to the sender of the original email. We use the information of the original email, the <code>From:</code>, <code>Subject:</code> and <code>To:</code> headers, to make a nice reply.\n</p></p><p><h2>What's next?</h2>\n<p>\nBy now, you should be able to write your own scripts using the mimeDecode module. You could, for example, write a script that lets you just email images and get them published on your web log. In the rare event that you are a teacher, you could save all documents that your students send you in your 'incoming files' directory, without having to open each message first.\n</p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
