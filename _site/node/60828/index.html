<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Practical Tips On Reducing Load On Mysql</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Practical Tips On Reducing Load On Mysql</h2>
<p class="meta">28 Aug 2007</p>

<div class="post">
Alot of PHP/MySQL programmers out there , specially the ones just starting out make some mistakes while using queries and database designs. The ideas i am going to outline here, aren’t just limited to MySQL , they can be equally applied elsewhere as well. We need to keep in mind the fact that MySQL will use more <strong>RAM </strong>and <strong>CPU </strong>than it should if inefficient queries are written and database structure is designed incorrectly.\n<ul>\n	<li> For instance one common      mistake is to use "<strong>SELECT * from table1</strong>" , unless you don’t      need to use all of the fields i strongly suggest against it. Use something      like "<strong>SELECT field1,field2 from table1</strong>"</li>\n	<li>Make sure you know what you      are doing when using <strong>JOINs</strong>. Use "<strong>explain</strong>" to see      how many rows are actually being scanned for the query to execute and      bring the result. A lot of times its better to break the query up into      several queries. <strong>JOINS ARE HEAVY</strong>!</li>\n	<li>I have seen people use order      by clause in queries where they need to get just the count of the records.      That’s totally unintelligent. Order by clause uses up RAM as well to sort      the data. Avoid it where it can be avoided.</li>\n	<li>Saving <strong>images</strong> in DB is      probably not a really good idea after all. Atleast I think so. If you can      , doesn’t mean you should.</li>\n	<li><strong>Integer primary keys</strong>      are faster than making username the primary key or something similar.</li>\n	<li><strong>Fixed length fields</strong>      are processed faster than variable length fields.</li>\n	<li><strong>Use indexing wisely</strong>.      Indexing helps in query the database faster BUT insertion and updates are      slower.</li>\n	<li><strong>Sometimes it better not to      create text book database structure aka normalization</strong> , sometimes a      little redundancy can help minimize number of queries AND/OR load on      database, specially when dealing with large databases.</li>\n	<li>Keep in mind that in the loop      <strong>while($array=mysql_fetch_array($queryresult)) , </strong>the transaction      will keep the query open until the end of the loop. So if there is some      heavy processing happening inside the loop on the result data, it is      probably a good idea to <strong>first run the query loop and store the data you      want to process in arrays</strong> and then later on process on the array. I      find this technique helpful on many occasions.</li>\n	<li>Using <strong>mysql_pconnect</strong> doesnt always help .</li>\n	<li>Using <strong>mysql_free_result</strong> is probably a good idea.</li>\n	<li><strong>mysql_insert_id</strong> is a useful function to get newest primary key of the record , rather than using "....order by id desc limit 1"</li>\n	<li>If you know you will be using some mysql field data alot , like the username of the logged in user , its always a good idea to store it in session , rather than banging on mysqls door again and again for it.</li>\n	<li><strong>ENUM</strong> field type is very useful , just like fixed length fields. Data processing on <strong>ENUM</strong> fields is quite fast.</li>\n	<li>Using <strong>count(*)</strong> in queries instead of mysql_num_rows is faster i believe.</li>\n	<li>I believe if you are storing signup dates etc , its probably a good idea to have the field as integer instead of <strong>datetime </strong>and put in mktime() value. This only applies to current and future dates. In cases where past dates are possible datetime should be used. As you never know if that date can be earlier than 1970. Storing mktime gives you faster processing and manipulation of data is easier as well in PHP with the date() function.</li>\n	<li>Dont use <strong>fulltext </strong>unless you really have to.</li>\n	<li>And finally <strong>DO USE PRIMARY</strong> <strong>KEYS </strong>,  dont be affraid to use them , they can help you down the road. For instance "DELETE  from table1 WHERE id = 1" and "DELETE from table1 where firstname='php' and lastname='rox'" , the first query i reckon will run faster.</li>\n</ul>\nThose are all i can think of right now. Please remember i am not an expert on MySQL ,  the above are based on professional experience with PHP and MySQL. Another thing to remember here is , all of these points might seem insignificantly small but when piled up together. They can cause major havoc. Specially when large databases are question.</p><p>Hope the tips can really help someone.
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
