<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Php Frontend To Imagemagick</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Php Frontend To Imagemagick</h2>
<p class="meta">27 Feb 2003</p>

<div class="post">
<h2>What is ImageMagick?</h2>\n<p>\n<a href="http://www.imagemagick.com/" target="_new"\ntitle="Download ImageMagick (Link opens in a new window)">ImageMagick</a> is\na powerful set of image manipulation utilities. It can read, write and\nmanipulate images in many image formats. It can resize, rotate, sharpen,\ncolor reduce or add any other special effect to your images. And, best of all,\nImageMagick is directly available from the command line. In this article, we will\nwrite a script to make it available from the query string. You can then use\nit, for example, to automatically generate thumbnails of your images.\n</p></p><p><h2>What our script will do</h2>\n<p>\nWe will write a script that we can copy-paste in a directory with images and\nthat enables us to use ImageMagick's <a\nhref="http://www.imagemagick.com/www/convert.html" target="_new"\ntitle="Read more about convert (Link opens in a new window)">convert</a>\nutility on each of the images in that directory. The script will enable us to\ngive <code>convert</code> commands by changing the query string.\n</p>\n<p>\nMaybe a simple example will better explain this idea. You've got an image:\n<code>http://wwww.example.com/img/image.jpg</code>. You copy the\nImageMagick script <code>magick.php</code> to the same directory. The image is\nnow also available as\n<code>http://www.example.com/img/magick.php/image.jpg</code>. So far,\nyour image hasn't changed. Now, imagine you want a thumbnail of the image\nwith a width of exactly 200 pixels. You can get that image by requesting the\nurl:\n<code>http://www.example.com/img/magick.php/image.jpg?resize(200)</code>. \n</p>\n<p>\nOn receiving a request, the script will:\n</p>\n<ol>\n <li>Parse the query string;</li>\n <li>Convert the query string to an ImageMagick command string;</li>\n <li>Run ImageMagick on the image;</li>\n <li>Send the modified image to the browser.</li>\n</ol>\n<p>\nAs you see, the script will run ImageMagick for every request. This isn't\nvery efficient. As you will probably use just a few commands (e.g.\nthumbnail and original image) in your html files, caching the output will\nspeed up the system. We will add a point 5 to the list. The output of\nImageMagick should be cached. The script should send the cached image if it\nexists, so ImageMagick won't be generating the same image over and over\nagain. \n</p></p><p>\n<h2>Commands</h2>\n<p>\nYou can use the <a\nhref="http://www.imagemagick.com/www/ImageMagick.html#opti" target="_new"\ntitle="A list of all ImageMagick commands (Link opens in a new window">\nstandard commands/options</a> of ImageMagick's convert utility. The\ncommand is followed by the command's parameters. These parameters are\nenclosed in brackets. Multiple commands are separated by a plus sign.  \n</p>\n<p>\nImageMagick uses &lt; and &gt; in some parameters. You can't use these in\nhtml-documents. Instead of &lt; and &gt;, you may use { and } in your query\nstring. The scripts then converts { to &lt; and } to &gt;. \n</p>\n<p>\nHere are a few example convert commands and their query equivalent.\n</p>\n<table cellspacing="0" class="data">\n <tr>\n  <th>Command line</th>\n  <th>Query string</th>\n </tr>\n <tr>\n  <td><code>-resize &quot;100x150&quot;</code></td>\n  <td><code>?resize(100x150)</code></td>\n </tr>\n <tr>\n  <td><code>-resize &quot;800x600&gt;&quot; -roll &quot;90&quot;</code></td> \n  <td><code>?resize(800x600})+roll(90)</code></td>\n </tr>\n <tr>\n  <td><code>-flip -resize &quot;800x600&gt;&quot; -flop</code></td> \n  <td><code>?flip+resize(800x600})+flop</code></td>\n </tr>\n</table></p><p><h2>Extra commands</h2>\n<p>\nThe long list of ImageMagick commands didn't contain some things I wanted to\ndo. I added three 'extra' commands to the script to do this.\n</p></p><p><h3>part</h3>\n<p>\nThe first of these commands is\n<strong><code>part(<i>width</i>x<i>height</i>)</code></strong>. With\nImageMagick's <code>crop</code> command, it is possible to get a part of the\nimage. Unfortunately, this command only accepts absolute parameters. It can\ncrop <i>w</i> by <i>h</i> pixels, starting <i>x</i> pixels from the left and\n<i>y</i> pixels from the top of the image. But what if I want to get 100x100\npixels from the center of the image? That's impossible if I don't know the\nsize of the image.\n</p>\n<p>\nEnter the <code>part</code> command. It resizes the image to match either\nthe preferred width or the preferred height. Then it crops the image to get\nthe center part of that resized image. And that's what I wanted to do.\n</p></p><p><h3>colorizehex</h3>\n<p>\nImageMagick's <code>colorize</code> command accepts only decimal RGB\nnumbers, on a 0 to 100 scale. To colorize with red gives <code>colorize\n100/0/0</code>. This isn't ideal for web use, since html uses hex codes to\nidentify colors. The <strong><code>colorizehex(<i>hex</i>)</code></strong>\ncommand does accept hex colors. It converts them to the ImageMagick\nnotation. Example: a red colorize is done with\n<code>colorizehex(FF0000)</code>.\n</p></p><p><h3>type</h3>\n<p>\nThe <strong><code>type(<i>type</i>)</code></strong> is available in\nImageMagick. It's just not a part of the commands, but is appended to the\nname of the output file (e.g. <code>jpg:output.jpg</code>). I wanted to\ninclude it in the query string, so I made it a command. You can now convert\nthe image to jpeg by using <code>type(jpg)</code> in your query. \n</p> </p><p><h2>Before we start</h2>\n<p>\nThere are just two minor points left before we can start coding.\n</p></p><p><h3>Do you have ImageMagick?</h3>\n<p>\nImageMagick should be installed on your system before you can use it in your\nscripts. This means you will either have to <a\nhref="http://www.imagemagick.com/" target="_new"\ntitle="Download ImageMagick (Link opens in a new window)">install</a>\nit yourself, or have your server admin do it for you.\n</p>\n<p>\nIf your server is running PHP in <a\nhref="http://www.php.net/manual/en/features.safe-mode.php" target="_new"\ntitle="Read more about safe mode (Links opens in a new window)">safe\nmode</a>, which it is likely to be if you're using a (free) shared host,\nyour scripts don't have the right to execute shell commands. As this script\nruns ImageMagick as a shell command, you won't be able to use it. You could\na. ask your hosting provider to disable safe mode or b. use the <a\nhref="http://www.evolt.org/article/Automated_Creation_of_Thumbnails_With_PHP/20/24498/index.html"\ntitle="Automated Creation of Thumbnails With PHP">GD library</a> to generate\nyour images. ImageMagick is far more powerful than the GD library, but you\ncan use the latter even in safe mode.\n</p></p><p><h3>Why write your own script?</h3>\n<p>\nDirectly running convert isn't the only way to use ImageMagick in your scripts.\nThe <a href="http://pear.php.net/package-info.php?pacid=76" target="_new"\ntitle="Imagick, part of PEAR (Link opens in a new window)">Imagick</a>\nmodule from the PEAR library,\n<a href="http://www.imagemagick.com/www/perl.html" target="_new"\ntitle="PerlMagick, for Perl (Link opens in a new window)">PerlMagick</a>,\na Perl interface to ImageMagick, can do this too. Then why bother and write\nyour own script? Because it gives you a far more flexible system. You just\nenter your commands as the query string, and the script just sends them to\nImageMagick. The PEAR module, for instance, has a special PHP function for\neach ImageMagick command. The script would have to translate the commands to\nthe corresponding functions, for which it would need an array with all\npossible commands and functions. The direct method, withouth PEAR module, is\ntherefore faster to write. \n</p></p><p><h2>The script</h2>\n<p>\nAnd, finally, here's the script that makes it all possible. If you copy all\nparts, you'll end up with one script. Place it in your image directory, and\nit's ready for use.\n</p></p><p><h3>Configuration</h3>\n<p>\nYou can specify where your images are and where you want the script to cache\nthe processed images. It defaults to the current directory, which is probably\nwhere you want it. If the <code>convert</code> utility isn't available in the\nPATH environment variable of your web server, you'll need to specify the full\npath.\n</p>\n<pre>\n&lt;?php\n//  location of source images (no trailing /)\n$image_path = '.';</p><p>//  location of cached images (no trailing /)\n$cache_path = '.';</p><p>//  location of imagemagick's convert utility\n$convert_path = 'convert';\n</pre></p><p><h3>Check input</h3>\n<p>\nThe path and file name of the requested image is available as\n<code>$_SERVER['PATH_INFO']</code>. We need to check that such information is\ngiven, and that the file exists.\n</p>\n<pre>\n// first, check if an image location is given\nif (!isset($_SERVER['PATH_INFO'])) {\n    die('ERROR: No image specified.');\n}\n$image = $image_path.$_SERVER['PATH_INFO'];</p><p>// next, check if the file exists\nif (!file_exists($image)) {\n    die('ERROR: That image does not exist.');\n}\n</pre></p><p><h3>Parse commands</h3>\n<p>\nWe need a regular expression to parse the query string and extract commands\nand parameters.\n</p>\n<pre>\n// extract the commands from the query string\n// eg.: ?resize(....)+flip+blur(...)\npreg_match_all('/\+*(([a-z]+)(\(([^\)]*)\))?)\+*/',\n               $_SERVER['QUERY_STRING'],\n               $matches, PREG_SET_ORDER);\n</pre>\n<p>\nWe now have an array <code>$matches</code>. Each element in that array is\nanother array, with in the third element (position 2) the command name and\non position 4 the parameters.\n</p>\n<p>\nThe cache file name will contain the name of the original file. We then add\nthe commands and parameters to it, so we get an unique name for each version\nof the image.\n</p>\n<pre>\n// concatenate commands for use in cache file name\n$cache = $_SERVER['PATH_INFO'];\nforeach ($matches as $match) {\n    $cache .= '%'.$match[2].':'.$match[4];\n}\n$cache = str_replace('/','_',$cache);\n$cache = $cache_path.'/'.$cache;\n$cache = escapeshellcmd($cache);\n</pre></p><p><h3>Run convert</h3>\n<p>\nNow that we have the cache file name, we can look if we already have a cached\nversion of the requested image. If we do, we can just send that to the\nbrowser. If we don't, we will ask <code>convert</code> to create it.\n</p>\n<p>\nWe will add each command to the string <code>$commands</code>. We will send\nthat string to <code>convert</code> to generate the image.\n</p>\n<pre>\nif (!file_exists($cache)) {\n    // there is no cached image yet, so we'll need to create it first</p><p>    // convert query string to an imagemagick command string\n    $commands = '';\n    foreach ($matches as $match) {\n        // $match[2] is the command name\n        // $match[4] the parameter\n    \n        // check input\n        if (!preg_match('/^[a-z]+$/',$match[2])) {\n            die('ERROR: Invalid command.');\n        }\n        if (!preg_match('/^[a-z0-9\/{}+-<>!@%]+$/',$match[4])) {\n            die('ERROR: Invalid parameter.');\n        }\n    \n        // replace } with &gt;, { with &lt;\n        // > and < could give problems when using html\n        $match[4] = str_replace('}','&gt;',$match[4]);\n        $match[4] = str_replace('{','&lt;',$match[4]);\n</pre>\n<p>\nAfter we've checked the input and converted { to &lt; and } to &gt;, we will\nadd this command to the <code>$convert</code> string. But, since we used our\nown, special commands, we will have to check if this command is one of them.\nIf it is, we will have to do a bit more work.\n</p>\n<p>\nThe <code>colorizehex</code> is quite simple. We will convert hex to decimal,\nand then convert the 0-255 scale to ImageMagick's 0-100.\n</p>\n<pre>\n        // check for special, scripted commands\n        switch ($match[2]) {\n            case 'colorizehex':\n                // imagemagick's colorize, but with hex-rgb colors\n                // convert to decimal rgb\n                $r = round((255 - hexdec(substr($match[4], 0, 2))) / 2.55);\n                $g = round((255 - hexdec(substr($match[4], 2, 2))) / 2.55);\n                $b = round((255 - hexdec(substr($match[4], 4, 2))) / 2.55);\n    \n                // add command to list\n                $commands .= ' -colorize &quot;'.&quot;$r/$g/$b&quot;.'&quot;';\n                break;\n</pre></p><p><p>\nThe <code>part</code> command requires more work. We first get the size of the\nsource image using the <code>getimagesize()</code> function. After that we\nlet ImageMagick resize the image to match either the new width or the new\nheight. We want one of the image's dimensions to be equal to the new size, and\nthe other one to exceed that size. We can then crop the image to the requested\nsize.\n</p>\n<pre>\n            case 'part':\n                // crops the image to the requested size\n                if (!preg_match('/^[0-9]+x[0-9]+$/',$match[4])) {\n                    die('ERROR: Invalid parameter.');\n                }</p><p>                list($width, $height) = explode('x', $match[4]);\n    \n                // get size of the original\n                $imginfo = getimagesize($image);\n                $orig_w = $imginfo[0];\n                $orig_h = $imginfo[1];\n    \n                // resize image to match either the new width\n                // or the new height\n    \n                // if original width / original height is greater\n                // than new width / new height\n                if ($orig_w/$orig_h &gt; $width/$height) {\n                    // then resize to the new height...\n                    $commands .= ' -resize &quot;x'.$height.'&quot;';\n    \n                    // ... and get the middle part of the new image\n                    // what is the resized width?\n                    $resized_w = ($height/$orig_h) * $orig_w;\n    \n                    // crop\n                    $commands .= ' -crop &quot;'.$width.'x'.$height.\n                                 '+'.round(($resized_w - $width)/2).'+0&quot;';\n                } else {\n                    // or else resize to the new width\n                    $commands .= ' -resize &quot;'.$width.'&quot;';\n    \n                    // ... and get the middle part of the new image\n                    // what is the resized height?\n                    $resized_h = ($width/$orig_w) * $orig_h;\n    \n                    // crop\n                    $commands .= ' -crop &quot;'.$width.'x'.$height.\n                                 '+0+'.round(($resized_h - $height)/2).'&quot;';\n                }\n                break;\n</pre></p><p><p>\nThe <code>type</code> command is really simple. We can just save the type name\nfor now.\n</p>\n<pre>\n            case 'type':\n                // convert the image to this file type\n                if (!preg_match('/^[a-z]+$/',$match[4])) {\n                    die('ERROR: Invalid parameter.');\n                }\n                $new_type = $match[4];\n                break;\n</pre></p><p><p>\nIf this command isn't special, we can simply add the command and parameters to\nthe command string.\n</p>\n<pre>\n            default:\n                // nothing special, just add the command\n                if ($match[4]=='') {\n                    // no parameter given, eg: flip\n                    $commands .= ' -'.$match[2].'';\n                } else {\n                    $commands .= ' -'.$match[2].' "'.$match[4].'"';\n                }\n        }\n    }\n</pre></p><p><p>\nAfter we've run through the array we've got a list of commands in\n<code>$commands</code>. We can now run <code>convert</code>.\n<code>convert</code> needs the commands, the location of the source image and\nthe location of the output image to work. If a new file type is specified, we\nadd that type and a colon to the output file name.\n</p>\n<pre>\n    // create the convert-command\n    $convert = $convert_path.' '.$commands.' "'.$image.'" ';\n    if (isset($new_type)) {\n        // send file type-command to imagemagick\n        $convert .= $new_type.':';\n    }\n    $convert .= '"'.$cache.'"';</p><p>    // execute imagemagick's convert, save output as $cache\n    exec($convert);\n}\n</pre></p><p><h3>Output</h3>\n<p>\nThe <code>$cache</code> variable should now point to the file containing the\nrequested image. It was already cached or it was generated by\n<code>convert</code>. If the file exists, we can retrieve some information\nabout that image to put in the http headers.\n</p>\n<pre>\n// there should be a file named $cache now\nif (!file_exists($cache)) {\n	die('ERROR: Image conversion failed.');\n}</p><p>// get image data for use in http-headers\n$imginfo = getimagesize($cache);\n$content_length = filesize($cache);\n$last_modified = gmdate('D, d M Y H:i:s',filemtime($cache)).' GMT';</p><p>// array of getimagesize() mime types\n$getimagesize_mime = array(1=>'image/gif',2=>'image/jpeg',3=>'image/png',\n                           4=>'application/x-shockwave-flash',5=>'image/psd',\n                           6=>'image/bmp',7=>'image/tiff',8=>'image/tiff',\n                           9=>'image/jpeg',\n                           13=>'application/x-shockwave-flash',\n                           14=>'image/iff');\n</pre></p><p><p>\nWe can now check if the browser sent us a If-Modified-Since header. This is\nused to update the browser cache. If the If-Modified-Since date of the browser\nis equal to the date the image was last modified, we don't have to send the\nimage again. The cache of the browser still has an updated version.\n</p>\n<pre>\n// did the browser send an if-modified-since request?\nif (isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {\n	// parse header\n	$if_modified_since = preg_replace('/;.*$/', '', $_SERVER['HTTP_IF_MODIFIED_SINCE']);</p><p>	if ($if_modified_since == $last_modified) {\n		// the browser's cache is still up to date\n		header("HTTP/1.0 304 Not Modified");\n		header("Cache-Control: max-age=86400, must-revalidate");\n		exit;\n	}\n}\n</pre></p><p><p>\nThe browser does really want a (new) version of the image. We send some headers\nand then the image.\n</p>\n<p>\nThe <code>Content-Type</code> header is a bit special. We have to send a MIME\ncontent type, but the PHP <code>getimagesize()</code> command only gives us\nthe number of the image type. With the <code>$getimagesize_mime</code> array\nwe can find the MIME type of that number. In case there is no number we use\nthe <code>application/octet-stream</code> type. I haven't tested that, but\nit's probably better than <code>text/html</code>. (Note: Starting with\nPHP 4.3, <code>getimagesize()</code> does return a MIME type. I didn't use it\nto make the script compatible with older versions.)\n</p>\n<pre>\n// send other headers\nheader('Cache-Control: max-age=86400, must-revalidate');\nheader('Content-Length: '.$content_length);\nheader('Last-Modified: '.$last_modified);\nif (isset($getimagesize_mime[$imginfo[2]])) {\n	header('Content-Type: '.$getimagesize_mime[$imginfo[2]]);\n} else {\n	// send generic header\n	header('Content-Type: application/octet-stream');\n}</p><p>// and finally, send the image\nreadfile($cache);</p><p>?&gt;\n</pre></p><p><h2>Concluding</h2>\n<p>\nIf you copied the parts of the script and saved it in your image directory,\nit's ready for use. Just enter the url to the script, a slash, then the name\nof your image and a query string. You should now get the image, modified to\nsuit your needs.\n</p>\n<p>\nFor those of you who don't like to copy-paste: you can download the <a\nhref="http://gvtulder.f2o.org/evolt/magick/magick.php.txt" target="_new"\ntitle="Download the full script (Link opens in a new window)">full script</a>.\n</p></p><p><h3>Tip</h3>\n<p>\nMaybe you don't like the ugly <code>.php</code> part in\nyour url (I don't). You can edit your Apache's configuration file, or\nplace a .htaccess file in your images directory and add the line:\n</p>\n<pre>\nDefaultType application/x-httpd-php\n</pre>\n<p>\nYou can then rename the script to something without <code>.php</code> (ie. just\n<code>magick</code>). The url is now much nicer.\n</p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
