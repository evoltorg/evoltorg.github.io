<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Use Oracle S Explain Plan To Tune Your Queries</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Use Oracle S Explain Plan To Tune Your Queries</h2>
<p class="meta">24 Aug 2000</p>

<div class="post">
<h2>Introduction</h2>\n<P>Query speed is a perpetual challenge for anyone using a SQL database. Many \n  newer Oracle Users are unaware of the issues involved with designing a good \n  query and those who have been at the game for some time want to make sure they \n  are not needlessly burdening the database server. If you use Oracle, Explain \n  Plan is a great way to tune your queries. As a bonus for using Explain Plan, \n  you will learn more about how the DBMS works &quot;behind the scenes&quot;, \n  enabling you to write efficient queries the first time around</P>\n<h2>Using Explain Plan</h2>\n<P>What does Explain Plan do? Explain Plan executes your query and records the \n  &quot;plan&quot; that Oracle devises to execute your query. By examining this \n  plan, you can find out if Oracle is picking the right indexes and joining your \n  tables in the most efficient manner. There are a few different ways to utilize \n  Explain Plan. I will focus on using it through SQL*Plus since most Oracle programmers \n  will have access to SQL*Plus.</P>\n<P>The first thing you will need to do is make sure you have a table called plan_table \n  available in your schema. The following SQL will create it for you if you don't \n  have it:</P>\n<pre>\nCREATE TABLE plan_table\n (\n  statement_id               VARCHAR2(30),\n  timestamp                  DATE,\n  remarks                    VARCHAR2(80),\n  operation                  VARCHAR2(30),\n  options                    VARCHAR2(30),\n  object_node                VARCHAR2(128),\n  object_owner               VARCHAR2(30),\n  object_name                VARCHAR2(30),\n  object_instance            NUMBER,\n  object_type                VARCHAR2(30),\n  optimizer                  VARCHAR2(255),\n  search_columns             NUMBER,\n  id                         NUMBER,\n  parent_id                  NUMBER,\n  position                   NUMBER,\n  other                      LONG\n )\n \n</pre>\n<p>Next, you can run the following script to get a list of the steps that Oracle \n  will perform in order to execute your query:</p>\n<pre>\nset echo on</p><p>delete from plan_table\n where statement_id = 'MINE';\ncommit;\nCOL operation   FORMAT A30\nCOL options     FORMAT A15\nCOL object_name FORMAT A20\nEXPLAIN PLAN set statement_id = 'MINE' for\n/* ------ Your SQL here ------*/\nselect *\n  from scott.salgrade</p><p>/*----------------------------*/\n/</p><p>set echo off</p><p>select operation, options, object_name\n  from plan_table\n where statement_id = 'MINE'\nstart with id = 0\nconnect by prior id=parent_id and prior statement_id = statement_id;\nset echo on\n</pre>\n<h2>Making Use of Indexes</h2>\n<p>Making sure your query is using indexes to find rows faster is the most basic \n  use of Explain Plan. We will examine this process first. When the aforementioned \n  script is run with the query &quot;select * from scott.salgrade&quot;, this \n  is the output we will see:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nTABLE ACCESS                   FULL            SALGRADE\n</pre>\n<p>What this tells us is that in order to execute the SELECT STATEMENT, Oracle \n  will access the table SALGRADE using a FULL table scan. In other words the DBMS \n  will read every record in SALGRADE. You would expect this result for a query \n  with no where clause. What if we want to look for the record for salary grade \n  #1. We will limit our results using the GRADE column in SALGRADE and our query \n  will look like this:</p>\n<code>select *<br>\n  from scott.salgrade<br>\n where grade = 1<br>\n</code>\n<p>But our plan looks the same. Oracle still has to read every row in the table \n  to find all rows with the grade = 1 because there is no index on that column. \n  Since, GRADE should be the primary key of the SALGRADE table, we will create \n  a primary key constraint on that column. After creating the primary key constraint \n  (which creates a related unique index), and running the plan script again, our \n  plan looks like this:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          UNIQUE SCAN     SALGRADE_PK\n</pre>\n<p>This time Oracle ran a unique scan on the SALGRADE_PK index and then went directly \n  to the row we wanted in the SALGRADE table using the ROWID. An index scan is \n  much faster than a full table scan so the result of our query is sure to come \n  back nearly instantaneously, even if our table has millions of rows.</p>\n<p> What if we had simply created a non-unique index instead of a primary (unique) \n  key? Our plan would have looked like this:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          RANGE SCAN      SALGRADE_IDX1\n</pre>\n<p>This is a slightly slower path for Oracle to take. Notice that the OPTIONS \n  column says RANGE SCAN instead of UNIQUE SCAN. This is because it has to scan \n  for multiple records with the same value in the index in case there is more \n  than one row. If this was the case, our query speed would depend on the uniqueness \n  of our data. Assuming a fairly large table size, we can illustrate this dependance \n  using two extreme cases. In the first extreme case, GRADE is totally unique \n  (even though the index is non-unique). Because of this uniqueness, Oracle will \n  be able to find the row it needs quite quickly and bring back the results. In \n  the second extreme case, there are only a few different values for GRADE distributed \n  among many rows. Because of this non-uniqueness, Oracle will have to scan through \n  many values in the index to find the ones it wants, finalizing the results some \n  time later.</p>\n<p>Most of the time, when you write your queries, the data model will have already \n  been built to match the purpose of the application. To maximize your application's \n  speed, use criteria that will allow Oracle to use the fastest (most unique) \n  indexes on a given table.</p>\n<h2>Joining Tables Efficiently</h2>\n<p>Sometimes we use slower (less unique) indexes in small to medium sized tables \n  and don't notice that our application is slower than it should be. However, \n  when joining tables, you will notice a difference if you are not using the optimal \n  query plan. The key to making joins faster is making your query select from \n  the table that will return the least number of records first and then use the \n  information gained from the first table to make subsequent searches more unique. \n  The following query retrieves the employee and salary records for employee #1:</p>\n<code>\nselect *<br>\n  from emp e, salgrade s<br>\n where empid   = 1<br>\n   and s.grade = e.grade<br>\n</code>\n<p>Given a unique index on EMPID in the EMP table and on GRADE in the SALGRADE \n  table, Oracle's plan will look like this:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nNESTED LOOPS\nTABLE ACCESS                   BY INDEX ROWID  EMP\nINDEX                          UNIQUE SCAN     EMP_PK\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          UNIQUE SCAN     SALGRADE_PK\n</pre>\n<p>The NESTED LOOPS operation indicates that Oracle will look for rows in GRADE \n  for each row in EMP that it finds. We have an efficient query because Oracle \n  is searching for our EMPID = 1 first and then looking for 1's GRADE. If Oracle \n  had looked in SALGRADE first, it would have had to read all rows in that table \n  because it wouldn't know what the GRADE of EMPID = 1 was. In this case, it would \n  be hard to write an inefficient query because we are searching on criteria that \n  are by definition unique (and fast). What if we had to search on fields with \n  a low level of uniqueness? Examine the following query, which searches for employees \n  with low salaries (LOSAL) between 10000 and 30000:</p>\n<code>select *\n  from emp e, salgrade s\n where s.grade = e.grade\n   and s.losal between 10000 and 30000</code>\n<p>We will get this plan from Oracle:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nNESTED LOOPS\nTABLE ACCESS                   FULL            EMP\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          UNIQUE SCAN     SALGRADE_PK\n</pre>\n<p>Under the circumstances, this is the best we could have done. Oracle scans \n  the employee table (all of it) because it can narrow that table the most using \n  the given criteria. Hypothetically, there are a couple of ways to speed up this \n  query. One way is to use some criteria on the EMP table that is indexed. if \n  we assume a non-unique index on EMP.NAME (EMP_IDX2), and have some sort of criteria \n  we can use for NAME, we could narrow our results from EMP more quickly. Let's \n  get the employee and salary records for all employees whose names start with \n  'SM' and whose low salaries are between 10000 and 30000, like so:</p>\n<code>select *<br>\n  from emp e, salgrade s<br>\n where e.name like 'SM%'\n   and s.grade = e.grade<br>\n   and s.losal between 10000 and 30000<br>\n</code>\n<p>We will get this plan from Oracle: <br>\n</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nNESTED LOOPS\nTABLE ACCESS                   BY INDEX ROWID  EMP\nINDEX                          RANGE SCAN      EMP_IDX2\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          UNIQUE SCAN     SALGRADE_PK\n</pre>\n<p>The criteria on NAME could narrow our search fairly quickly. The actual speed \n  will depend on the uniqueness of the NAME column. If all of our employees are \n  named SMITH and SMYTHE and SMALL, the criteria will not help much. Given an \n  even distribution of names, the criteria will help a lot.</p>\n<p>What if we didn't have the option to narrow down the result set by NAME? We \n  might want to consider creating an index on the SALGRADE.LOSAL and another index \n  on EMP.GRADE if this query is used often. Given a non-unique index on SALGRADE.LOSAL, \n  a non-unique index on EMP.GRADE and this query:<br>\n</p>\n<code>select *<br>\n  from emp e, salgrade s<br>\n where s.grade = e.grade<br>\n   and s.losal between 10000 and 30000<br> \n</code>\n<p>Oracle will produce this plan:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nNESTED LOOPS\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          RANGE SCAN      SALGRADE_IDX2\nTABLE ACCESS                   BY INDEX ROWID  EMP\nINDEX                          RANGE SCAN      EMP_IDX3\n</pre>\n<p>Oracle now will search for the appropriate salary grades first and then all \n  employees with that grade.</p>\n<h2>Using the fastest indexes in a Join</h2>\n<p>Up until now, we have been striving to use any avaliable index. More complicated \n  issues arise when trying to decide which of two or three indexes is faster. \n  In the case that are looking for names starting with 'SM' and low salaries between \n  10000 and 30000 and all the indexes given up to this point, we will probably \n  have to tell Oracle which table to search first, in order to get results as \n  quickly as possible. We can do that by changing the order of the tables in the \n  from clause. This query:</p>\n<code>select *<br>\n  from emp e, salgrade s<br>\n where e.name like 'SM%'<br>\n   and s.grade = e.grade<br>\n   and s.losal between 10000 and 30000<br>\n</code>\n<p>Will produce this plan:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nNESTED LOOPS\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          RANGE SCAN      SALGRADE_IDX2\nTABLE ACCESS                   BY INDEX ROWID  EMP\nINDEX                          RANGE SCAN      EMP_IDX3\n</pre>\n<p>The plan indicates that Oracle looks at SALGRADE.LOSAL first and EMP.NAME second. \n  The choice is made because SALGRADE comes last in the from clause. If Oracle \n  can't decide which table is better to go with first, it will read the from clause \n  from right to left. This is great if SALGRADE.LOSAL is more unique than EMP.NAME. \n  However, what if searching for EMP.NAME starting with 'SM' will return fewer \n  rows than searching for SALGRADE.LOSALs between 10000 and 30000? Simply switch \n  the tables in the from clause to produce the opposite result:</p>\n<code>\n select *\n   from salgrade s, emp e\n  where e.name like 'SM%'\n    and s.grade = e.grade\n    and s.losal between 10000 and 30000</code>\n<p>This query produces this plan:</p>\n<pre>\nOPERATION                      OPTIONS         OBJECT_NAME\n------------------------------ --------------- --------------------\nSELECT STATEMENT\nNESTED LOOPS\nTABLE ACCESS                   BY INDEX ROWID  EMP\nINDEX                          RANGE SCAN      EMP_IDX2\nTABLE ACCESS                   BY INDEX ROWID  SALGRADE\nINDEX                          UNIQUE SCAN     SALGRADE_PK\n</pre>\n<p>EMP.NAME is queried first because we instructed Oracle to do so.</p>\n<h2>Utilizing Multiple Column Indexes</h2>\n<p>Multiple-column indexes will eventually make their way into your database applications. \n  In order to use the index, we have to search on the first column before searching \n  on the second column in the index and the criteria for the second column will \n  not help us if our criteria for the first column are not very unique. Also keep \n  in mind that in order to get a fully unique search on a unique multi-column \n  index, we have to limit all columns in the index. </p>\n<h2>Conclusion</h2>\n<p>Remember that by utilizing Explain Plan you can explore the differences that \n  subtle changes in your query make in the way Oracle executes your query. In \n  a short time you will be writing very fast queries. \n</p>\n<p>\nBy <a href="mailto:apatrick@oracular.com">Adam Patrick</a></p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
