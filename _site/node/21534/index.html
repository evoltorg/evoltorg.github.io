<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>An Introduction To The Perl Dbi</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">evolt.org</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>An Introduction To The Perl Dbi</h2>
<p class="meta">21 Feb 2002</p>

<div class="post">
<h2>Introduction</h2></p><p><p><acronym title="Database Independent">DBI</acronym> is a Perl module that makes it possible to use Perl to access\nmany different types of databases though a single API that works\nindependently of the actual database being used. This means that the\nprogrammer is able to use the DBI module (Database Independent) to\ntalk to a MySQL database, a DB2 database, an Oracle database, and many\nothers using the same DBI-specific variables and function\ncalls. Although there are also many functions built into the DBI for\nspecific database engines, the core functionality is always the\nsame. This functionality makes DBI a very powerful programming tool,\nbut after a brief introduction, you will notice that the DBI is also\nvery accessible and easy to understand; programmers require knowledge\nof only a few key features to get started writing scripts to perform\nany number of database tasks.</p></p><p><h2>How it All Works</h2></p><p><p>There are three tiers within every Perl DBI application. The first\nlayer is the Perl script itself, which uses the DBI Application\nProgram Interface (the objects, functions and variables predefined by\nthe DBI) to interact with the database. The middle layer is the DBI,\nwhose main responsibility is to pass those DBI-specific instructions\nto the appropriate database driver. The third layer is the <acronym title="Database Dependent">DBD</acronym>\n(Database Dependent) layer, which is the driver for the specific\ndatabase engine you are using.</p></p><p><h2>Example: The Postcard Application</h2></p><p><p>Let's say I have a collection of postcards, and in order to keep\nthem organized, I have entered information about them into a MySQL\ndatabase. Then let's say that I want to show those postcards off to\nvisitors to my website. Because I have only CGI available on my web\nserver, I decide the best way to do that is through a CGI\napplication. I start out my application like this:</p></p><p><pre>\n#!/usr/bin/perl -w</p><p>use CGI("standard");\nuse DBI;\n</pre></p><p><p>This bit of code first specifies this as a Perl script. Then it makes\nthe Perl CGI module available (this module automates some HTML writing\nand means less typing). The last line makes available the DBI module.</p></p><p><p>My next step is to define some variables for the database and\nconnect to it:</p></p><p><pre>\nmy $datasource = "DBI:mysql:postcards:localhost";\nmy $user = "greg"\nmy $passwd = "greatpostcards";\n</pre></p><p><p>If you have ever written any sort of application that has a\ndatabase interface, this information should look familiar to\nyou. However, note that the syntax of the <code>$datasource</code>\nvariable is a bit unique. The pattern, which seems at first to be\ncounter-intuitive, works like this: <code>DBI:[DBD driver]:[database name]:[database host]</code>.</p></p><p><p>Remember that DBI applications are designed to easily talk to many\ndifferent types of databases. Specifying the type of database you\nwant to use in your application is as easy as changing a single part\nof the string held in the <code>$datasource</code> variable. So, now that all of\nmy connection information has been defined, my next step is to\ncreate a connection object. That's as easy as adding the following to my\napplication: <code>my $dbh = DBI->connect($datasource,$user,$passwd);</code>.</p></p><p><p>The string contained in the <code>$datasource</code> variable is\nsaying, &quot;hey, DBI! Use the mysql database dependent module to\naccess the postcards database that exists on the computer named\nlocalhost.&quot;</p></p><p><p>Now that I have defined my connection object, my next step is to\nprepare an SQL statement. I can do that by using the (you guessed it)\nprepare method:</p></p><p><pre>\nmy $sth = $dbh->prepare("SELECT postcard.*,\n                         location.*\n                         sender.*\n                         FROM postcard\n                         LEFT JOIN location ON postcard.location_id = location.location_id,\n                         LEFT JOIN sender ON postcard.sender_id = sender.sender_id\n                         WHERE postcard.pc_id = ?;");\n</pre></p><p><p>Now, with the SQL statement prepared, my next step is to execute\nit. We do that by employing the execute method: <code>$sth->execute($dynamicvariable);</code></p><p><p>Everything might seem pretty clear in these two lines, except you\nmight notice the question mark in the SQL statement and the\n<code>$dynamicvariable</code> we pass to it when we invoke the execute method. This\nis a feature of the Perl DBI, which allows me to pass any number of\nvariables to my SQL statement before it is executed. The value of\nthese variables then fits into the question mark placeholders, in\nthe order they are passed. (So I should be sure that the variables I pass go\nin the right order!) If my application does not require me to\npass dynamic values to my SQL statement, I would have simply called the\nexecute method without any parentheses, like this: <code>$sth->execute;</code></p></p><p><p>Now, for the final step in my application, I need a way of\ngetting at the contents of the record set that the execute method\nreturns. As is always the way with Perl, there are a billion different\nways of doing this. But since I'm dealing with rows of data, the\n<code>fetchrow_array</code> works well, because it allows me to loop through the\nreturned row as an array.</p></p><p><pre>\nmy @array = $sth->fetchrow_array;\nmy $i;\nfor $i (0..$#array) {\n    print $array[$i],"\n";\n}\n</pre></p><p><p>As I have already mentioned, I have many other DBI\nfunctions at my disposal at this point. The\n<code>fetchrow_arrayref</code> will return the database row as an\narray reference. The <code>fetchrow_hashref</code> will return it as a\nhash reference (this is especially handy if you have a lot of rows and\nyou want to key them up by their column names; if you're like me, you tend to\nremember names better than numeric values). And there are many\nothers. Be sure to read the documentation to find the function that\nmost suits your needs and programming behaviors.</p></p><p><p>My next step is to clean up my program. Though clearing memory and\nclosing database connections is not always necessary, it is good\nprogramming practice (not to mention easy to do). So I recommend\nit. Here's all you have to do:</p></p><p><pre>\n$sth->finish;\n$dbh->disconnect;\n</pre></p><p><p>Once that's done, I'm done with my postcard\napplication. But beyond the simple API demonstrated by the code\nsnippets above, it may not be exactly clear why the Perl DBI is\nvaluable. Here are some benefits I have found.</p></p><p><h2>Why You Might Care About This</h2></p><p>\n<ul>\n<li>Ubiquity: The Perl DBI module is included with the default\ninstall of any relatively new version of Perl. So if you have access\nto a UNIX-based system, you should be able to start programming the\nPerl DBI.</li></p><p><li>Easy Integration: Because it's a Perl module, database functionality\ncan be easily integrated into existing Perl/CGI applications.</li></p><p><li>Simplicity and Power: being able to talk to a wide variety of\ndatabases with Perl (and even within a single Perl script) makes\nmassive exports and/or imports of data even much more manageable\n(anyone who has had the job of upgrading a corporate RDBMS can see the\nvalue in this, I'm sure).</li>\n</ul></p><p><h2>Further Reading and DBI Resources</h2></p><p><p>You can start your search for Perl DBI information just about anywhere\non the web. There is the <a href="http://www.cpan.org/" target="_blank" title="Comprehensive Perl Archive Network">Database Interfaces section of the CPAN website</a>, there are <a href="http://groups.google.com/groups?hl=en&group=comp.lang.perl" target="_blank" title="Perl-oriented news groups at groups.google.com">Perl-oriented\nnewsgroups</a>. However, the best places to\nstart reading about Perl DBI is either by checking out <a href="http://dbi.symbolstone.org/index.html" target="_blank" title="Symbolstone: everything you want to know about DBI">Symbolstone</a>,\nthe central resource for Perl DBI and DBD modules and documentation on\nthe Web, or else just running the <code>perldoc DBI</code> command at your local\nUNIX prompt. Generally the information is accessible and easy to understand, and\nwill help you further as you get started.</p></p><p><h2>Conclusion</h2></p><p><p>Notwithstanding all of the pitfalls and shortcomings of Perl\nprogramming generally, the power, simplicity, and accessibility of the Perl DBI\nmake it worth understanding. And even though it has the ability to\nwork well with the most complex development projects, it's easy\nenough to learn in time for your next Web administration crisis as well.</p>
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
